## vue2.x 的响应式

### 实现原理:

- 对象类型: 通过 `Object.defineProperty()` 对属性的读取、修改进行拦截（数据劫持）。

- 数组类型: 通过重写更新数组的一系列方法来实现拦截。（对数组的变更方法进行了包裹）。

```javascript
Object.defineProperty(data, "count", {
  get() {},
  set() {},
});
```

## Vue3.0 的响应式

### 实现原理:

- 通过 **Proxy(代理)**: 拦截对象中任意属性的变化，包括属性值的读写、属性的添加、属性的删除等。

- 通过 **Reflect(反射)**: 对被代理对象的属性进行操作。

## defineProperty

```js
let person = {
  name: "张三",
  age: 18,
};

let p = {};
Object.defineProperty(p, "name", {
  get() {
    // 有人读取name时调用
    return person.name;
  },
  set(value) {
    // 有人修改name时调用
    console.log("有人修改了name属性,我发现了,我要去更新界面!");
    person.name = value;
  },
});

Object.defineProperty(p, "age", {
  get() {
    // 有人读取age时调用
    return person.age;
  },
  set(value) {
    // 有人修改age时调用
    console.log("有人修改了age属性，我发现了，我要去更新界面!");
    person.age = value;
  },
});
```

### Vue2 真实实现

```javascript
export default {
  name: "App",
  data() {
    return {
      person: {
        name: "张三",
        age: 18,
        hobby: ["学习", "吃饭"],
      },
    };
  },
  methods: {
    addSex() {
      // console.log(this.person.sex)
      // this.person.sex = '女'
      // console.log(this.person.sex)

      this.$set(this.person, "sex", "女");
      // Vue.set(this.person, 'sex', '女')
    },
    deleteName() {
      // console.log(this.person.name)
      // delete this.person.name
      // console.log(this.person.name)

      // this.$delete(this.person, 'name')
      Vue.delete(this.person, "name", "女");
    },
    updateHobby() {
      // this.person.hobby[0] = '逛街'
      // this.$set(this.person.hobby, 0, '逛街')
      // this.person.hobby.splice(0, 1, '逛街')
    },
  },
};
```

## Proxy

```js
let person = {
  name: "张三",
  age: 18,
};
const p = new Proxy(person, {
  // 有人读取p的某个属性时调用
  get(target, propName) {
    console.log(`有人读取了p身上的${propName}属性`);
    return target[propName];
  },
  // 有人修改p的某个属性、或给p追加某个属性时调用
  set(target, propName, value) {
    console.log(`有人修改了p身上的${propName}属性，我要去更新界面了!`);
    target[propName] = value;
  },
  // 有人删除p的某个属性时调用
  deleteProperty(target, propName) {
    console.log(`有人删除了p身上的${propName}属性，我要去更新界面了!`);
    return delete target[propName];
  },
});
```

## Reflect.defineProperty

> 目前正在将 Object 对象的属性移植到 reflect, 它能返回 Boolean 值, 易于捕获错误

```js
const obj = {};

const x1 = Reflect.defineProperty(obj, "c", {
  get() {
    return 3;
  },
});
console.log(x1);

const x2 = Reflect.defineProperty(obj, "c", {
  get() {
    return 4;
  },
});

if (x2) {
  console.log("某某某操作成功了!");
} else {
  console.log("某某某操作失败了!");
}
```

## Vue3 实现

```js
const person = {
  name: "张三",
  age: 18,
};

const p = new Proxy(person, {
  // 有人读取p的某个属性时调用
  get(target, propName) {
    console.log(`有人读取了p身上的${propName}属性`);
    return Reflect.get(target, propName);
  },
  // 有人修改p的某个属性、或给p追加某个属性时调用
  set(target, propName, value) {
    console.log(`有人修改了p身上的${propName}属性，我要去更新界面了!`);
    Reflect.set(target, propName, value);
  },
  // 有人删除p的某个属性时调用
  deleteProperty(target, propName) {
    console.log(`有人删除了p身上的${propName}属性，我要去更新界面了!`);
    return Reflect.deleteProperty(target, propName);
  },
});
```
