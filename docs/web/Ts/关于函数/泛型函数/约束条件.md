## 约束条件

> 泛型约束条件（Generic Constraints）允许你限制泛型参数可以是哪些类型。这通常通过使用 extends 关键字来实现，它指定了泛型参数必须符合特定的类型或接口。

### 泛型约束的基本使用

> 泛型约束通常用于函数或类中，以确保泛型参数满足特定的条件。例如，你可能有一个函数，它需要操作具有 .length 属性的对象。T extends Lengthwise 指定了泛型参数 T 必须实现 Lengthwise 接口，即必须具有 length 属性。

```ts
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length); // 现在我们知道它具有.length属性，因此没有错误
  return arg;
}
```

### 使用类型参数作为约束

> 可以使用另一个类型参数作为当前类型参数的约束。这在你需要基于一个类型参数定义另一个类型参数时非常有用。Key extends keyof T 指定了 Key 必须是 T 的键之一，这样可以确保 obj[key] 是合法的访问

```ts
function getProperty<T, Key extends keyof T>(obj: T, key: Key): T[Key] {
  return obj[key];
}
```

### 类型约束的高级用法

> 泛型约束不仅可以用于接口，还可以用于类型别名、交叉类型等更复杂的类型表达式。例如，你可以创建一个类型别名，它将数组中的元素类型设为只读，但只有当该类型是数组时才生效。在这个类型别名中，如果 T 是数组类型，那么结果类型将是数组元素类型的只读版本。

```ts
type ReadOnlyIfArray<T> = T extends any[] ? Readonly<T[number]> : T;
```
