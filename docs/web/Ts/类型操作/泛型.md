## 泛型

> 泛型是一种强大的工具，它允许你编写可重用的函数、接口和类，这些函数、接口和类可以操作多种类型的数据，而不会失去类型安全性。泛型在编译时提供类型检查，从而帮助你捕捉错误。

### 泛型函数

> 泛型函数可以接收任意类型的参数，并返回相同类型的结果。

```ts
function identity<T>(arg: T): T {
  return arg;
}

const result = identity<string>("hello"); // type is string
const resultNumber = identity<number>(123); // type is number
```

### 泛型接口

> 泛型接口允许你定义操作多种类型的数据的结构，而不需要指定具体的类型。

```ts
interface GenericIdentity<T> {
  (arg: T): T;
}

const identityObject: GenericIdentity<number> = identity;
```

### 泛型类

> 泛型类允许你定义可以操作多种类型的数据的类。

```ts
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function (x, y) {
  return x + y;
};
```

### 泛型约束

> 你可以对泛型参数施加约束，以确保它们支持特定的操作或属性。

```ts
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  // Now we know it has a .length property, so no more error
  console.log(arg.length);
  return arg;
}

loggingIdentity({ length: 10, value: 3 });
```

### 泛型类型别名

> 泛型类型别名为复杂的类型提供了一种简便的命名方式。

```ts
type GenericArray<T> = Array<T>;

let myArray: GenericArray<number> = [1, 2, 3];
```

### 泛型元组

> 元组类型允许你定义已知元素数量和类型的数组，各元素的类型不必相同。

```ts
function tuple<T1, T2, T3>(item1: T1, item2: T2, item3: T3): [T1, T2, T3] {
  return [item1, item2, item3];
}

const x: [string, number, boolean] = tuple("Hello", 10, true);
```

### 泛型工具类型

> 内置的泛型工具类型，如 Partial&lt;T&gt;、Readonly&lt;T&gt;、Pick&lt;T, K&gt; 等，这些类型可以方便地构造新的类型。

```ts
type Point = {
  x: number;
  y: number;
};

type PartialPoint = Partial<Point>;
const p: PartialPoint = { x: 3 }; // OK
```

### Partial&lt;T&gt;

> Partial&lt;T&gt; 类型构造函数用于生成一个类型，其所有属性都是原始类型的属性，但所有属性都是可选的。

```ts
type Point = {
  x: number;
  y: number;
};

type PartialPoint = Partial<Point>;
// { x?: number; y?: number; }

const p: PartialPoint = { x: 3 }; // OK
const p2: PartialPoint = { y: 7 }; // OK
const p3: PartialPoint = {}; // OK
```

### Readonly&lt;T&gt;

> Readonly&lt;T&gt; 类型构造函数用于生成一个类型，其所有属性都是原始类型的属性，但所有属性都是只读的。

```ts
type Point = {
  x: number;
  y: number;
};

type ReadonlyPoint = Readonly<Point>;
// { readonly x: number; readonly y: number; }

const p: ReadonlyPoint = { x: 3, y: 7 };
// Error: Cannot assign to 'x' because it is a read-only property.
// p.x = 4;
```

### Pick&lt;T, K&gt;

> Pick&lt;T, K&gt; 类型构造函数用于生成一个类型，其属性是原始类型中 K 所指定的属性的子集。
> PickedPoint 类型表示一个对象，它只包含原始 Point 类型中的 x 和 y 属性

```ts
type Point = {
  x: number;
  y: number;
  z: number;
};

type PickedPoint = Pick<Point, "x" | "y">;
// { x: number; y: number; }

const p: PickedPoint = { x: 3, y: 7 };
```
