## 模板字面类型

> 模板字面类型（Template Literal Types）是从字符串字面类型构建的，并且可以通过联合类型扩展成多个字符串。它们与 JavaScript 中的模板字面字符串具有相同的语法，但用于类型位置。当与具体的字面类型一起使用时，模板字面通过连接内容生成新的字符串字面类型
> 。

> 定义一个类型，它通过连接一个已知的字符串和一个泛型参数来创建一个新的字符串字面类型:

```ts
type World = "world";
type Greeting = `hello ${World}`;
// Greeting 类型为 "hello world"
```

> 当在插值位置使用联合类型时，类型可以由每个联合成员表示的每个可能的字符串字面类型的集合:

```ts
type EmailLocaleIDs = "welcome_email" | "email_heading";
type FooterLocaleIDs = "footer_title" | "footer_sendoff";
type AllLocaleIDs = `${EmailLocaleIDs | FooterLocaleIDs}_id`;
// AllLocaleIDs 类型为 "welcome_email_id" | "email_heading_id"
// z| "footer_title_id" | "footer_sendoff_id"
```

模板字面类型可以用于创建复杂的类型关系，通过内联字符串插值在类型中。它们与映射类型结合使用时尤其强大，可以基于现有类型定义新类型或接口的变换。

> 可以使用模板字面类型来定义 API 端点的路径:

```ts
interface Routes {
  home: void;
  about: void;
  contact: number;
}

type RouteNames = keyof Routes;
type Path = `/${RouteNames}`;

const homePath: Path = "/home";
// 正确
const loginPath: Path = "/login";
// 错误：类型 '"/login"' 不能分配给类型 'Path'
```

模板字面类型也可以用来确保函数参数之间的关系。

> 创建一个函数，它根据事件名称推断出事件处理函数的参数类型：

```ts
type Event = {
  type: "click" | "mouseover";
} & {
  timestamp: number;
};

function handleEvent(
  eventType: `${"click" | "mouseover"}-event`,
  handler: (event: Event & { type: "click" | "mouseover" }) => void
) {
  // 实现
}

handleEvent("click-event", (event) => {});
// 正确
handleEvent("keypress-event", (event) => {});
// 错误：参数 '"keypress-event"' 不能分配给参数 '"click-event" | "mouseover-event"'
```
