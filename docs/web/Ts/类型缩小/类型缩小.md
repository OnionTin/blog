## 类型缩小(缩小类型范围)

> 类型缩小（Type Narrowing）是指在运行时基于某些条件来减少一个变量可能的类型范围的过程。这通常在处理联合类型或交叉类型时非常有用，允许你根据不同的情况对变量进行更具体的操作。类型缩小是 TypeScript 编程中的一个重要概念，它允许你编写更精确和更安全的代码。通过使用类型缩小可以在不同的代码路径中对变量进行更具体的操作。

### 使用类型谓词

> 类型谓词是一种函数，它对参数的类型进行断言，并返回一个布尔值，表明该参数是否为特定的类型。这可以用来缩小类型。

```ts
function process(x: number | string) {
  if (isNumber(x)) {
    // 在这个块中，TypeScript 知道 x 是一个 number
    x.toFixed(2); // 正确
  } else {
    // 在这个块中，TypeScript 知道 x 是一个 string
    x.toUpperCase(); // 正确
  }
}
function isNumber(x: number | string): x is number {
  return typeof x === "number";
}
```

### 使用字面量类型

> 当你知道变量的值可能是几个特定字面量之一时，可以使用字面量类型进行缩小。

```ts
type Event = "click" | "scroll" | "mousemove";

function handleEvent(event: Event) {
  if (event === "click") {
    // event 被缩小为 'click'
  } else if (event === "scroll") {
    // event 被缩小为 'scroll'
  } else if (event === "mousemove") {
    // event 被缩小为 'mousemove'
  }
}
```

### 使用类型守卫

> 类型守卫是 TypeScript 的一个特性，允许你在运行时检查变量的类型。

```ts
function hasOwnProperty<T, U extends string>(obj: T, key: U): key is keyof T {
  return key in obj;
}

const obj = { name: "Kimi", age: 30 };
if (hasOwnProperty(obj, "name")) {
  // obj 在这里被缩小，包含了 name 属性
  console.log(obj.name); // 正确
} else {
  // 'name' 不是 obj 的属性
}
```

### 使用逻辑运算符

> 逻辑运算符，如 &&，可以用来基于条件缩小类型。

```ts
function isObjectWithKey<T, U extends PropertyKey>(
  obj: T,
  key: U
): obj is T & Record<U, unknown> {
  return key in obj;
}

const result = isObjectWithKey(obj, "name");
if (result) {
  // obj 在这里被缩小，包含了 name 属性
  console.log(obj.name); // 正确
}
```

### 使用自定义类型守卫

```ts
function printInput(x: string | number) {
  if (isStringOrNumber(x)) {
    console.log(x.toUpperCase()); // x 被缩小为 string
  } else {
    console.log(x.toFixed(2)); // x 被缩小为 number
  }
}
function isStringOrNumber(x: string | number): x is string {
  return typeof x === "string";
}
```

### in 运算符

> isBird 函数是一个类型谓词，它使用 in 运算符来检查 animal 是否有 fly 属性。如果 isBird 返回 true，那么在 if 块中，creature 被缩小为 Bird 类型。

```ts
type Bird = {
  fly: () => void;
  layEggs: () => void;
};

type Fish = {
  swim: () => void;
  layEggs: () => void;
};

type Animal = Bird | Fish;

function isBird(animal: Animal): animal is Bird {
  return "fly" in animal;
}

const creature: Animal = { layEggs: () => {}, swim: () => {} };

if (isBird(creature)) {
  // 在这个块中，TypeScript 会将 creature 缩小为 Bird 类型
  creature.fly();
} else {
  // 在这个块中，creature 可能是 Bird 或 Fish
}
```

> 映射类型也使用 in 运算符来动态地构造类型。OptionsFlags 是一个映射类型，它使用 in 运算符来遍历 T 类型的键，并为每个键创建一个相应的布尔属性。

```ts
type OptionsFlags<T> = {
  [K in keyof T]: boolean;
};

type FeatureFlags = {
  darkMode: boolean;
  notifications: boolean;
  betaProgram: boolean;
};

type FeatureOptions = OptionsFlags<FeatureFlags>;
// FeatureOptions 类型为 {
//   darkMode: boolean;
//   notifications: boolean;
//   betaProgram: boolean;
// }
```

### instanceof 运算符

> feed 函数接受一个 Animal 类型的参数。使用 instanceof 运算符检查 pet 是否为 Dog 类的实例。如果是，我们可以安全地调用 bark 方法，因为 TypeScript 的类型检查器现在知道 pet 具体是 Dog 类型。

```ts
class Animal {
  eat() {
    console.log("Eating");
  }
}

class Dog extends Animal {
  bark() {
    console.log("Barking");
  }
}

function feed(pet: Animal) {
  if (pet instanceof Dog) {
    (pet as Dog).bark(); // 类型缩小，现在知道 pet 是 Dog 类型
  } else {
    pet.eat(); // 所有 Animal 都会 eat
  }
}
```

### 其他方式

1. typeof 运算符
2. Array.isArray()
