<!-- @format -->

## 状态提升（Lifting State Up）

状态提升是 React 中用于管理多个组件间共享状态的模式。当多个组件需要访问同一个状态时，你可以将这个状态提升到它们共同的父组件中。状态提升是一种简单有效的状态管理方式，适用于多个组件需要访问共享状态的场景。然而，随着应用规模的增长，可能需要考虑使用更强大的状态管理解决方案。

### 1. 定义状态

在父组件中定义一个状态，并通过 props 将其传递给子组件。

```jsx
class ParentComponent extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      sharedState: ''
    };
  }

  render() {
    return (
      <div>
        <ChildComponentA sharedState={this.state.sharedState} />
        <ChildComponentB sharedState={this.state.sharedState} />
      </div>
    );
  }
}
```

### 2. 子组件访问状态

子组件通过 props 访问状态，并回调到父组件以更新状态。

```jsx
function ChildComponentA({ sharedState }) {
  return (
    <input
      value={sharedState}
      onChange={(e) => this.props.onChange(e.target.value)}
    />
  );
}

function ChildComponentB({ sharedState, onChange }) {
  return (
    <input
      value={sharedState}
      onChange={onChange}
    />
  );
}
```

### 3. 更新状态

子组件通过回调函数更新父组件的状态。

```jsx
class ParentComponent extends React.Component {
  // ...

  handleInputChange = (newState) => {
    this.setState({ sharedState: newState });
  };

  render() {
    return (
      <div>
        <ChildComponentA
          sharedState={this.state.sharedState}
          onChange={this.handleInputChange}
        />
        <ChildComponentB
          sharedState={this.state.sharedState}
          onChange={this.handleInputChange}
        />
      </div>
    );
  }
}
```

### 4. 子组件的独立状态

如果子组件需要独立控制状态，可以使用`useState`在子组件中定义独立状态。

```jsx
function ChildComponentB({ sharedState }) {
  const [localState, setLocalState] = useState('');

  const handleChange = (e) => {
    setLocalState(e.target.value);
  };

  return (
    <input
      value={localState}
      onChange={handleChange}
    />
  );
}
```

### 5. 状态提升的适用场景

- 当多个组件需要访问同一个状态时。
- 当多个组件需要基于同一个状态渲染输出时。
- 当需要在多个组件之间同步状态时。

### 6. 避免过度提升状态

过度提升状态会导致组件过于紧密耦合，难以维护。如果只有少数几个组件需要访问状态，可以考虑其他方式，如 Context API 或状态管理库。

### 7. 状态提升与 Context API

状态提升可以与 Context API 结合使用，以避免深层组件树的 props 钻取。

```jsx
const SharedContext = createContext();

function ParentComponent() {
  const [sharedState, setSharedState] = useState('');

  return (
    <SharedContext.Provider value={[sharedState, setSharedState]}>
      <ChildComponentA />
      <ChildComponentB />
    </SharedContext.Provider>
  );
}

function ChildComponentA() {
  const [sharedState, setSharedState] = useContext(SharedContext);
  return (
    <input
      value={sharedState}
      onChange={(e) => setSharedState(e.target.value)}
    />
  );
}
```

### 8. 状态提升与性能

状态提升可能会影响性能，因为父组件的重新渲染会导致所有子组件的重新渲染。可以通过性能优化技巧，如`React.memo`或`shouldComponentUpdate`来减少不必要的渲染。
