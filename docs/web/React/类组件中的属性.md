## 类组件中的属性

> state, props, refs: 在组件实例组件对象的构造属性; context 再说。类组件中的属性，函数式组件需要用到 hooks 支持

### 初始化 state

```jsx
// 1.创建组件
class Weather extends React.Component {
  state = { isHot: false, wind: "微风" };

  render() {
    const { isHot, wind } = this.state;
    return (
      <h1 onClick={this.changeWeather}>
        今天天气很{isHot ? "炎热" : "凉爽"}, {wind}
      </h1>
    );
  }

  changeWeather = () => {
    const isHot = this.state.isHot;
    this.setState({ isHot: !isHot });
  };
}

// 2.渲染组件到页面
ReactDOM.render(<Weather />, document.getElementById("test"));
}
```

### 修改 state 事件

```jsx
class Weather extends React.Component {
  constructor(props) {
    super(props);
    // 初始化状态
    this.state = { isHot: false };
    // 解决changeWeather中this指向问题
    this.changeWeather = this.changeWeather.bind(this);
  }

  render() {
    // 读取状态
    const { isHot } = this.state;
    return (
      <h1 onClick={this.changeWeather}>今天天气很{isHot ? "炎热" : "凉爽"}</h1>
    );
  }

  changeWeather() {
    // changeWeather放在哪里?-Weather的原型对象上，供实例使用
    // 由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
    // 类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
    console.log(this);
  }
}

// 2.渲染组件到页面
ReactDOM.render(<Weather />, document.getElementById("test"));
```

### setState 用法

```jsx
render() {
  console.log('render');
  // 读取状态
  const { isHot, wind } = this.state;
  return (
    <h1 onClick={this.changeWeather}>
      今天天气很{isHot ? '炎热' : '凉爽'}, {wind}
    </h1>
  );
}

changeWeather() {
  // changeWeather放在哪里?Weather的原型对象上，供实例使用
  // 由于changeWeather是作为onClick的回调，所以不是通过实例调用的，是直接调用
  // 类中的方法默认开启了局部的严格模式，所以changeWeather中的this为undefined
  console.log('changeWeather');
  // 获取原来的isHot值
  const isHot = this.state.isHot;
  // 严重注意:状态必须通过setState进行更新，且更新是一种合并，不是替换。
  this.setState({ isHot: !isHot });
  // 严重注意:状态(state)不可直接更改，下面这行就是直接更改!!!
  // this.state.isHot = !isHot; // 这是错误的写法
}
```

### 修改 state 事件的简化版(es6 箭头函数,this 向外层查找)

```jsx
// 1.创建组件
class Weather extends React.Component {
  state = { isHot: false, wind: "微风" };

  render() {
    const { isHot, wind } = this.state;
    return (
      <h1 onClick={this.changeWeather}>
        今天天气很{isHot ? "炎热" : "凉爽"},{wind}
      </h1>
    );
  }

  // 原型对象上定义方法: 箭头函数this 指向外部
  changeWeather = () => {
    const isHot = this.state.isHot;
    this.setState({ isHot: !isHot });
  };
}

// 2.渲染组件到页面
ReactDOM.render(<Weather />, document.getElementById("test"));
```

### 对 props 中的属性进行限制的简写方法(static 的用法)

```jsx
// 创建组件
class Person extends React.Component {
  // 对标签属性进行类型、必要性的限制
  static propTypes = {
    name: PropTypes.string.isRequired, // 限制name必传,且为字符串
    sex: PropTypes.string, // 限制sex为字符串
    age: PropTypes.number, // 限制age为数值
    speak: PropTypes.func, // 限制speak为函数
  };

  // 指定默认标签属性值
  static defaultProps = {
    sex: "男", // sex默认值为男
    age: 18, // age默认值为18
  };

  render() {
    // 渲染组件到页面
    ReactDOM.render(
      <Person name="jerry" speak={speak} />,
      document.getElementById("test1")
    );
    ReactDOM.render(
      <Person name="tom" age={18} sex="女" />,
      document.getElementById("test2")
    );

    const p = { name: "老刘", age: 18, sex: "女" };
    // console.log('@',..
  }
}
```

### 函数式组件拿不到 state 和 refs，但是可以拿到 props；除非利用 hooks

### refs 的基础用法(react16.8 开始已经废弃, string 类型的 refs 影响效率)

```jsx
// 创建组件
class Demo extends React.Component {
  // 展示左侧输入框的数据
  showData = () => {
    const { input1 } = this.refs;
    alert(input1.value);
  };

  // 展示右侧输入框的数据
  showData2 = () => {
    const { input2 } = this.refs;
    alert(input2.value);
  };

  render() {
    return (
      <div>
        <input
          ref={(c) => (this.input1 = c)}
          type="text"
          placeholder="点击按钮提示数据"
        />
        <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
        <input
          onBlur={this.showData2}
          ref={(c) => (this.input2 = c)}
          type="text"
          placeholder="失去焦点提示数据"
        />
      </div>
    );
  }
}
// 渲染组件到页面
ReactDOM.render(<Demo a="1" b="2" />, document.getElementById("test"));
```

### 回调函数形式的 refs

> (利用 es6 的箭头函数，()和{}都可以省略, 所以只有了一个{}; 页面更新时调两次，第一次为 null，第二次才是真正的节点)

```jsx
// 创建组件
class Demo extends React.Component {
  // 展示左侧输入框的数据
  showData = () => {
    const { input1 } = this.refs;
    alert(input1.value);
  };

  // 展示右侧输入框的数据
  showData2 = () => {
    const { input2 } = this.refs;
    alert(input2.value);
  };

  render() {
    return (
      <div>
        <input
          ref={(c) => (this.input1 = c)}
          type="text"
          placeholder="点击按钮提示数据"
        />
        <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
        <input
          onBlur={this.showData2}
          ref={(c) => (this.input2 = c)}
          type="text"
          placeholder="失去焦点提示数据"
        />
      </div>
    );
  }
}

// 渲染组件到页面
ReactDOM.render(<Demo a="1" b="2" />, document.getElementById("test"));
```

### 内联函数的 refs(不会随着更新时频繁调用)

```jsx
saveInput = (c) => {
  this.input1 = c;
  console.log('@', c);
};

render() {
  const { isHot } = this.state;
  return (
    <div>
      <h2>今天天气很{isHot ? '炎热' : '凉爽'}</h2>
      <input
        ref={(c) => { this.input1 = c; console.log('@', c); }}
        type="text"
      />
      <input ref={this.saveInput} type="text" /><br /><br />
      <button onClick={this.showInfo}>点我提示输入的数据</button>
      <button onClick={this.changeWeather}>点我切换天气</button>
    </div>
  );
}
```

### React.createRef 方式创建结点(目前最推荐的一种方式了)

```jsx
//创建组件
class Demo extends React.Component {
// React.createRef调用后可以返回一个容器，
// 该容器可以存储被ref所标识的节点，该容器是“专人专用”的
myRef = React.createRef();
myRef2 = React.createRef();

//展示左侧输入框的数据
showData = () => {
  alert(this.myRef.current.value);
};

//展示右侧输入框的数据
showData2 = () => {
  alert(this.myRef2.current.value);
};

render() {
  return (
    <div>
      <input ref={this.myRef} type="text" placeholder="点击按钮提示数据" />
      <button onClick={this.showData}>点我提示左侧的数据</button>&nbsp;
      <input
        onBlur={this.showData2}
        ref={this.myRef2}
        type="text"
        placeholder="失去焦点提示数据"
      />
    </div>
  );
}
```
