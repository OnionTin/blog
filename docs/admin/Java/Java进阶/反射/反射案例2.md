## 反射案例 2

> 模拟框架，来实现可以执行我们指定的任意一个类中的任意一个方法(简单点，目前只要空参即可)

```java
// 思路
// 1. 获取字节码文件对象
Class clazz = Class.forName("???"); // ???：className
// 2. 创建实例（两种方式）
// 创建实例1
Object obj1 = clazz.newInstance();
// 获取构造器对象
Constructor cons = clazz.getConstructor();
// 创建实例2
Object obj2 = cons.newInstance();
// 3. 获取方法对象
Method m = clazz.getMethod("???"); // ???：methodName
// 4. 调用方法对象
m.invoke(obj1);
```

> 如何解决 className 和 methodName？而且这两个都是活的，不能是写死的？
>
> 方法一：利用配置文件
>
> 方法二：使用注解

```java
// 方法一
package com.api.Reflex;

import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.util.Properties;

public class Demo08 {
    public static void main(String[] args) throws Exception {
        // 加载配置文件
        Properties properties = new Properties();
        properties.load(
          Demo08.class.getClassLoader().getResourceAsStream("reflex.properties")
        );
        String className = properties.getProperty("className");
        String methodName = properties.getProperty("methodName");
        // 获取字节码文件对象
        Class clazz = Class.forName(className);
        // 创建实例（两种方式）
        // 创建实例1
        Object obj1 = clazz.newInstance();
        // 获取构造器对象
        Constructor cons = clazz.getConstructor();
        // 创建实例2
        Object obj2 = cons.newInstance();
        // 获取方法对象
        Method m = clazz.getMethod(methodName);
        // 调用方法对象
        m.invoke(obj1);
        // 结果：执行了两次无参构造
        // 无参构造执行
        // 无参构造执行
        // Bird is flying
    }
}

class Bird {
    public Bird() {
        System.out.println("无参构造执行");
    }

    public void fly() {
        System.out.println("Bird is flying");
    }
}
```

```properties
# reflex.properties
className=com.api.Reflex.Bird
methodName=fly
```
