## 动态代理

> 在实际开发中，尽量不要去修改原本的对象，而是使用对象代理的方式去扩展对象的功能。由于静态代理会导致代码的膨胀，因此需要动态代理(底层都是反射)。

### 动态代理的分类

1. 基于接口的动态代理：JDK 动态代理
2. 基于类的 动态代理：CGLIB 动态代理
3. java 字节码：javasist

### 通过案例理解动态代理

> 通过下面的案例，我们只需要定制一套动态代理处理器封装类，之后不管是实现什么功能，只需要传入不同的被代理对象即可；这就是动态代理的好处。

```java
// 动态代理处理器封装类
package com.haha;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

// 代理类的处理器：用这个类生成代理类，以及对被代理的类进行处理，所以就是对代理类的封装
public class ProxyInvocationHandler implements InvocationHandler {
  // 被代理的接口
  private Object target;

  public void setTarget(Object target) {
    this.target = target;
  }
  // 生成并返回代理类
  public Object getProxy() {
    // getClass()：反射方法，获取类的类加载器
    // getClassLoader()：获取类
    // getInterfaces()：获取接口
    return Proxy.newProxyInstance(
      this.getClass().getClassLoader(),
      target.getClass().getInterfaces(),
      this
    );
  }

  // 处理代理类，并返回结果(InvocationHandler抽象类中的方法重写)
  // invoke(proxy, method)
  // proxy: 被代理的类
  // method: 被代理的方法
  // args: 被代理的方法的参数
  @Override
  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    // 注入公共事件，在返回代理对象结果之前调用方法都会被执行
    log(method.getName());
    Object result = method.invoke(target, args);
    return result;
  }

  public void log(String msg){
    System.out.println("日志:" + msg + "方法");
  }
}
```

```java
// 接口1
package com.haha;

public interface Rent {
  void rent();
}

// 实现类1
package com.haha;

public class Host implements Rent {
  @Override
  public void rent() {
    System.out.println("房东出租房子");
  }
}
```

```java
// 接口2
package com.haha;

public interface UserService {
  void rent();

  public void add();

  public void delete();

  public void update();

  public void query();
}

// 实现类2
package com.haha;

public class UserServiceImpl implements UserService {
  public void rent() {
    System.out.println("房东要出租房子");
  }
  public void add() {
    rent();
    System.out.println("调用了add方法");
  }

  public void delete() {
    rent();
    System.out.println("调用了delete方法");
  }

  public void query() {
    rent();
    System.out.println("调用了query方法");
  }

  public void update() {
    rent();
    System.out.println("调用了update方法");
  }
}
```

```java
// 客户端1
package com.haha;

public class Client {
  public static void main(String[] args) {
    // 真实角色
    Host host = new Host();
    // 获取代理类处理类
    ProxyInvocationHandler pih = new ProxyInvocationHandler();
    // 设置代理类
    pih.setTarget(host);
    // 获取代理类
    Rent proxy = (Rent) pih.getProxy();
    // 执行代理对象的方法
    proxy.rent();
    // 结果：
    // 日志：rent方法
    // 房东出租房子
  }
}

// 客户端2
package com.haha;

public class UserClient {
  public static void main(String[] args) {
    // 真实角色
    UserServiceImpl userService = new UserServiceImpl();
    // 获取代理类处理类
    ProxyInvocationHandler pih = new ProxyInvocationHandler();
    // 设置代理类
    pih.setTarget(userService);
    // 获取代理类
    UserService proxy = (UserService) pih.getProxy();
    // 执行代理对象的方法(add等多个方法，想用哪个执行调用哪个，比较灵活)
    proxy.add();
    // 结果：
    // 日志：add方法
    // 房东要出租房子
    // 调用了add方法
  }
}
```
