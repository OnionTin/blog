<!-- @format -->

## 自定义负载均衡算法

### IRule 中的负载均衡策略

| 类名                      | 描述                                 |
| ------------------------- | ------------------------------------ |
| RandomRule                | 随机                                 |
| RoundRobinRule            | 轮询(默认)                           |
| RetryRule                 | 重试                                 |
| AvailabilityFilteringRule | 过滤崩溃或者叫跳闸的服务，剩下的轮询 |
| WeightedResponseTimeRule  | 响应时间权重                         |
| BestAvailableRule         | 最小并发                             |
| ZoneAvoidanceRule         | 区域权重                             |
| RandomWeightedRule        | 随机权重                             |
| RetryRule                 | 重试规则                             |

### 自定义策略

#### 1. 在启动类中添加@RibbonClient 注解，并指定自定义策略

```java
package com.ths.consumer;

import com.ths.myrule.MyRestTemplateClientRule;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.netflix.eureka.EnableEurekaClient;
import org.springframework.cloud.netflix.ribbon.RibbonClient;

// 确保扫描到所有相关包
@SpringBootApplication
// 服务注册与发现
@EnableEurekaClient
// 配置自定义负载均衡策略，这样就会覆盖掉原来的策略
@RibbonClient(name="PROJECT-PROVIDER",configuration=MyRestTemplateClientRule.class)
public class Consumer_80 {
  public static void main(String[] args) {
    SpringApplication.run(Consumer_80.class, args);
  }
}
```

#### 2. 在配置类中添加自定义策略

```java
package com.ths.myrule;

import com.netflix.loadbalancer.IRule;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;


// 自定义服务器负载均衡策略
@Configuration
public class MyRestTemplateClientRule {
  @Bean
  public IRule myRandomRule() {
    // 返回的是自定义的，可以返回其他的方法就按照其他的策略
    return new MyRandomRule();
  }
}
```

#### 3. 实现 IRule 接口(基于源码修改)

```java
package com.ths.myrule;

import com.netflix.client.config.IClientConfig;
import com.netflix.loadbalancer.AbstractLoadBalancerRule;
import com.netflix.loadbalancer.ILoadBalancer;
import com.netflix.loadbalancer.Server;

import java.util.List;
import java.util.concurrent.ThreadLocalRandom;

public class MyRandomRule extends AbstractLoadBalancerRule {
  public Server choose(ILoadBalancer lb, Object key) {
    if (lb == null) {
      return null;
    }
    Server server = null;

    while (server == null) {
      if (Thread.interrupted()) { // 线程终端
        return null;
      }
      List<Server> upList = lb.getReachableServers(); // 获得可用服务器列表
      List<Server> allList = lb.getAllServers(); // 获得所有服务器列表

      int serverCount = allList.size();
      if (serverCount == 0) {
        return null;
      }

      int index = chooseRandomInt(serverCount); // 生成随机数
      server = upList.get(index); // 从活着的服务中获取服务器

      if (server == null) {
        Thread.yield();
        continue;
      }

      if (server.isAlive()) {
        return (server);
      }

      // Shouldn't actually happen.. but must be transient or a bug.
      server = null;
      Thread.yield();
    }

    return server;

  }

  protected int chooseRandomInt(int serverCount) {
    return ThreadLocalRandom.current().nextInt(serverCount);
  }

  @Override
  public Server choose(Object key) {
    return choose(getLoadBalancer(), key);
  }

  @Override
  public void initWithNiwsConfig(IClientConfig clientConfig) {
    // TODO Auto-generated method stub

  }
}
```
