## 多态

`运行和编译看哪边指的是等号的左边和右边，即看实例对象的类型；`

`正常情况下，父类不能使用子类中特有的内容`

`向上转型(多态)、向下转型Zi zi = (Zi)Fu。`

> 前提条件:
>
> 1. 要有继承关系
>
> 2. 要有方法的重写
>
> 3. 要有父类引用指向子类对象

### 多态的用法

```java
class Fu {
  public void print(){}
}
class Zi extends Fu { // 有继承关系
  public void print(){} // 有方法重写
}
class Demo{
  public static void main(String[] args){
    Fu fu = new Zi(); // 父类引用指向子类对象
  }
}
```

### 多态间子父类之间成员变量的关系(编译看左边，运行看左边)

```java
// 父类中的成员变量与子类中的成员变量不同
class Fu {
  int i = 10;
}
class Zi extends Fu {
  int j = 20;
}
class Demo{
  public static void main(String[] args){
    Fu fu = new Zi();
    System.out.println(fu.i); // 10
    System.out.println(fu.j); // 编译报错
  }
}
/**
 * 父类引用中不能使用子类中特有的成员变量
 * 改成 Zi fu = new Zi(); 即可
*/
```

```java
// 父类中的成员变量与子类中的成员变量相同
class Fu {
  int i = 10;
}
class Zi extends Fu {
  int i = 20;
}
class Demo{
  public static void main(String[] args){
    Fu fu = new Zi();
    System.out.println(fu.i); // 10
    System.out.println(fu.i); // 10
  }
}
/**
 * 父类引用只能使用自身中特有的成员变量，不能使用子类中的成员变量
 * 子类对象可以调用父类中特有的成员变量
 * 改成 Zi fu = new Zi(); 的话打印结果为 20 20
*/
```

### 多态间子父类之间成员方法的关系(编译看左边，运行看右边)

```java
// 父类中的成员方法与子类中的成员方法不同
class Fu {
  public void printFu(){
    System.out.println("Fu");
  }
}
class Zi extends Fu {
  public void printZi(){
    System.out.println("Zi");
  }
}
class Demo{
  public static void main(String[] args){
    Fu fu = new Zi();
    fu.printFu(); // Fu
    fu.printZi(); // 编译报错
  }
}
/**
 * 父类引用中不能使用子类中特有的成员方法
 * 改成 Zi fu = new Zi(); 即可
*/
```

```java
// 父类中的成员方法与子类中的成员方法相同
class Fu {
  public void print(){
    System.out.println("Fu");
  }
}
class Zi extends Fu {
  public void print(){
    System.out.println("Zi");
  }
}
class Demo{
  public static void main(String[] args){
    Fu fu = new Zi();
    fu.print(); // Zi
    fu.print(); // Zi
  }
}
/**
 * 父类引用中可以使用子类中重写父类的方法
*/
```

### 多态间子父类之间静态成员的关系(多态，静态，成员变量和成员方法，编译看左边，运行看左边)

```java
// 父类中的静态成员与子类中的静态成员相同
class Fu {
  static int i = 10;
}
class Zi extends Fu {
  static int i = 20;
}
class Demo{
  public static void main(String[] args){
    Fu fu = new Zi();
    System.out.println(fu.i); // 10
    System.out.println(fu.i); // 10
  }
}
```

```java
// 父类中的静态成员与子类中的静态成员不同
class Fu {
  static int i = 10;
}
class Zi extends Fu {
  static int j = 20;
}
class Demo{
  public static void main(String[] args){
    Fu fu = new Zi();
    System.out.println(fu.i); // 10
    System.out.println(fu.j); // 编译报错
  }
}
```

### 多态的实际应用

```java
class AnimalTool { // AnimalTool是类方法，也叫静态方法
  public static void eat(Animal animal){ // 有父类对子类的指向
    animal.eat();
  }
}
class Animal{
  public void eat(){
    System.out.println("动物吃东西");
  }
}
class Dog extends Animal{ // 有继承
  public void eat(){ // 有重写
    System.out.println("狗吃肉");
  }
}
class Cat extends Animal{
  public void eat(){
    System.out.println("猫吃鱼");
  }
}
class Pig extends Animal{
  public void eat(){
    System.out.println("猪吃白菜");
  }
}
class Demo{
  public static void main(String[] args){
    // 狗吃肉: 有父类对子类的指向
    AnimalTool.eat(new Dog());
    // 猫吃鱼: 类方法(静态方法)可以类名.方法名(
    AnimalTool.eat(new Cat());
    //猪吃白菜: Animal animal = new Pig() => Fu fu = new Zi()
    AnimalTool.eat(new Pig());
  }
}
```

### 向上转型(就是多态)

```java
Fu Fu = new Zi();
```

### 向下转型(解决多态的弊端)

```java
Zi zi = (Zi)fu; // 有点像强制类型转换
```

> 多态的弊端:
>
> 父类不能使用子类中特有的变量，向下转型后即可。
>
> 举例说明，有一只小狗，长的很漂亮，我们可以说那只小狗长得很漂亮，
>
> 当然也可以说那个动物长得很漂亮，
>
> 漂亮本是狗的特有属性，这就是向下转型的意义。

```java
class Animal{
  public void eat(){
    System.out.println("动物吃东西");
  }
}
class Dog extends Animal{ // 有继承
  public void eat(){ // 有重写
    System.out.println("狗吃肉");
  }
}
class Cat extends Animal{ // 有继承
  public void eat(){ // 有重写
    System.out.println("猫吃鱼");
  }
}
class Demo{
  public static void main(String[] args){
    Animal animal = new Dog(); // 向上转型 Fu fu = new Zi()
    Dog dog = (Dog)animal; // 向下转型，Zi zi = (Zi) fu，转型后即可使用子类中特有的成员
    dog.eat(); // 狗吃肉
    Cat cat = (Cat)animal; // 错误的，因为animal是new Dog()的实例，不能再用猫来修饰
    cat.eat(); // 报错，因为cat是猫，而animal是动物，所以不能使用
  }
}

```
