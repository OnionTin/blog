## 集合总结

### 集合的特点

单列集合：

| 接口名 | 类名          | 特性                                                 | 查询                      | 增删                      | 底层         |
| ------ | ------------- | ---------------------------------------------------- | ------------------------- | ------------------------- | ------------ |
| List   | -             | <font color=red>有序，有索引，可重复</font>          | -                         | -                         | -            |
| List   | ArrayList     | 同上                                                 | <font color=red>快</font> | 慢                        | 数组         |
| List   | LinkedList    | 同上                                                 | 慢                        | <font color=red>快</font> | 链表         |
| List   | Vector        | 同上                                                 | 慢                        | 慢                        | 数组         |
| Set    | -             | <font color=red>无序，无索引，不可重复</font>        | -                         | -                         | -            |
| Set    | HashSet       | 同上，<font color=red>但是注意去重和 hashCode</font> | 快                        | 慢                        | 哈希表       |
| Set    | LinkedHashSet | 有序                                                 | 快                        | 慢                        | 链表和哈希表 |
| Set    | TreeSet       | 同上，<font color=red>但是可排序</font>              | 慢                        | 快                        | 红黑树       |

双列集合：
| 接口名 | 类名 | 特性 | 查询 | 增删 | 底层 |键值|
| ------ | ----- | ------------------------ | -------- | -------- | --------- |-|
| Map | - | 无序，无索引，键不可重复，值可重复 | - | - | - |-|
| Map | HashMap | 同上 | 快 | 慢 | 哈希表 |<font color=red>键和值都可为 null</font>|
| Map | TreeMap | 同上，<font color=red>但是可排序</font> | 慢 | 快 | 红黑树 |不可为 null|
| Map | LinkedHashMap | 同上，但是有序 | 快 | 慢 | 链表和哈希表 |不可为 null|
|Map|HashTable|同上|慢|慢|哈希表|不可为 null|
|Map|Properties|同上|快|慢|数组和链表|可为 null，键值都是 String 类型|

### 集合 Tree 结构排序

- 自然排序：元素需要实现 Comparable 接口，重写 compareTo 方法

- 比较器：元素需要实现 Comparator 接口，重写 compare 方法

### 集合 List 结构排序

利用 Collections 工具类的 sort 方法进行排序

### 集合的遍历

单列集合：

1. 转数组循环遍历

2. 迭代器遍历

3. 增强 for 循环遍历(for each)

4. 普通的 for 循环遍历(利用索引)

双列集合：

1. keySet()键找值遍历

2. entrySet()键值对遍历

### 集合的常用方法

单列集合：

- add()：添加元素
- remove()：删除元素
- size()：获取元素个数
- isEmpty()：判断是否为空
- contains()：判断是否包含某个元素
- clear()：清空集合
- addAll()：添加多个元素
- removeAll()：删除多个元素
- retainAll()：保留多个元素
- containsAll()：判断是否包含多个元素
- equals()：判断是否相等
- hashCode()：获取哈希码
- toArray()：转换为数组
- subList()：获取子集合
- iterator()：获取迭代器
- listIterator()：获取列表迭代器
- spliterator()：获取集合的拆分器
- stream()：获取流
- parallelStream()：获取并行流
- forEach()：遍历集合
- forEachOrdered()：有序遍历集合
- toString()：转换为字符串
- removeIf()：删除满足条件的元素
- replaceAll()：替换所有元素
- replaceAll()：替换所有元素
- sort()：排序
- parallel()：并行处理
- stream()：流式处理
- parallelStream()：并行流式处理

双列集合：

- put()：添加元素
- remove()：删除元素
- size()：获取元素个数
- isEmpty()：判断是否为空
- containsKey()：判断是否包含某个键
- containsValue()：判断是否包含某个值
- clear()：清空集合
- putAll()：添加多个元素
- removeAll()：删除多个元素
- retainAll()：保留多个元素
- containsAll()：判断是否包含多个键或值
- equals()：判断是否相等
- hashCode()：获取哈希码
- toArray()：转换为数组
- keySet()：获取所有键的集合
- values()：获取所有值的集合
- entrySet()：获取所有键值对的集合
- iterator()：获取迭代器
- listIterator()：获取列表迭代器
- spliterator()：获取集合的拆分器
- stream()：获取流
- parallelStream()：获取并行流
- forEach()：遍历集合
- forEachOrdered()：有序遍历集合
- toString()：转换为字符串
- removeIf()：删除满足条件的元素
- replaceAll()：替换所有元素
- replaceAll()：替换所有元素
- sort()：排序
- parallel()：并行处理
- stream()：流式处理
- parallelStream()：并行流式处理

### 集合的使用

```java
package com.wuziqi.gobang.Map;

import java.util.*;

public class DemoClassStudent {
     /**
      * 定义一个学生类，
      * 属性：姓名（String name）、班级班号（String no）、成绩（double score）
      * 将n个学生对象存入List集合，并统计每个班级的总分和平均分
      * 思想：采用面向对象的思想
      * 不推荐使用Map<String,List<Student>>操作不方便
      * 推荐使用Map<String,ClassRoom>
      */

    public static void main(String[] args) {
        Map<String, ClassRoom> map = new TreeMap<String, ClassRoom>();

        List<Stud> students1 = new ArrayList<Stud>();
        students1.add(new Stud("小张",100));
        students1.add(new Stud("小李",33));
        students1.add(new Stud("小王",33));
        students1.add(new Stud("小王",33));

        List<Stud> students2 = new ArrayList<Stud>();
        students2.add(new Stud("小亮",50));
        students2.add(new Stud("小萌",38));

        map.put("1班", new ClassRoom(0.0,0.0, students1));
        map.put("2班", new ClassRoom(0.0,0.0, students2));

        System.out.println(map);
        // 结果：
        // {1班=ClassRoom{total=199.0, pjNum=49.75,
        // students=[Stud{name='小张', score=100.0}, Stud{name='小李', score=33.0},
        // Stud{name='小王', score=33.0}, Stud{name='小王', score=33.0}]},
        // 2班=ClassRoom{total=88.0, pjNum=44.0,
        // students=[Stud{name='小亮', score=50.0},Stud{name='小萌', score=38.0}]}}
    }
}
class ClassRoom implements Comparable<ClassRoom>{
    private Double total;
    private Double pjNum;
    private List students;
    private void setTotal(List students){
        this.total = total;
    }

    private  void setPjNum(List students){
        this.pjNum = pjNum;
    }

    public ClassRoom(Double total, Double pjNum, List students) {
        this.students = students;
        this.total = total;
        this.pjNum = pjNum;
        for (Object o : students){
            Stud s = (Stud)o;
            this.total += s.score;
        }
        this.pjNum = getTotal()/ students.size();
    }

    public Double getTotal() {
        return total;
    }

    public void setTotal(Double total) {
        this.total = total;
    }

    public Double getPjNum() {
        return pjNum;
    }

    public void setPjNum(Double pjNum) {
        this.pjNum = pjNum;
    }

    public List getStudents() {
        return students;
    }

    public void setStudents(List students) {
        this.students = students;
    }

    @Override
    public String toString() {
        return "ClassRoom{" +
                "total=" + total +
                ", pjNum=" + pjNum +
                ", students=" + students +
                '}';
    }
    @Override
    public int compareTo(ClassRoom o) {
        return this.getPjNum().compareTo(o.getPjNum());
    }
}
class Stud{
    private String name;
    double score;

    public Stud(String name, double score) {
        this.name = name;
        this.score = score;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Stud{" +
                "name='" + name + '\'' +
                ", score=" + score +
                '}';
    }
}
```
