## 同步机制

> 解决多线程并发访问时出现的问题，使用同步机制，保证同一时刻，只能有一个线程对数据进行操作。

### 方法一(同步代码块)

> 什么时候使用同步代码块？(什么时候会出现多线程并发访问问题？)
>
> 1. 多线程；
> 2. 有共享资源；
> 3. 有多条语句都操作了共享资源。
>
> 锁对象？
>
> - 同步方法的锁对象 可以是我们传递的任意对象

```java
格式:
synchronized(锁对象){
  /*
  * 锁对象：可以是任意对象(当然，也包括字节码文件对象，所以可以不创建对象，
  * 把当前文件字节码文件对象当作锁对象传进去)
  * 要求：多个线程必须要共用同一把锁
  * 特性：在某一个线程使用时，会被锁上，不受其他线程影响
  * 放哪：仅包裹所有操作共享资源的最小代码块，否则可能会出现线程的阻塞
  */
  // 需要被同步的代码 || 所有操作共享资源的部分的最小代码块
}
案例代码：
package com.api.DuoXianCheng;

public class Ticket02 {
    public static void main(String[] args) {
        // 三个窗口，即三个线程
        Ticket2 ticket = new Ticket2();

        Thread t1 = new Thread(ticket);
        Thread t2 = new Thread(ticket);
        Thread t3 = new Thread(ticket);
        t1.setName("窗口1");
        t2.setName("窗口2");
        t3.setName("窗口3");

        t1.start();
        t2.start();
        t3.start();
    }
}
class Ticket2 implements Runnable {
    private int ticketNum = 100;
    private Object obj = new Object(); // 锁对象：多线程共用
    @Override
    public void run() {
        // 售票代码
        while (true) {
            synchronized (obj) {
              /*
               * 如果把while整体都包裹了，就不是最小代码块了；
               * 可能会出现当前线程锁资源的问题；
               * 其他线程阻塞了
              */
                if (ticketNum > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    System.out.println(
                      Thread.currentThread().getName() + ":出票，票号为：" + ticketNum
                    );
                    ticketNum--;
                } else {
                    break;
                }
            }
        }
    }
}
```

### 方法二(同步方法)

> 什么时候使用同步方法？
>
> - 当一个方法中，需要使用同步代码块把方法体中的代码全部包裹起来的时候，这个时候就可以选择同步方法了。
>
> 锁对象？
>
> - 同步方法的锁对象是 this

```java
格式:
修饰符 synchronized 返回值类型 方法名(形参){
  // 执行语句
  return 返回值;
}
案例代码：
package com.api.DuoXianCheng;

public class Ticket03 {
    public static void main(String[] args) {
        Ticket3 ticket3 = new Ticket3();
        // 使用匿名子类对象创建两个线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    ticket3.print1();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    ticket3.print2();
                }
            }
        }).start();
    }
}
class Ticket3{
    // 使用同步代码块
    /*
    private Object obj = new Object(); // 锁对象
    public void print1(){
        synchronized (obj) {
            System.out.print("我");
            System.out.print("要");
            System.out.print("上");
            System.out.print("学");
            System.out.println("校");
        }
    }
    public void print2(){
        synchronized (obj) {
            System.out.print("天");
            System.out.print("天");
            System.out.print("不");
            System.out.print("迟");
            System.out.println("到");
        }
    }
    */

    // 使用同步方法： 锁对象是this
    public synchronized void print1(){
        System.out.print("我");
        System.out.print("要");
        System.out.print("上");
        System.out.print("学");
        System.out.println("校");
    }
    public synchronized void print2(){
        System.out.print("天");
        System.out.print("天");
        System.out.print("不");
        System.out.print("迟");
        System.out.println("到");
    }
}
```

### 方法三(静态同步方法)

> 什么时候使用静态同步方法？
>
> - 和使用同步方法的要求一样，至于使用静态或者非静态需要根据需求而定。
>
> 锁对象？
>
> - 静态同步方法的锁对象是 当前类本身，即字节码文件对象。

```java
格式:
修饰符 static synchronized 返回值类型 方法名(形参){
  // 执行语句
  return 返回值;
}
案例代码：
package com.api.DuoXianCheng;

public class Ticket04 {
    public static void main(String[] args) {
        // 使用匿名子类对象创建两个线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    // 静态方法，类名直接调用
                    Ticket4.print1();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    Ticket4.print2();
                }
            }
        }).start();
    }
}
class Ticket4{
    // 使用静态同步方法：锁对象当前类本身
    public static synchronized void print1(){
        System.out.print("我");
        System.out.print("要");
        System.out.print("上");
        System.out.print("学");
        System.out.println("校");
    }
    public static synchronized void print2(){
        System.out.print("天");
        System.out.print("天");
        System.out.print("不");
        System.out.print("迟");
        System.out.println("到");
    }
}
```

### 方法四(使用 ReentrantLock 锁对象)

```java
package com.api.DuoXianCheng;

import java.util.concurrent.locks.ReentrantLock;

public class Ticket05 {
    public static void main(String[] args) {
        Ticket5 ticket5 = new Ticket5();
        // 使用匿名子类对象创建两个线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    ticket5.print1();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    ticket5.print2();
                }
            }
        }).start();
    }
}
class Ticket5{
    // 使用 ReentrantLock 对象控制线程同步
    private ReentrantLock lock = new ReentrantLock();
    public synchronized void print1(){
        lock.lock();
        System.out.print("我");
        System.out.print("要");
        System.out.print("上");
        System.out.print("学");
        System.out.println("校");
        lock.unlock();
    }
    public synchronized void print2(){
        lock.lock();
        System.out.print("天");
        System.out.print("天");
        System.out.print("不");
        System.out.print("迟");
        System.out.println("到");
        lock.unlock();
    }
}
```
