## 等待唤醒机制

> 用来解决生产者和消费者的问题(一个买票，一个出票，正常应该出一张票买一张票)

| 方法                          | 作用                     |
| ----------------------------- | ------------------------ |
| public final void wait()      | 使当前线程等待           |
| public final void notify()    | 唤醒正在等待的单个线程。 |
| public final void notifyAll() | 唤醒正在等待的所有线程。 |

```java
package com.api.DuoXianCheng;

public class ThreadWait {
    public static void main(String[] args) {
        Ticket6 ticket3 = new Ticket6();
        // 使用匿名子类对象创建两个线程
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    ticket3.print1();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    ticket3.print2();
                }
            }
        }).start();
        new Thread(new Runnable() {
            @Override
            public void run() {
                while (true) {
                    ticket3.print3();
                }
            }
        }).start();
    }
}

class Ticket6 {
    // 使用同步代码块  只有两个线程
    /*
    private Object obj = new Object(); // 锁对象
    private Boolean flag = false;
    public void print1(){
        synchronized (obj) {
            while (!flag){
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print("我");
            System.out.print("要");
            System.out.print("上");
            System.out.print("学");
            System.out.println("校");

            obj.notify();
            this.flag = false;
        }
    }
    public void print2(){
        synchronized (obj) {
            while (flag){
                try {
                    obj.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            System.out.print("天");
            System.out.print("天");
            System.out.print("不");
            System.out.print("迟");
            System.out.println("到");

            obj.notify();
            this.flag = true;
        }
    }
    */

    // 同步方法  假如有多个线程怎么使用等待唤醒机制
    private  int i = 1;
    public synchronized void print1() {
        while (i != 1){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.print("我");
        System.out.print("要");
        System.out.print("上");
        System.out.print("学");
        System.out.println("校");

        this.notifyAll();
        this.i = 2;
    }

    public synchronized void print2() {
        while (i != 2){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.print("天");
        System.out.print("天");
        System.out.print("不");
        System.out.print("迟");
        System.out.println("到");

        this.notifyAll();
        this.i = 3;
    }

    public synchronized void print3() {
        while (i != 3){
            try {
                this.wait();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        System.out.print("好");
        System.out.print("孩");
        System.out.println("子");
        this.notifyAll();
        this.i = 1;
    }
}
```

### wait 和 sleep 的区别

1. wait 和 sleep 都可以暂停线程的执行。

2. wait 是 Object 类中的普通成员方法；

   sleep 是 Thread 类中的静态成员方法。

3. wait 暂停后，会释放锁对象，需要被唤醒；

   sleep 暂停后，不会释放锁对象，也不需要被唤醒。

4. wait 通常被用于线程间交互通信；

   sleep 通常被用于暂停执行。

### 关于 java 中线程安全的类

1. StringBuffer 和 StringBuilder

   StringBuilder：线程不安全，效率高

   StringBuffer：线程安全，效率低

2. ArrayList 和 Vector

   ArrayList：线程不安全，效率高

   Vector：线程安全，效率低

3. HashMap 和 HashTable

   HashMap：线程不安全，效率高

   HashTable：线程安全，效率低

4. Collections.synchronizedXXX

   这些类都是线程安全的， 这些类的源代码中， 一般的方法都会被 synchronized 关键字修饰。
