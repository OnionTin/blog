## 装饰设计模式

对已有的方法或功能进行增强的方式

1. 继承

```java
class Demo{
  public static void main(String[] args) {
    // A a = new A();
    // B b = new B();
    Tools.play(new A()); // 打篮球
    Tools.play(new B()); // 打篮球、打排球、踢足球
  }
}
class A{
  public void play(){
    System.out.println("打篮球");
  }
}
class B extends A{
  @Override
  public void play(){
    super.play(); // 继承方法
    System.out.println("打排球"); // 增强的功能
    System.out.println("踢足球"); // 增强的功能
  }
}
class Tools{
  public static void play(A a){
    a.play();
  }
}
```

2. 装饰设计模式

```java
package com.wuziqi.gobang.Decorate;

public class zhuangshishejimoshi {
  public static void main(String[] args) {
    FileInputStream fis = new FileInputStream("a.txt");
    /*
    int by = fis.read();
    System.out.println(by);

    byte[] bys = new byte[1024];
    int len = fis.read(bys);
    System.out.println(len);
    System.out.println(new String(bys, 0, len));
    */

    /*
    * BufferedInputStream(InputStream is)
    * 正常来说需要传递InputStream类型参数，但它是抽象类
    * 因此只能传递他的儿子，即FileInputStream
    */
    BufferedInputStream bis = new BufferedInputStream(fis);
    System.out.println(bis);

    int by = bis.read(); // 调用的增强方法
    System.out.println(by);

    byte[] bys = new byte[1024];
    int len = bis.read(bys); // 调用的增强方法
    System.out.println(len);
    System.out.println(new String(bys, 0, len));
  }
}
abstract class InputStream{
  public abstract int read();
  public abstract int read(byte[] bys);
  public abstract void close();
}
class FileInputStream extends InputStream{
  public FileInputStream(String path){
    System.out.println("FileInputStream");
  }
  @Override
  public int read() {
    // XXX：正常处理代码
    return 0;
  }

  @Override
  public int read(byte[] bys) {
    // XXX：正常处理代码
    return 0;
  }

  @Override
  public void close() {
    // XXX：正常处理代码
  }
}

class BufferedInputStream extends InputStream{
  private InputStream is; // 变量对象
  /*
  * InputStream is = new FileInputStream("a.txt");
  * Fu fu = new Zi();
  */
  public BufferedInputStream(InputStream is){
    this.is = is; // 初始化，给变量赋值，赋值为形参中的is
  }
  @Override
  public int read() {
    // XXX000：增强处理的代码
    return 0;
  }

  @Override
  public int read(byte[] bys) {
    // XXX000：增强处理的代码
    return 0;
  }

  @Override
  public void close() {
    // 没有被增强的方法调用被包装的对象的方法
    is.close();
  }
}
```

3. 动态代理设计模式

4. 适配器设计模式

5. 外观设计模式

6. 桥接设计模式

7. 组合设计模式

8. 享元设计模式

9. 策略设计模式

10. 模板方法设计模式

11. 职责链设计模式

12. 命令设计模式

13. 状态设计模式
