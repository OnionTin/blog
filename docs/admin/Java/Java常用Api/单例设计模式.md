## 单例设计模式

> 使用单例设计模式，能够实现，一个类只能有一个对象。

### 如何实现单例设计模式

方式一：立即加载

优点：不会出现多线程并发访问问题

缺点：太早进入内存，又太晚消失了，生命周期长，占内存

```java
package com.api.SingleMode;

public class mode01 {
    public static void main(String[] args) {
        // 只有一个对象，所以输出true，都是地址值
        Singleton singleton1 = Singleton.getInstance();
        Singleton singleton2 = Singleton.getInstance();
        System.out.println(singleton1 == singleton2); // true
    }
}

class Singleton {
    private static final Singleton s = new Singleton();
    private Singleton() {
    }
    public static Singleton getInstance() {
        return s;
    }
}
```

方式二：延迟加载

优点：不占用内存

缺点：加载慢；线程不安全，多线程并发访问时，可能会出现多个对象，即不是单例

```java
package com.api.SingleMode;

public class mode02 {
    public static void main(String[] args) {
        // 只有一个对象，所以输出true，都是地址值
        Singleton2 singleton1 = Singleton2.getInstance();
        Singleton2 singleton2 = Singleton2.getInstance();
        System.out.println(singleton1 == singleton2); // true
    }
}

class Singleton2 {
    private static Singleton2 s;
    private Singleton2() {
    }
    public static Singleton2 getInstance() {
        // 只有第一次执行，后期不进入了，所以还是一个对象
        if (s == null){
            s = new Singleton2();
        }
        return s;
    }
}
```

### 延迟加载的问题(多线程并发访问可能不再是单例模式)

```java
package com.api.SingleMode;

public class mode03 {
    public static void main(String[] args) {
        new Thread("线程A") {
            @Override
            public void run() {
                Singleton3 singleton1 = Singleton3.getInstance();
                System.out.println(getName() + ":" + singleton1);
            }
        }.start();
        new Thread("线程B") {
            @Override
            public void run() {
                Singleton3 singleton2 = Singleton3.getInstance();
                System.out.println(getName() + ":" + singleton2);
            }
        }.start();

        // 可能的结果1：还是单例模式
        // 线程A:com.api.SingleMode.Singleton3@5b21a71
        // 线程B:com.api.SingleMode.Singleton3@5b21a71

        // 可能的结果2：不是单例模式了
        // 线程B:com.api.SingleMode.Singleton3@49fb8056
        // 线程A:com.api.SingleMode.Singleton3@5247863c
    }
}

class Singleton3 {
    private static Singleton3 s;

    private Singleton3() {
    }

    public static Singleton3 getInstance() {
        // 只有第一次执行，后期不进入了，所以还是一个对象
        if (s == null) {
            s = new Singleton3();
        }
        return s;
    }
}
```

### 解决延迟加载出现的问题(多线程同步机制)

优点：不占用内存，解决多线程并发访问时，可能会出现多个对象，即不是单例

缺点：每次抢到进程后要判断是否上锁，效率低

```java
package com.api.SingleMode;

public class mode04 {
    public static void main(String[] args) {
        Singleton4 singleton1 = Singleton4.getInstance();
        Singleton4 singleton2 = Singleton4.getInstance();
        new Thread("线程A") {
            @Override
            public void run() {
                while (true) {
                    System.out.println(getName() + ":" + singleton1);
                }
            }
        }.start();
        new Thread("线程B") {
            @Override
            public void run() {
                while (true) {
                    System.out.println(getName() + ":" + singleton2);
                }
            }
        }.start();
    }
}

class Singleton4 {
    private static Singleton4 s;

    private Singleton4() {
    }

    public static synchronized Singleton4 getInstance() {
        // 只有第一次执行，后期不进入了，所以还是一个对象
        if (s == null) {
            s = new Singleton4();
        }
        return s;
    }
}
```

### 单例模式最终方案

把同步方法改为同步代码块，解决效率问题

优点：不占内存，解决线程安全问题，解决效率问题

```java
package com.api.SingleMode;

public class mode05 {
    public static void main(String[] args) {
        Singleton5 singleton1 = Singleton5.getInstance();
        Singleton5 singleton2 = Singleton5.getInstance();
        new Thread("线程A") {
            @Override
            public void run() {
                while (true) {
                    System.out.println(getName() + ":" + singleton1);
                }
            }
        }.start();
        new Thread("线程B") {
            @Override
            public void run() {
                while (true) {
                    System.out.println(getName() + ":" + singleton2);
                }
            }
        }.start();

        // 结果：
    }
}

class Singleton5 {
    private static Singleton5 s;

    private Singleton5() {
    }

    public static Singleton5 getInstance() {
        // 只有第一次执行，后期不进入了，所以还是一个对象
        if (s == null) {
            synchronized (Singleton5.class){
                if (s == null){ // 这个判断解决并发问题
                    s = new Singleton5();
                }
            }
        }
        return s;
    }
}
```
