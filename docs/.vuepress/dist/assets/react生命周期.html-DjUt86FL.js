import{_ as t,o as e,c as a,e as d}from"./app-CilA4iky.js";const n={},o=d('<h2 id="react-组件生命周期详解" tabindex="-1"><a class="header-anchor" href="#react-组件生命周期详解"><span>React 组件生命周期详解</span></a></h2><h3 id="类组件的生命周期" tabindex="-1"><a class="header-anchor" href="#类组件的生命周期"><span>类组件的生命周期</span></a></h3><h4 id="创建阶段" tabindex="-1"><a class="header-anchor" href="#创建阶段"><span>创建阶段</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>constructor()</td><td>构造函数，在组件实例创建时只调用一次，用于初始化组件。</td></tr><tr><td>render()</td><td>渲染方法，返回组件要渲染的内容。</td></tr><tr><td>componentDidMount()</td><td>组件挂载后调用，用于执行一些副作用操作，如数据请求、订阅事件等。</td></tr></tbody></table><h4 id="更新阶段" tabindex="-1"><a class="header-anchor" href="#更新阶段"><span>更新阶段</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>shouldComponentUpdate(nextProps, nextState)</td><td>在组件接收到新的 props 或 state 时调用，返回布尔值决定组件是否应该更新。</td></tr><tr><td>render()</td><td>在更新前调用，返回组件要渲染的内容。</td></tr><tr><td>componentDidUpdate(prevProps, prevState)</td><td>在更新后调用，可以执行副作用操作，如网络请求。</td></tr></tbody></table><h4 id="渲染输出阶段" tabindex="-1"><a class="header-anchor" href="#渲染输出阶段"><span>渲染输出阶段</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>render()</td><td>渲染方法，返回组件要渲染的内容。 在创建和更新阶段都会被调用</td></tr></tbody></table><h4 id="卸载阶段" tabindex="-1"><a class="header-anchor" href="#卸载阶段"><span>卸载阶段</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>componentWillUnmount()</td><td>在组件卸载（销毁）前调用，用于清理操作，如移除事件监听器。</td></tr></tbody></table><h3 id="函数组件的生命周期" tabindex="-1"><a class="header-anchor" href="#函数组件的生命周期"><span>函数组件的生命周期</span></a></h3><p>在函数组件中，可以使用 Hooks 来模拟生命周期。</p><h4 id="创建阶段-1" tabindex="-1"><a class="header-anchor" href="#创建阶段-1"><span>创建阶段</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>useState()</td><td>用于在函数组件中添加状态。</td></tr><tr><td>useEffect()</td><td>用于处理副作用，相当于类组件的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</td></tr></tbody></table><h4 id="更新阶段-1" tabindex="-1"><a class="header-anchor" href="#更新阶段-1"><span>更新阶段</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>useState()</td><td>用于在函数组件中添加状态。</td></tr><tr><td>useEffect()</td><td>用于处理副作用，相当于类组件的 <code>componentDidMount</code>、<code>componentDidUpdate</code> 和 <code>componentWillUnmount</code>。</td></tr></tbody></table><h4 id="卸载阶段-1" tabindex="-1"><a class="header-anchor" href="#卸载阶段-1"><span>卸载阶段</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>useEffect()</td><td>在组件卸载时调用，用于清理副作用，如取消订阅、清除定时器等。</td></tr></tbody></table><h3 id="类组件详解" tabindex="-1"><a class="header-anchor" href="#类组件详解"><span>类组件详解</span></a></h3><h4 id="constructor生命周期" tabindex="-1"><a class="header-anchor" href="#constructor生命周期"><span><code>constructor生命周期</code>：</span></a></h4><ol><li>当 react 组件实例化时，是第一个运行的生命周期；</li><li>在这个生命周期中，不能使用 this.setState()；</li><li>在这个生命周期中，不能使用副作用(调接口、dom 操作、定时器、长连接等)；</li><li>不能把 props 和 state 交叉赋值；</li></ol><h4 id="componentdidmount生命周期" tabindex="-1"><a class="header-anchor" href="#componentdidmount生命周期"><span><code>componentDidMount生命周期</code>：</span></a></h4><ol><li>相当于是 vue 中的 mounted</li><li>它表示 DOM 结构在浏览器中渲染已完成；</li><li>在这里可以使用任何的副作用；</li></ol><h4 id="shouldcomponentupdate-nextprops-nextstate-生命周期" tabindex="-1"><a class="header-anchor" href="#shouldcomponentupdate-nextprops-nextstate-生命周期"><span><code>shouldComponentUpdate(nextProps,nextState)生命周期</code>：</span></a></h4><ol><li>相当于一个开关，如果返回 true 则更新机制正常执行，如果为 false 则更新机制停止；</li><li>在 vue 中是没有的；</li><li>存在的意义：可以用于性能优化，但是不常用，最新的解决方案是使用 PureComponent；</li><li>理论上，这个生命周期的作用，用于精细地控制声明式变量的更新问题，如果变化的声明式变量参与了视图渲染则返回 true，如果被变化的声明式变量没有直接或间接参与视图渲染，则返回 false；</li></ol><h4 id="componentdidupdate生命周期" tabindex="-1"><a class="header-anchor" href="#componentdidupdate生命周期"><span><code>componentDidUpdate生命周期</code>：</span></a></h4><ol><li>相当于 vue 中的 updated()；</li><li>它表示 DOM 结构渲染更新已完成，只发生在更新阶段；</li><li>在这里，可以执行大多数的副作用，但是不建议；</li><li>在这里，可以使用 this.setState()，但是要有终止条件判断；</li></ol><h4 id="componentwillunmount生命周期" tabindex="-1"><a class="header-anchor" href="#componentwillunmount生命周期"><span><code>componentWillUnmount生命周期</code>：</span></a></h4><ol><li>一般在这里清除定时器、长连接等其他占用内存的构造器；</li></ol><h4 id="render生命周期" tabindex="-1"><a class="header-anchor" href="#render生命周期"><span><code>render生命周期</code>：</span></a></h4><ol><li>render 是类组件中唯一必须有的生命周期，同时必须有 return（return 返回的 jsx 默认只能是单一根节点，但是在 fragment 的语法支持下，可以返回多个兄弟节点）；</li><li>Fragment 碎片写法: &lt;React.Fragment&gt;&lt;/React.Fragment&gt; 简写成&lt;&gt;&lt;/&gt;；</li><li>return 之前，可以做任意的业务逻辑，但是不能使用 this.setState()，会造成死循环；</li><li>render()在装载阶段和更新阶段都会运行；</li><li>当 render 方法返回 null 的时候，不会影响生命周期函数的正常执行。</li></ol><h4 id="forceupdate" tabindex="-1"><a class="header-anchor" href="#forceupdate"><span><code>forceUpdate</code>:</span></a></h4><ol><li>页面强制更新,不经过 shouldComponentUpdate();</li></ol><h4 id="componentwillreceiveprops" tabindex="-1"><a class="header-anchor" href="#componentwillreceiveprops"><span><code>componentWillReceiveProps</code>:</span></a></h4><ol><li>在子组件内，将要接收 props 调用(第一次不会调用,更新后才开始调用，可以接收参数 props，参数是更新后的值);</li></ol><h4 id="unmountcomponentatnode" tabindex="-1"><a class="header-anchor" href="#unmountcomponentatnode"><span><code>unmountComponentAtNode</code>:</span></a></h4><ol><li>组件的卸载(ReactDom.unmountComponentAtNode(gocument.getElementById(&#39;...&#39;)));</li></ol><h4 id="react-新的生命周期-react-17-0-1-开始采用" tabindex="-1"><a class="header-anchor" href="#react-新的生命周期-react-17-0-1-开始采用"><span>react 新的生命周期 - react-17.0.1 开始采用</span></a></h4><table><thead><tr><th>生命周期方法</th><th>描述</th></tr></thead><tbody><tr><td>getDerivedStateFromProps()</td><td>在组件实例化后和接收到新的 props 或 state 时调用，用于更新 state。</td></tr><tr><td>getSnapshotBeforeUpdate()</td><td>在组件更新前调用，用于获取更新前的快照信息。</td></tr></tbody></table><h3 id="常见的使用场景" tabindex="-1"><a class="header-anchor" href="#常见的使用场景"><span>常见的使用场景</span></a></h3><ul><li><strong>数据获取</strong>：通常在 <code>componentDidMount</code> 或 <code>useEffect</code> 中进行数据获取。</li><li><strong>订阅</strong>：在 <code>componentDidMount</code> 或 <code>useEffect</code> 中订阅，然后在 <code>componentWillUnmount</code> 或 <code>useEffect</code> 的返回函数中取消订阅。</li><li><strong>表单处理</strong>：使用 <code>useState</code> 来管理表单状态，使用 <code>useEffect</code> 来处理表单提交后的副作用。</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><ul><li>尽量避免在 <code>render</code> 方法中执行重的计算或复杂的逻辑，因为这会在每次渲染时都执行。</li><li>尽量使用函数组件和 Hooks，因为它们更简洁，易于理解。</li></ul>',43),r=[o];function l(h,c){return e(),a("div",null,r)}const i=t(n,[["render",l],["__file","react生命周期.html.vue"]]),p=JSON.parse('{"path":"/web/React/react%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"React 组件生命周期详解","slug":"react-组件生命周期详解","link":"#react-组件生命周期详解","children":[{"level":3,"title":"类组件的生命周期","slug":"类组件的生命周期","link":"#类组件的生命周期","children":[]},{"level":3,"title":"函数组件的生命周期","slug":"函数组件的生命周期","link":"#函数组件的生命周期","children":[]},{"level":3,"title":"类组件详解","slug":"类组件详解","link":"#类组件详解","children":[]},{"level":3,"title":"常见的使用场景","slug":"常见的使用场景","link":"#常见的使用场景","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]}]}],"git":{"updatedTime":1727600594000,"contributors":[{"name":"OnionTin","email":"2775376881@qq.com","commits":2}]},"filePathRelative":"web/React/react生命周期.md","excerpt":"<h2>React 组件生命周期详解</h2>\\n<h3>类组件的生命周期</h3>\\n<h4>创建阶段</h4>\\n<table>\\n<thead>\\n<tr>\\n<th>生命周期方法</th>\\n<th>描述</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>constructor()</td>\\n<td>构造函数，在组件实例创建时只调用一次，用于初始化组件。</td>\\n</tr>\\n<tr>\\n<td>render()</td>\\n<td>渲染方法，返回组件要渲染的内容。</td>\\n</tr>\\n<tr>\\n<td>componentDidMount()</td>\\n<td>组件挂载后调用，用于执行一些副作用操作，如数据请求、订阅事件等。</td>\\n</tr>\\n</tbody>\\n</table>"}');export{i as comp,p as data};
