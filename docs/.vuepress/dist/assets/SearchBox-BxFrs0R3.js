import{f as S,g as B,h as O,i as j,t as P,u as T,j as k,_ as J,o as m,c as d,k as M,v as N,a as b,n as v,l as y,F as L,m as I,p as f,q as D,s as H}from"./app-CnclWRTO.js";const R=[{path:"/get-started.html",title:"Get Started",pathLocale:"/",contents:[{header:"Get Started",slug:"get-started",content:"This is a normal page, which contains VuePress basics."},{header:"Pages",slug:"pages",content:`You can add markdown files in your vuepress directory, every markdown file will be converted to a page in your site.
See routing for more details.`},{header:"Content",slug:"content",content:`Every markdown file will be rendered to HTML, then converted to a Vue SFC.
VuePress support basic markdown syntax and some extensions, you can also use Vue features in it.`},{header:"Configuration",slug:"configuration",content:`VuePress use a .vuepress/config.js(or .ts) file as site configuration, you can use it to config your site.
For client side configuration, you can create .vuepress/client.js(or .ts).
Meanwhile, you can also add configuration per page with frontmatter.`},{header:"Layouts and customization",slug:"layouts-and-customization",content:`Here are common configuration controlling layout of @vuepress/theme-default: navbar
sidebar Check default theme docs for full reference.
You can add extra style with .vuepress/styles/index.scss file.`}]},{path:"/",title:"首页",pathLocale:"/",contents:[]},{path:"/posts/archive1.html",title:"Archive Article1",pathLocale:"/",contents:[{header:"Archive Article1",slug:"archive-article1",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/archive2.html",title:"Archive Article2",pathLocale:"/",contents:[{header:"Archive Article2",slug:"archive-article2",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article1.html",title:"Article 1",pathLocale:"/",contents:[{header:"Article 1",slug:"article-1",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article10.html",title:"Article 10",pathLocale:"/",contents:[{header:"Article 10",slug:"article-10",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article11.html",title:"Article 11",pathLocale:"/",contents:[{header:"Article 11",slug:"article-11",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article12.html",title:"Article 12",pathLocale:"/",contents:[{header:"Article 12",slug:"article-12",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article2.html",title:"Article 2",pathLocale:"/",contents:[{header:"Article 2",slug:"article-2",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article3.html",title:"Article 3",pathLocale:"/",contents:[{header:"Article 3",slug:"article-3",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article4.html",title:"Article 4",pathLocale:"/",contents:[{header:"Article 4",slug:"article-4",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article5.html",title:"Article 5",pathLocale:"/",contents:[{header:"Article 5",slug:"article-5",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article6.html",title:"Article 6",pathLocale:"/",contents:[{header:"Article 6",slug:"article-6",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article7.html",title:"Article 7",pathLocale:"/",contents:[{header:"Article 7",slug:"article-7",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article8.html",title:"Article 8",pathLocale:"/",contents:[{header:"Article 8",slug:"article-8",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/article9.html",title:"Article 9",pathLocale:"/",contents:[{header:"Article 9",slug:"article-9",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/sticky.html",title:"Sticky Article",pathLocale:"/",contents:[{header:"Sticky Article",slug:"sticky-article",content:""},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/posts/sticky2.html",title:"Sticky Article with Higher Priority",pathLocale:"/",contents:[{header:"Sticky Article with Higher Priority",slug:"sticky-article-with-higher-priority",content:"Excerpt information which is added manually."},{header:"Heading 2",slug:"heading-2",content:"Here is the content."},{header:"Heading 3",slug:"heading-3",content:"Here is the content."}]},{path:"/ui/ui.html",title:"",pathLocale:"/",contents:[{header:"Ui 设计网站积累",slug:"ui-设计网站积累",content:""},{header:"设计相关",slug:"设计相关",content:`即时设计
ui 设计素材导航
ui 设计网站导航
蓝湖`},{header:"Css",slug:"css",content:`Animista 动画库
Icônes
uiverse
NavNav`},{header:"素材网站",slug:"素材网站",content:`站酷
千库网
菜鸟图库
花瓣网
专属设计师导航-甲方叭叭
uistore 免费素材下载
GSAP`}]},{path:"/admin/Node/",title:"",pathLocale:"/",contents:[]},{path:"/admin/Java/",title:"",pathLocale:"/",contents:[{header:"java",slug:"java",content:"java 部分包括 java 基础"}]},{path:"/web/React/",title:"",pathLocale:"/",contents:[{header:"react",slug:"react",content:""}]},{path:"/web/Vue/",title:"",pathLocale:"/",contents:[{header:"Vue",slug:"vue",content:""}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/ASCII%E7%BC%96%E7%A0%81.html",title:"",pathLocale:"/",contents:[{header:"ASCII 编码",slug:"ascii-编码",content:`谨记以下 前 3 个编码,相对应的英文字母的编码就相对应的往上加
'a' -> 97 'A' -> 65 '0' -> 48
0 -> 0
1 -> 1
2 -> 2
...
9 -> 9
'A' -> 65
'B' -> 66
...
'Z' -> 90
'a' -> 97
'b' -> 98
...
'z' -> 122`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/final.html",title:"",pathLocale:"/",contents:[{header:"final",slug:"final",content:"常量、初始值、不被继承、不被重写"},{header:"final 关键字的特点",slug:"final-关键字的特点",content:`final 关键字修饰的变量就是常量
常量的分类 字面量常量 整数常量
小数常量
字符常量
字符串常量
布尔常量
空常量 自定义常量 被 final 修饰的变量 被 final 修饰的类不能被继承 被 final 修饰的成员方法不能被重写`},{header:"final 的注意事项",slug:"final-的注意事项",content:`如果一个成员变量，在被定义的时候，并没有赋初始值，会编译报错，我们必须给其赋值。
赋值的方式有两种： 定义的同时赋值 有参构造赋值 public class Demo { final int a; // 编译报错 final int age = 18; // 没有问题 // final char value = 'final'; // 没有问题 方式一 final int value; // 没有问题 public Demo(int value) { this.value = value; // 方式二 }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/",title:"",pathLocale:"/",contents:[]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/static.html",title:"",pathLocale:"/",contents:[{header:"static",slug:"static",content:"共享成员、只能访问静态变量和方法、与实例对象无关、优先对象加载等问题 static 是一个修饰符，代表静态的意思，用来修饰成员变量和成员方法的，不能修饰构造方法。"},{header:"特点",slug:"特点",content:`被 static 修饰的成员变量和成员方法在内存中只有一个副本，被所有对象共享。 被 static 修饰的成员变量和成员方法独立于该类的任何对象。也就是说，这些成员变量和成员方法与类的任何对象实例无关，它们属于类本身，因此通过类名就可以访问它们。
类名.成员变量
类名.成员方法() 被 static 修饰的成员变量和成员方法随着字节码文件对象的加载而加载，所以是优先于对象存在于内存中。`},{header:"案例",slug:"案例",content:"静态方法只能访问类的静态成员变量和静态方法，不能访问非静态成员变量和非静态方法 class Person{ String name; static int age; public static void eat(){ drink(); // 没有问题 System.out.println(name); // 没有问题 sleep(); // 编译报错 System.out.println(age); // 编译报错 } public static void drink(){ } public void sleep(){ } }"}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/super.html",title:"",pathLocale:"/",contents:[{header:"super",slug:"super",content:`super指向父类、this指向本类
构造方法中第一行要么this(参数)要么super(参数)，但不共存
至少有一个构造方法中调用super() super 是父类内存空间的标记，在用法上，我们可以当作父类对象的引用来使用，但是我们不能说
super 就是父类对象的引用`},{header:"super 关键字和 this 关键字的区别",slug:"super-关键字和-this-关键字的区别",content:"调用构造方法 super() 调用父类的构造方法 this() 调用本类的构造方法 调用成员方法 super.方法名() 调用父类中的成员方法 this.方法名() 调用本类中的成员方法 调用成员变量 super.变量名 调用父类中的成员变量 this.变量名 调用本类中的成员变量"},{header:"具体说明 super 和 this",slug:"具体说明-super-和-this",content:`子类中的所有的构造方法的第一行，默认都有一个super()。 // 因为有继承，说明子类可以使用父类的成员变量，那也就意味着父类的成员变量一定要有一直 // 才可以被使用，所以在创建类对象的时候，会调用子类的构造方法，而子类的构造方法中会先 // 去调用父类的构造方法，目的就是给父类的额成员变量默认初始化
class Fu{ String name; public Fu(){ // 父类默认有一个无参构造 System.out.println("Fu的无参构造"); }
}
class Zi extends Fu{ public Zi(){ super(); // 默认调用父类的无参构造 } public Zi(String name){ super(); // 默认调用父类的无参构造 } public Zi(int age){ super(); // 默认调用父类的无参构造 } public Zi(String name,int age){ super(); // 默认调用父类的无参构造 }
}
class Demo { public static void main(String[] args) { Zi zi = new Zi(); System.out.println(zi.name); // null }
} 子类中的所有构造方法中， 第一行要么是 super(参数)，要么是 this(参数)，他们不能同时存在。 class Fu{ String name; public Fu(){ }
}
class Zi extends Fu{ public Zi(String name){ super(); // this(); // 错误，super和this不能同时存在 } public Zi(){ this("张三"); // 正确的，因为调用了上面的有参构造 }
} 子类中的所有的构造方法中至少有一个构造方法里面调用的是 super(参数)，如果没有显式的调用 super(参数)，则默认调用 super()。 class Fu{ String name; int age;
}
class Zi extends Fu{ public Zi(){ this("aaa"); } public Zi(String name){ this(18); } public Zi(int age){ this("aaa", 18) } public Zi(String name,int age){ // super(); }
}
class Demo { public static void main(String[] args) { Zi zi = new Zi(); }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E4%BB%A3%E7%A0%81%E5%9D%97.html",title:"",pathLocale:"/",contents:[{header:"代码块",slug:"代码块",content:`局部代码块: 方法执行后消失，释放内存；
构造代码块: 抽离共有部分，每次创建对象都执行；
静态代码块: 只加载一次，抽离共有部分`},{header:"局部代码块",slug:"局部代码块",content:`定义在方法中的代码块就是局部代码块
作用: 能够让局部变量，更早的在内存中消失，节省内存空间 // 基础用法
class Demo{ public void test() { { // 这就是局部代码块 } }
} // 节省内存空间
class Demo{ public void test() { { int num = 20; System.out.println(num); // num变量有必要活得很久嘛? } // 局部代码块执行完毕后，num变量就自动消失 System.out.println(num); // 报错 for (int i = 0; i < 10; i++) { .... } /** * 假设这个位置上有100000行代码，但是均无用到num变量 */ }
}`},{header:"构造代码块",slug:"构造代码块",content:`定义在类中，方法外的代码块，就是构造代码块。
作用: 构造代码块是在创建对象的时候执行，并且是优先于构造方法先执行 构造代码块是给所有对象共有的属性进行初始化 每次创建对象都会执行一次构造代码块 class Demo{ public static void main(String[] args) { // 下面的任何一个对象的创建都会执行构造代码块中的方法哭 Person p1 = new Person(); Person p2 = new Person(18); Person p3 = new Person(18, "张三"); }
}
class Cry{ { // 构造代码块提取出来的共有相同部分，不用在重写方法中再写了 System.out.println("哭"); } public Cry() { // System.out.println("哭"); } public Cry(int age) { // System.out.println("哭"); } public Cry(int age, String Name) { // System.out.println("哭"); }
}`},{header:"静态代码块",slug:"静态代码块",content:"被静态修饰的 构造代码块，就成为静态代码块 静态代码块什么时候执行? 可以说类加载的时候执行，并且只执行一次；也可以说是.class 文件从磁盘中加载到方法区形成字节码文件对象的时候，静态代码块会随之执行。 为什么只执行一次? 因为字节码文件只加载一次，并且是优先于所有对象的创建而执行的。 静态代码块的执行要早于构造代码块的执行，并且只执行一次 作用呢? 给静态属性进行初始化，当数据只需要被初始化一次的时候，之后就可以重复使用的时候，就可以使用静态代码块。"},{header:"类的初始化顺序",slug:"类的初始化顺序",content:`public static void main(String[] args){ Zi zi = new Zi(); // new Zi()相当于调构造方法 System.out.println("--------------------");
}
class Fu{ static { System.out.println("父类静态代码块"); } { System.out.println("父类构造代码块"); } public Fu() { System.out.println("父类构造方法"); }
}
class Zi extends Fu{ static { System.out.println("子类静态代码块"); } { System.out.println("子类构造代码块"); } public Zi() { // 1. super() 执行父类 // 2. 执行本类中的构造代码块和构造方法 System.out.println("子类构造方法"); }
}
/** * 运行结果： * 父类静态代码块 * 子类静态代码块 * 父类构造代码块 * 父类构造方法 * 子类构造代码块 * 子类构造方法 * ---------------------
*/`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E4%BF%AE%E9%A5%B0%E7%AC%A6.html",title:"",pathLocale:"/",contents:[{header:"修饰符",slug:"修饰符",content:`开发中一般用public 修饰类，用private 修饰属性
public > protected > 默认的(什么都不写) > private
public：都行
protected：既不同包又不继承那不行
默认的：不同包就不行
private：只有同类才能访问 以后开发中，一个类的各个组成部分都用什么修饰符来修饰
类: public
属性: private
构造方法: public，偶尔用 private
成员方法: public`},{header:"导包",slug:"导包",content:`import 包名.类名 快捷键: Ctrl + Shift + O 包名：一般是小写的域名的倒置，去掉 www 如果两个类不在同一个包下，类 A 想要使用 类 B，必须导入类 B 所在的包 com.aaa
|-- A
com.bbb
|-- B`},{header:"访问权限修饰符",slug:"访问权限修饰符",content:`public > protected > 默认的(什么都不写) > private
public：都行
protected：既不同包又不继承那不行
默认的：不同包就不行
private：只有同类才能访问 修饰符
同类中
同包不同类有继承关系
同包不同类无继承关系
不同包有继承关系
不同包没有继承关系 public
true
true
true
true
true protected
true
true
true
true
false 默认的
true
true
true
false
false private
true
false
false
false
false 不同包有继承关系 同包不同类无继承关系 同包不同类有继承关系`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E5%86%85%E9%83%A8%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"内部类",slug:"内部类",content:`什么是内部类 ?
一个类写在另一个类的里边，里边的类就是内部类
内部类有什么特点 ?
内部类可以直接访问外部类的成员，包括私有成员
外部类不能直接访问内部类，要访问内部类的成员，必须通过间接的方式，通过创建内部类的对象来访问`},{header:"1. 成员内部类",slug:"_1-成员内部类",content:"定义在类中，方法外的内部类叫成员内部类"},{header:"成员内部类的使用",slug:"成员内部类的使用",content:""},{header:"1. 修饰符为 public、protected、默认的",slug:"_1-修饰符为-public、protected、默认的",content:`class Outer { protected class Inner { int i = 1; public void show() { System.out.println("内部类方法"); } }
}
class Demo{ public static void main(String[] args) { Outer.Inner in = new Outer().new Inner(); System.out.println(in.i); // 1 in.show(); // 内部类方法 }
}`},{header:"2. 修饰符为 static",slug:"_2-修饰符为-static",content:`class Outer { static class Inner { int i = 1; public void show() { System.out.println("内部类方法"); } }
}
class Demo{ public static void main(String[] args) { /** * 方式一 */ Outer.Inner in = new Outer.Inner(); System.out.println(in.i); // 1 in.show(); // 内部类方法 /** * 方式二 */ // 需要先导包 import com.inner.Outer.Inner; Inner in2 = new Inner(); System.out.println(in2.i); // 1 in2.show(); // 内部类方法 }
}`},{header:"3. 修饰符为 private",slug:"_3-修饰符为-private",content:`class Outer { private class Inner { int i = 1; public void show() { System.out.println("内部类方法"); } } public void print() { Inner in = new Inner(); System.out.println(in.i); // 1 in.show(); // 内部类方法 }
}
class Demo{ public static void main(String[] args) { Outer ou = new Outer(); ou.print(); }
}`},{header:"2. 局部内部类",slug:"_2-局部内部类",content:`定义在类中，方法内的内部类叫局部内部类 class Outer { public void print() { class Inner { int i = 1; public void show() { System.out.println("局部内部类方法"); } } Inner in = new Inner(); System.out.println(in.i); // 1 in.show(); // 局部内部类方法 }
}
class Demo { public static void main(String[] args) { Outer ou = new Outer(); ou.print(); }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"匿名内部类(匿名子类对象)",slug:"匿名内部类-匿名子类对象",content:`匿名内部类就是没有名字的局部内部类，也叫匿名子类对象
实际就是子类对象
格式：
new 类名/接口名(){
重写的方法
自定义的方法
} new Person(){ // 这就是匿名内部类的格式 }
当一个方法的形参是接口或者是抽象类的时候，我们可以使用匿名子对象进行传递
/** * 理解
*/
interface Inter { public abstract void print();
}
class Demo{ public static void main(String[] args){ /** * 想要在本处执行show方法，但是需要传递一个参数，但是接口不能new实例化 */ // show(); show(new Inter(){ public abstract void print(){ System.out.printIn("这就是匿名子对象或者叫匿名内部类的好处！") } }) } public static void show(Inter inter){ /** * Inter inter: 参数是接口或者是抽象类可以用匿名子对象进行传递 * Inter inter = new Inter(){} * Inter inter => Fu fu * new Inter(){} => new Zi() * 格式: Fu fu = new Zi() * {} => 匿名对象 * 多态形式的 */ inter.print(); }
}
/** * 案例一
*/
public class Demo{ public static void main(String[] args){ // 父类的子对象，但是是匿名的 new Fu(){ // 重写的方法 public void show(Inter inter){ inter.print(); } }.show(new Inter(){ public void print(){ System.out.println("这块就是为了展示调用方法！"); } }); }
}
abstract class Fu{ public abstract void show(Inter inter);
}
interface Inter{ public abstract void print();
}
/** * 案例二
*/
public class Demo{ public static void main(String[] args){ Tool.getInstance().show(); }
}
interface Inter{ public static void show();
}
class Tool{ public static Inter getInstance(){ return new Inter(){ public static void show(){ System.out.println("约吗！"); } }; }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E5%A4%9A%E6%80%81.html",title:"",pathLocale:"/",contents:[{header:"多态",slug:"多态",content:`运行和编译看哪边指的是等号的左边和右边，即看实例对象的类型；
正常情况下，父类不能使用子类中特有的内容
向上转型(多态)、向下转型Zi zi = (Zi)Fu。 前提条件: 要有继承关系 要有方法的重写 要有父类引用指向子类对象`},{header:"多态的用法",slug:"多态的用法",content:`class Fu { public void print(){}
}
class Zi extends Fu { // 有继承关系 public void print(){} // 有方法重写
}
class Demo{ public static void main(String[] args){ Fu fu = new Zi(); // 父类引用指向子类对象 }
}`},{header:"多态间子父类之间成员变量的关系(编译看左边，运行看左边)",slug:"多态间子父类之间成员变量的关系-编译看左边-运行看左边",content:`// 父类中的成员变量与子类中的成员变量不同
class Fu { int i = 10;
}
class Zi extends Fu { int j = 20;
}
class Demo{ public static void main(String[] args){ Fu fu = new Zi(); System.out.println(fu.i); // 10 System.out.println(fu.j); // 编译报错 }
}
/** * 父类引用中不能使用子类中特有的成员变量 * 改成 Zi fu = new Zi(); 即可
*/
// 父类中的成员变量与子类中的成员变量相同
class Fu { int i = 10;
}
class Zi extends Fu { int i = 20;
}
class Demo{ public static void main(String[] args){ Fu fu = new Zi(); System.out.println(fu.i); // 10 System.out.println(fu.i); // 10 }
}
/** * 父类引用只能使用自身中特有的成员变量，不能使用子类中的成员变量 * 子类对象可以调用父类中特有的成员变量 * 改成 Zi fu = new Zi(); 的话打印结果为 20 20
*/`},{header:"多态间子父类之间成员方法的关系(编译看左边，运行看右边)",slug:"多态间子父类之间成员方法的关系-编译看左边-运行看右边",content:`// 父类中的成员方法与子类中的成员方法不同
class Fu { public void printFu(){ System.out.println("Fu"); }
}
class Zi extends Fu { public void printZi(){ System.out.println("Zi"); }
}
class Demo{ public static void main(String[] args){ Fu fu = new Zi(); fu.printFu(); // Fu fu.printZi(); // 编译报错 }
}
/** * 父类引用中不能使用子类中特有的成员方法 * 改成 Zi fu = new Zi(); 即可
*/
// 父类中的成员方法与子类中的成员方法相同
class Fu { public void print(){ System.out.println("Fu"); }
}
class Zi extends Fu { public void print(){ System.out.println("Zi"); }
}
class Demo{ public static void main(String[] args){ Fu fu = new Zi(); fu.print(); // Zi fu.print(); // Zi }
}
/** * 父类引用中可以使用子类中重写父类的方法
*/`},{header:"多态间子父类之间静态成员的关系(多态，静态，成员变量和成员方法，编译看左边，运行看左边)",slug:"多态间子父类之间静态成员的关系-多态-静态-成员变量和成员方法-编译看左边-运行看左边",content:`// 父类中的静态成员与子类中的静态成员相同
class Fu { static int i = 10;
}
class Zi extends Fu { static int i = 20;
}
class Demo{ public static void main(String[] args){ Fu fu = new Zi(); System.out.println(fu.i); // 10 System.out.println(fu.i); // 10 }
}
// 父类中的静态成员与子类中的静态成员不同
class Fu { static int i = 10;
}
class Zi extends Fu { static int j = 20;
}
class Demo{ public static void main(String[] args){ Fu fu = new Zi(); System.out.println(fu.i); // 10 System.out.println(fu.j); // 编译报错 }
}`},{header:"多态的实际应用",slug:"多态的实际应用",content:`class AnimalTool { // AnimalTool是类方法，也叫静态方法 public static void eat(Animal animal){ // 有父类对子类的指向 animal.eat(); }
}
class Animal{ public void eat(){ System.out.println("动物吃东西"); }
}
class Dog extends Animal{ // 有继承 public void eat(){ // 有重写 System.out.println("狗吃肉"); }
}
class Cat extends Animal{ public void eat(){ System.out.println("猫吃鱼"); }
}
class Pig extends Animal{ public void eat(){ System.out.println("猪吃白菜"); }
}
class Demo{ public static void main(String[] args){ // 狗吃肉: 有父类对子类的指向 AnimalTool.eat(new Dog()); // 猫吃鱼: 类方法(静态方法)可以类名.方法名( AnimalTool.eat(new Cat()); //猪吃白菜: Animal animal = new Pig() => Fu fu = new Zi() AnimalTool.eat(new Pig()); }
}`},{header:"向上转型(就是多态)",slug:"向上转型-就是多态",content:"Fu Fu = new Zi();"},{header:"向下转型(解决多态的弊端)",slug:"向下转型-解决多态的弊端",content:`Zi zi = (Zi)fu; // 有点像强制类型转换 多态的弊端:
父类不能使用子类中特有的变量，向下转型后即可。
举例说明，有一只小狗，长的很漂亮，我们可以说那只小狗长得很漂亮，
当然也可以说那个动物长得很漂亮，
漂亮本是狗的特有属性，这就是向下转型的意义。 class Animal{ public void eat(){ System.out.println("动物吃东西"); }
}
class Dog extends Animal{ // 有继承 public void eat(){ // 有重写 System.out.println("狗吃肉"); }
}
class Cat extends Animal{ // 有继承 public void eat(){ // 有重写 System.out.println("猫吃鱼"); }
}
class Demo{ public static void main(String[] args){ Animal animal = new Dog(); // 向上转型 Fu fu = new Zi() Dog dog = (Dog)animal; // 向下转型，Zi zi = (Zi) fu，转型后即可使用子类中特有的成员 dog.eat(); // 狗吃肉 Cat cat = (Cat)animal; // 错误的，因为animal是new Dog()的实例，不能再用猫来修饰 cat.eat(); // 报错，因为cat是猫，而animal是动物，所以不能使用 }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E5%B0%81%E8%A3%85.html",title:"",pathLocale:"/",contents:[{header:"封装",slug:"封装",content:`封装是指隐藏对象的属性和实现细节，仅对外提供公共的访问方式。
隐藏对象的属性，只需要在属性定义的前面加上一个关键字 super 即可。
对外提供公共的访问方式，就是在类中写上几个 setXXX(...)和 getXXX()即可。`},{header:"private 关键字",slug:"private-关键字",content:`什么是 private 关键字
private 是一个修饰符，代表私有的意思，可以修饰成员变量和成员方法以及构造函数
private 关键字的特点
被 private 关键字修饰的成员变量和成员方法不能在本类中使用，不能在其他类中使用
private 关键字怎么用`},{header:"举例",slug:"举例",content:`this代表对象的引用，哪个对象调用 this 所在的方法，this 就代表哪个对象
this可以解决局部变量隐藏成员变量的问题 class Person{ private String name; private int age; private String sex; public void setName(String n){ this.name = n; // this可以解决局部变量隐藏成员变量的问题 } public String getName(){ return this.name; } public void setAge(int n){ this.age = n; } public int getAge(){ return this.age; } public void setSex(String n){ this.sex = n; } public String getSex(){ return this.sex; }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F.html",title:"",pathLocale:"/",contents:[{header:"成员变量和局部变量",slug:"成员变量和局部变量",content:"初始值、区别、匿名对象可以当实参、方法和对象回收等问题"},{header:"成员变量和局部变量的区别",slug:"成员变量和局部变量的区别",content:`定义的位置不同
成员变量：定义在类中方法外
局部变量：定义在方法中或方法的声明上
// 成员变量
public class Person { private String name; // 在类中、方法外定义的变量 public void info() { System.out.println(name); // null }
}
// 局部变量
public class Person { public void info() { String name = '小明'; // 在info方法中定义的变量 }
} // 局部变量
public class Person { public void info(int age) { // age是局部变量，定义在info方法的声明上 age = 10; System.out.println(age); }
} 内存位置不同
成员变量：存储在堆中的对象中
局部变量：存储在栈中的方法中 初始值不同
成员变量：有默认初始值，如果不赋值也可以使用 String 类型的成员变量：默认初始值是 null
int 类型的成员变量：默认初始值是 0
char 类型的成员变量：默认初始值是'\\u0000'
boolean 类型的成员变量：默认初始值是 false
引用类型的成员变量：默认初始值是 null 局部变量：没有默认初始值，如果没有赋值，不能使用，否则报错，使用前必须先赋值 声明周期不同
成员变量：随着对象的创建而存在，随着对象的消失而消失
局部变量：随着方法的调用而存在，随着方法的调用完毕而消失 作用域范围不同
成员变量：整个类中都可以使用
局部变量：只能在方法中使用，出了方法就用不了了`},{header:"案例",slug:"案例",content:"匿名对象可以做为实际参数传递 方法和对象的回收 共享static属性"}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E6%8A%BD%E8%B1%A1%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"抽象类(abstract)",slug:"抽象类-abstract",content:`可继承(要么是抽象类继承，要么普通类继承但是必须重写所有方法)
可以有构造方法，但是不能实例化，即不能创建对象
abstract不能与 private、static、final共存 什么是抽象类 ?
被 abstract 关键字所修饰的类就是抽象类
有抽象方法的类就是抽象类，但是抽象类不一定有抽象方法
抽象类不能被实例化`},{header:"抽象类特征",slug:"抽象类特征",content:`抽象类和抽象方法都要由 abstract 关键字修饰 abstract class Person{ public abstract void eat();
} class Student extends Person{ public void eat(){ System.out.println("eat 肉"); }
}
class Teacher extends Person{ public void eat(){ System.out.println("eat 饭"); }
}
public class Test{ public static void main(String[] args){ Student s = new Student(); Teacher t = new Teacher(); s.eat(); t.eat(); }
} 抽象类可以没有抽象方法，但是有抽象方法的类一定是抽象类 抽象类可以被继承，可以有构造方法，但是不能实例化，即不能创建对象 一个类要继承抽象类，要么该类也是抽象类，要么该类是一个普通类，但是必须重写所有的抽象方法`},{header:"abstract 关键字不能与哪些关键字共存",slug:"abstract-关键字不能与哪些关键字共存",content:'abstract 不能与 private 共存 因为被 abstract 修饰的方法是抽象方法，子类是必须要重写的，如果该类同时又被 private 修饰，那么子类就无法重写该方法，所以矛盾 abstract class Fu{ private abstract void show(); // 编译报错 } class Zi extends Fu{ public void show(){ System.out.println("show 方法"); } } abstract 不能与 protected 共存 因为被 protected 修饰的方法是受保护的，子类可以访问，但是子类不能重写该方法 abstract class Fu{ protected abstract void show(); // 编译报错 } abstract 不能与 static 共存 因为被 static 修饰的方法可以通过类名直接访问，而抽象方法是没有方法体的，出现矛盾 abstract class Person{ abstract static void eat(); // 编译报错 } Person.eat(); // 编译报错 abstract 不能与 final 共存 因为被 final 修饰的方法是最终方法，不能被重写，出现矛盾 abstract class Fu{ final abstract void eat(); // 编译报错 } class Zi extends Fu{ public void eat(){ System.out.println("eat 方法"); } }'},{header:"抽象类的作用",slug:"抽象类的作用",content:`抽象类提高代码的可读性和可维护性和可扩展性
抽象类和接口可以实现多态 // 抽象类
abstract class Animal { String name; public Animal(String name) { this.name = name; } public abstract void eat();
}
class Dog extends Animal { public Dog(String name) { super(name); } public void eat() { System.out.println(name + " is eating dog food."); }
}
class Cat extends Animal { public Cat(String name) { super(name); } public void eat() { System.out.println(name + " is eating cat food."); }
}
public class Test { public static void main(String[] args) { Animal dog = new Dog("旺财"); dog.eat(); Animal cat = new Cat("喵喵"); cat.eat(); }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3.html",title:"",pathLocale:"/",contents:[{header:"接口(interface)",slug:"接口-interface",content:`变量：public static final int i = 1
方法：public abstract
构造方法: 无
接口的实现：抽象类
可继承、必须重写所有的抽象方法 什么是接口 ?
比抽象类表现更加抽象的表现形式，就是接口
接口的格式 ?
interface 接口名 {
}
接口不是类 !!! interface Inter { }
class Zi implements Inter{ }`},{header:"接口的特点",slug:"接口的特点",content:"接口不是类，不能创建对象，接口需要类来实现 接口中的所有方法都是抽象方法(我们能用到的是，但是 java 开发人员不是) 一个类，如果想要实现一个接口，要么该类是抽象类，要么该类是普通类但是必须重写接口的抽象所有方法"},{header:"接口的成员特点",slug:"接口的成员特点",content:`成员变量 接口的所有变量全部都是自定义常量
默认修饰符: public static final public static final int i = 10; static final int j = 20; int x = 30; 成员方法 接口中的所有方法都是抽象方法(java 开发人员除外)
默认修饰符: public abstract public abstract void aaa(); public void bbb(); public void ccc(); void ddd(); 构造方法 接口中没有构造方法`},{header:"接口基础用法",slug:"接口基础用法",content:`public class Demo{ public static void main(String[] args){ Zi zi = new Zi(); }
}
interface Inter{ public static final int i = 10; public abstract void aaa(); public void bbb();
}
class Zi implements Inter{ @Override public void aaa(){ System.out.println("aaa"); } public void bbb(){ System.out.println("bbb"); }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.html",title:"",pathLocale:"/",contents:[{header:"数据类型",slug:"数据类型",content:`数据类型
关键字
内存占用
取值范围 整数
byte
1 字节
-128~127 short
2 字节
-32768~32767 int
4 字节
-2 的 31 次方 到 2 的 31 次方-1 long
8 字节
-2 的 63 次方 到 2 的 63 次方-1 浮点数
float
4 字节
1.4E-45~3.402823E+38 double
8 字节
4.9E-324~1.7976931348623157E+308 字符
char
2 字节
0~65535 布尔
boolean
1 字节
true,false`},{header:"常见的考试题",slug:"常见的考试题",content:`针对 byte 类型和 short 类型的时候，只要右边有一个是变量，就会编译报错 byte b1 = 1;
byte b2 = 2;
byte b3 = b1 + b2;
System.out.printIn(b3) //编译报错
short s1 = 1;
short s2 = 2;
short s3 = s1 + s2;
System.out.printIn(s3) //编译报错
byte b1 = 1;
byte b2 = b1 + 2;
System.out.printIn(b2); //编译报错
short s1 = 1;
short s2 = s1 + 2;
System.out.printIn(s2); //编译报错 注意数据类型的范围 byte b = 126 + 1;
System.out.printIn (b) ; //正确，127
byte b = 127 + 1;
System.out.printIn (b); //编译报错，因为 byte 范围最大值是 127`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E6%95%B0%E7%BB%84.html",title:"",pathLocale:"/",contents:[{header:"数组",slug:"数组",content:""},{header:"特征",slug:"特征",content:`一旦初始化，数组的长度就固定了，不能修改
数组的长度必须是一个大于0的整数
数组的元素可以是任意数据类型（包括 null、基本数据类型、引用数据类型、对象、方法、数组、接口、枚举、注解等）
数组的元素必须是相同的数据类型`},{header:"数组格式的定义",slug:"数组格式的定义",content:"格式一：数据类型[] 数组名 = new 数据类型[长度] int[] arr = new int[5]; 格式二：数据类型[] 数组名 = new 数据类型[]{元素 1, 元素 2, 元素 3...} int[] arr = new int[]{1, 2, 3, 4, 5}; 格式三：数据类型[] 数组名 = {元素 1, 元素 2, 元素 3...} int[] arr = {1, 2, 3, 4, 5};"},{header:"常见的错误类型",slug:"常见的错误类型",content:`ArrayIndexOutOfBoundsException(数组越界) int[] arr = {1, 2, 3, 4, 5};
System.out.println(arr[5]); // 数组越界 数组中只有5个元素，索引范围是0-4 NullPointerException(空指针异常) int arr = {1, 2, 3};
System.out.println(arr[0]);
System.out.println(arr[1]);
System.out.println(arr[2]);
arr = null;
System.out.println(arr[0]); // 这一行会引发空指针异，因为数组arr的值是null了 null 是空常量，只能赋值给引用数据类型的变量 int [] arr = null;
或者
String str = null;`},{header:"数组的遍历",slug:"数组的遍历",content:`int[] arr = {1, 2, 3, 4, 5};
for (int i = 0; i < arr.length; i++) { System.out.println(arr[i]);
}`},{header:"数组的复制",slug:"数组的复制",content:`int[] arr1 = {1, 2, 3, 4, 5};
int[] arr2 = new int[arr1.length];
for (int i = 0; i < arr1.length; i++) { arr2[i] = arr1[i];
}`},{header:"数组的反转",slug:"数组的反转",content:`int[] arr = {1, 2, 3, 4, 5};
for (int i = 0; i < arr.length / 2; i++) { int temp = arr[i]; arr[i] = arr[arr.length - 1 - i]; arr[arr.length - 1 - i] = temp;
}`},{header:"数组的排序",slug:"数组的排序",content:`int[] arr = {1, 2, 3, 4, 5};
Arrays.sort(arr); // 默认升序`},{header:"数组的查找",slug:"数组的查找",content:`int[] arr = {1, 2, 3, 4, 5};
int index = Arrays.binarySearch(arr, 3); // 返回3的索引，如果没有返回-3`},{header:"数组的合并",slug:"数组的合并",content:`int[] arr1 = {1, 2, 3, 4, 5};
int[] arr2 = {6, 7, 8, 9, 10};
int[] arr3 = new int[arr1.length + arr2.length];
System.arraycopy(arr1, 0, arr3, 0, arr1.length);
System.arraycopy(arr2, 0, arr3, arr1.length, arr2.length);`},{header:"数组的填充",slug:"数组的填充",content:`int[] arr = new int[5];
Arrays.fill(arr, 10); // 将数组arr的所有元素填充为10`},{header:"数组的比较",slug:"数组的比较",content:`int[] arr1 = {1, 2, 3, 4, 5};
int[] arr2 = {1, 2, 3, 4, 5};
boolean isEqual = Arrays.equals(arr1, arr2); // 比较两个数组是否相等`},{header:"数组的转换",slug:"数组的转换",content:`int[] arr = {1, 2, 3, 4, 5};
String str = Arrays.toString(arr); // 将数组转换为字符串`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E6%96%B9%E6%B3%95.html",title:"",pathLocale:"/",contents:[{header:"方法",slug:"方法",content:""},{header:"作用",slug:"作用",content:`提高了代码的复用性
提高了代码的可读性和可维护性`},{header:"格式",slug:"格式",content:`修饰符 返回值类型 方法名(数据类型 变量名, 数据类型 变量名, ...){
执行的代码
return 返回值;
}`},{header:"修饰符",slug:"修饰符",content:`public 公共的，任何类都可以访问
private 私有的，只能在本类中访问
protected 受保护的，在本类，子类中可以访问
static 静态的，可以被类名调用，也可以被对象调用
abstract 抽象的，不能被实例化，只能被继承
final 最终的，不能被继承`},{header:"返回值类型",slug:"返回值类型",content:`void 没有返回值
基本数据类型 返回基本数据类型
引用数据类型 返回引用数据类型
返回自定义的数据类型`},{header:"方法名",slug:"方法名",content:`见名知意
驼峰命名法(首字母小写，后面每个单词首字母大写)`},{header:"如何写一个方法",slug:"如何写一个方法",content:`明确参数
明确返回值 // 需求: 定义一个方法，能够计算两个数字的和 public static int getSum(int a, int b){ return a + b; }`},{header:"使用方法时需要注意的问题",slug:"使用方法时需要注意的问题",content:`方法与方法之间是平级关系，不能嵌套定义 // 错误案例:
public static int add (){ public void bbb(){ return 10; } return 10;
} 方法的返回值类型和返回值要匹配 public static int aaa (){ return 10;
}
protected static double aaa (){ return 10.0; // return 10; 也可以
}
public static String aaa (){ return "hello";
}
public static int aaa (){ return '1'; // 错误案例,编译报错
} 当没有返回值类型时，返回值类型为 void public static void aaa (){ return;
} void：没有什么特殊含义，只能写在返回值类型的位置上，表示没有返回值
返回值类型为 void，不要写 return 语句， 写了也不会报错但是可以省略且顺应 Java 语法规范`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD.html",title:"",pathLocale:"/",contents:[{header:"重载(@Overload)",slug:"重载-overload",content:""},{header:"1. 重载的概念",slug:"_1-重载的概念",content:`重载：在同一个类中，出现多个方法的名字相同，但是它们的形参（参数个数、参数类型、参数顺序）不同的多个方法。
方法的重载与返回值类型无关。`},{header:"3. 重载和重写的区别",slug:"_3-重载和重写的区别",content:`重载：发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，通过同名不同参数的方法重载。 重写：子类根据需要对从父类继承来的方法进行改造，使得父类方法在子类中得到新的实现版本。
重写和重载都是实现多态的方式，区别在于重载发生于同一个类中，重载发生在编译期，重写发生于继承体系中，发生在运行期。 // 方法重载的案例
public class OverloadExample { public void test() { System.out.println("无参数方法被调用！"); } public void test(int a) { System.out.println("int类型参数方法被调用！"); } public void test(int a, double b) { System.out.println("int类型和double类型参数方法被调用！"); } public void test(double b, int a) { System.out.println("double类型和int类型参数方法被调用！"); } public void test(String str) { System.out.println("String类型参数方法被调用！"); } public static void main(String[] args) { OverloadExample ex = new OverloadExample(); ex.test(); ex.test(10); ex.test("hello"); }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E7%B1%BB%E4%B8%8E%E6%8E%A5%E5%8F%A3.html",title:"",pathLocale:"/",contents:[{header:"类与类、类与接口、接口与接口",slug:"类与类、类与接口、接口与接口",content:""},{header:"类与类之间：继承关系，单继承，不可多继承；可以多层继承，不可循环继承",slug:"类与类之间-继承关系-单继承-不可多继承-可以多层继承-不可循环继承",content:`class Fu{ public void show(){ System.out.println("Fu show"); }
}
class Zi extends Fu{
}`},{header:"类与接口之间：实现关系，可以单一实现，也可以多实现",slug:"类与接口之间-实现关系-可以单一实现-也可以多实现",content:`interface Inter{ abstract void show();
}
interface Inter2{ abstract void eat();
}
class Demo implements Inter,Inter2{ public void show(){ System.out.println("Demo show"); } public void eat(){ System.out.println("Demo eat"); }
}`},{header:"接口与接口之间：继承关系，可以单继承，也可以多继承",slug:"接口与接口之间-继承关系-可以单继承-也可以多继承",content:`interface A{ public abstract void show();
}
interface B{ }
interface C extends A,B{ }
class Demo implements C{ public void show(){ System.out.println("Demo show"); }
}`},{header:"什么时候使用接口",slug:"什么时候使用接口",content:`abstract class Animal{ String name; public Animal(String name) { this.name = name; }; public abstract void eat(); //抽象方法 public void drink(){ System.out.println("动物都喝水"); }
}
interface Fly{ // 接口：谁用谁就继承 public abstract void fly();
}
interface Swim{ // 接口：谁用谁就继承 public abstract void swim();
}
class Dog extends Animal{ public Dog(String name) { super(name); } public void eat(){ System.out.println(name + "吃骨头"); } public void play(){ System.out.println( name + "玩球"); }
}
class Cat extends Animal implements Swim{ public void eat(){ System.out.println("吃鱼"); } public void catchMouse(){ System.out.println("抓老鼠"); } public void swim(){ System.out.println("猫本来不会游泳，继承了接口，那就会了"); }
}
class Pig extends Animal implements Fly, Swim{ public void eat(){ System.out.println("吃食"); } public void sleep(){ System.out.println("睡觉"); } public void fly(){ System.out.println("猪本来不会飞，继承了接口，那就会了"); } public void swim(){ System.out.println("猪本来不会游泳，继承了接口，那就会了"); }
} public class Test { public static void main(String[] args) { Dog dog = new Dog("旺财"); dog.eat(); // 旺财吃骨头 dog.play(); // 旺财玩球 Cat cat = new Cat(); cat.swim(); // 猫本来不会游泳，继承了接口，那就会了 Pig pig = new Pig(); pig.fly(); // 猪本来不会飞，继承了接口，那就会了 }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E7%BB%A7%E6%89%BF.html",title:"",pathLocale:"/",contents:[{header:"继承(extends)",slug:"继承-extends",content:`private、protected、构造方法不被继承、this、super等问题 类 B 继承 类 A
类 A：父类，超类，基类
类 B：子类，派生类`},{header:"继承的好处",slug:"继承的好处",content:`提高代码的复用性
让类与类之间产生继承关系，这是构成多态的前提条件`},{header:"继承的弊端",slug:"继承的弊端",content:`提高了代码的耦合性（耦合性：程序间的依赖关系） 开发原则: 高内聚，低耦合 高内聚：是指一个人的能力越强越好
低耦合：是指一个人的关系越少越好`},{header:"继承的特点",slug:"继承的特点",content:`在 java 中，类只支持单继承，不可以多继承，可以多层继承，不可以循环继承。 // 单继承
class Fu{}
class Zi extends Fu {} 子类不能继承父类中被 private 关键字所修饰的成员方法和变量。 class Fu{ private String name; int age;
}
class Zi extends Fu{ void show(){ System.out.println(age); // 可以继承 System.out.println(name); // 编译报错，因为父类中的name被私有了 }
} 子类可以继承父类中 protected 关键字修饰的成员方法，不能继承其成员变量。 class Fu{ protected String name; int age; protected void print(){ System.out.println(name); // 父类自己 }
}
class Zi extends Fu{ void show(){ System.out.println(age); // 可以继承 System.out.println(name); // 编译报错，因为父类中的name被protected保护 print(); // 可以继承 }
} 构造方法不能被继承。 class Fu{ int i = 10;
}
class Zi extends Fu{ int i = 20; public void show(){ i = 30; System.out.println(i); // 30 System.out.println(this.i); // 20 this指向调用的对象zi System.out.println(super.i); // 10 super指向继承的父类 }
}
class Demo { public static void main(String[] args) { Zi zi = new Zi(); zi.show(); }
}`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E9%87%8D%E5%86%99.html",title:"",pathLocale:"/",contents:[{header:"重写(@Override)",slug:"重写-override",content:"子类权限要大于父类、private修饰的不能重写、返回值类型可以不同的要求、静态的问题"},{header:"在子父类继承中成员方法的关系",slug:"在子父类继承中成员方法的关系",content:`// 父类成员方法与子类成员方法不同 class Fu { public void showFu(){ System.out.println("Fu show"); }
} class Zi extends Fu { public void showZi(){ System.out.println("Zi show"); }
} public class Test { public static void main(String[] args) { Zi z = new Zi(); z.showFu(); // 输出：Fu show z.showZi(); // 输出：Zi show }
}
// 父类成员方法与子类成员方法相同 class Fu { public void show(){ System.out.println("Fu show"); }
} class Zi extends Fu { public void show(){ System.out.println("Zi show"); }
} public class Test { public static void main(String[] args) { Zi z = new Zi(); z.show(); // 输出：Zi show 子类重写或者叫做覆盖 z.show(); // 输出：Zi show }
}`},{header:"重写注意事项",slug:"重写注意事项",content:`子类不能重写父类中的私有成员方法。 子类方法权限大于等于父类方法的权限。 public > protected > 默认 > private class Fu{ protected void print(){}
}
class Zi extends Fu{ public void print(){}
} 子类的方法的返回值类型可以和父类被重写方法的返回值类型不一致， 但是有一个条件，父类方法的返回值类型是子类方法返回值的父类。 class Fu{ public Person print(){}
}
class Zi extends Fu{ public Student print(){}
} 静态方法只能重写静态方法。`}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1.html",title:"",pathLocale:"/",contents:[{header:"面向对象",slug:"面向对象",content:"new一个新对象会创建一个空间、对象的指向问题"},{header:"理解面向对象和面向过程",slug:"理解面向对象和面向过程",content:`旅游: 面向过程: 自己订票, 自己订酒店, 自己订车, 自己安排行程
面向对象: 找旅行社, 旅行社安排, 旅行社负责订票, 订酒店, 订车, 安排行程 开发: 面向过程: 自己写代码, 自己写文档
面向对象: 花钱找一个程序员, 这个程序员写代码, 程序员写文档`},{header:"类和对象",slug:"类和对象",content:`类: 类是事物的属性(外在特征)和行为(具备的功能)的集合，抽象的
比如说人类 这个就是类
对象: 具体存在的, 是一个类的具体的体现
比如说小明，是具体的某一个人，是人类的具体体现`},{header:"面向对象三大特性",slug:"面向对象三大特性",content:"封装 把客观事物封装成抽象的类, 并且类可以把自己的数据和方法只让可信的类或者对象操作, 对不可信的进行信息隐藏 继承 子类继承父类的特征和行为, 使得子类对象（实例）具有父类的实例域和方法, 即子类对象（实例）可以调用这些被继承的方法 多态 多种状态 父类定义一个方法不去实现, 让继承它的子类去实现, 每一个子类有不同的表现"},{header:"练习题",slug:"练习题",content:"类与对象的基础用法 一个对象指向一个地址，创建多个就分别指向不同的地址 创建(new 一个对象)就会开辟一个新的地址 当两个对象指向同一个地址时，一个对象的属性发生更改就都跟着改了"}]},{path:"/admin/Java/Java%E5%9F%BA%E7%A1%80/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81.html",title:"",pathLocale:"/",contents:[{header:"面向对象三大特征",slug:"面向对象三大特征",content:"封装 提高了代码的安全性，把属性私有化，提供公共的访问方式 继承 提高代码的复用性，一般是将公共的属性和方法放在父类中，子类中保留其特有的内容 多态 提高代码的扩展性，父类引用或者父接口指向子类对象，不同类型的子对象对父类中相同的方法，产生了不同的执行结果，多态属于编译时行为"}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Arrays.html",title:"",pathLocale:"/",contents:[{header:"Arrays",slug:"arrays",content:"需要导包，在 java.util 包下；数组工具类(构造方法是私有的，成员方法都是静态的)"},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 void sort(int[] a)
按照升序对数组进行排序 String toString()
返回数组的字符串形式 int[] copyOf(Object[] original, int newLength)
复制数组，扩容 Arrays 扩容 与 System 扩容的区别在于一个是数组扩容，一个是 System 的内存扩容
// 扩容的案例
public static void main(String[] args) { int[] arr = {1, 2, 3}; System.out.println(Arrays.toString(arr)); // [1, 2, 3] int[] newArr = Arrays.copyOf(arr, 6); // 扩容的长度为6，System扩容写法不同 System.out.println(Arrays.toString(newArr)); // [1, 2, 3, 0, 0, 0]
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/BigDecimal.html",title:"",pathLocale:"/",contents:[{header:"BigDecimal",slug:"bigdecimal",content:"需要导包，在 java.math 包下"},{header:"常见构造方法",slug:"常见构造方法",content:`方法
作用 public BigDecimal(double val)
将 double 转换为 BigDecimal public BigDecimal(String val)
将 String 转换为 BigDecimal 注意: 如果期望结果更加准确的话，建议使用 BigDecimal(String val)的构造方法package com.wuziqi.gobang.controller;
import java.math.BigDecimal; public class DemoBigDecimal { public static void main(String[] args) { // public BigDecimal(String val) BigDecimal a = new BigDecimal("0.01"); System.out.println(a); // 0.01 BigDecimal b = new BigDecimal("1.10"); System.out.println(b); // 1.10 // public BigDecimal(double val) BigDecimal c = new BigDecimal(0.1); System.out.println(c); // 0.100000000000000005... BigDecimal d = new BigDecimal(1.0); System.out.println(d); // 1 }
}`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public BigDecimal add(另一个 BigDecimal 对象)
加法运算 public BigDecimal subtract(另一个 BigDecimal 对象)
减法运算 public BigDecimal multiply(另一个 BigDecimal 对象)
乘法运算 public BigDecimal divide(另一个 BigDecimal 对象)
除法运算 public BigDecimal divide(BigDecimal divisor,int scale,RoundingMode roundingMode)
除法运算除不尽 public BigDecimal divide(BigDecimal divisor,int scale,RoundingMode roundingMode)
divisor：另一个 BigDecimal 对象
scale：保留几位小数
roundingMode：舍入模式(ROUND_DOWN,ROUND_UP,ROUND_HALF_UP 等)
ROUND_DOWN：直接舍去(去尾)
ROUND_UP：直接进位(加头)
ROUND_HALF_UP：四舍五入 // 加法案例(加减乘除一样，这里以加法为例)
package com.wuziqi.gobang.controller;
import java.math.BigDecimal; public class DemoBigDecimal { public static void main(String[] args) { BigDecimal bd1 = new BigDecimal(0.1); BigDecimal bd2 = new BigDecimal(0.2); BigDecimal bd3 = bd1.add(bd2); System.out.println(bd3); // 0.30000... BigDecimal bd10 = new BigDecimal("0.1"); BigDecimal bd20 = new BigDecimal("0.2"); BigDecimal bd30 = bd10.add(bd20); System.out.println(bd30); // 0.3 我们想要的结果 // 使用 BigDecimal(String val)结果准确 }
}
// 除法(除不尽)
package com.wuziqi.gobang.controller;
import java.math.BigDecimal; public class DemoBigDecimal { public static void main(String[] args) { BigDecimal bd1 = new BigDecimal("10.0"); BigDecimal bd2 = new BigDecimal("3.0"); BigDecimal bd3 = bd1.divide(bd2, 2, BigDecimal.ROUND_DOWN); BigDecimal bd4 = bd1.divide(bd2, 3, BigDecimal.ROUND_UP); BigDecimal bd5 = bd1.divide(bd2, 4, BigDecimal.ROUND_HALF_DOWN); System.out.println(bd3); // 3.33 System.out.println(bd4); // 3.334 System.out.println(bd5); // 3.3333 }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Calendar.html",title:"",pathLocale:"/",contents:[{header:"Calendar",slug:"calendar",content:"需要导包，在 java.util 包下, 抽象类，使用时需要创建子对象"},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 getInstance()
获取 Calender 的子对象 int get(int field)
获取年、月、日、小时、分钟、秒等 void set(int field, int value)
设置年、月、日、小时、分钟、秒等 final Date getTime()
获取 Date 对象(将 Calendar 转成 Date 类型) abstract void add(int field, int amount)
对年、月、日等进行增将或减量 public static void main(String[] args) { Calendar c = Calendar.getInstance(); // c: Calendar子对象 // 获取年、月、日、小时、分钟、秒等 int year = c.get(Calendar.YEAR); int month = c.get(Calendar.MONTH); int day = c.get(Calendar.DAY_OF_MONTH); int hour = c.get(Calendar.HOUR_OF_DAY); int minute = c.get(Calendar.MINUTE); int second = c.get(Calendar.SECOND); System.out.println(year + "年" + month + "月" + day + "日"); System.out.println(hour + "时" + minute + "分" + second + "秒"); // 设置年、月、日、小时、分钟、秒等 c.set(Calendar.YEAR, 2020); c.set(Calendar.MONTH, 10); // 月份是从0开始的 c.set(Calendar.DAY_OF_MONTH, 1); c.set(Calendar.HOUR_OF_DAY, 12); c.set(Calendar.MINUTE, 30); c.set(Calendar.SECOND, 30); System.out.println(c.getTime()); // Sun Nov 01 12:30:30 CST 2020 // 对年、月、日等进行增将或减量 c.add(Calendar.YEAR, 1); // 正数是加 c.add(Calendar.MONTH, 1); // 月份是从0开始的 c.add(Calendar.DAY_OF_MONTH, 1); c.add(Calendar.HOUR_OF_DAY, 12); c.add(Calendar.MINUTE, 30); c.add(Calendar.SECOND, 30); System.out.println(c.getTime()); // Thu Nov 01 12:30:30 CST 2021
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Collections%E5%B7%A5%E5%85%B7%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"Collections 工具类(对 List 进行排序)",slug:"collections-工具类-对-list-进行排序",content:"工具类(构造方法私有的，成员方法静态的)"},{header:"常用的成员方法",slug:"常用的成员方法",content:`方法
作用 public static <T extends Comparable<? super T>> void sort(List<T> list)
对 List 集合进行排序(自定义类) public static <T> void sort(List<T> list, Comparator<? super T> c)
对 List 集合进行排序(不含自定义类)`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.Collections; import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator; public class DemoCollections { public static void main(String[] args) { ArrayList<String> list = new ArrayList<String>(); list.add("aaa"); list.add("dd"); list.add("c"); list.add("bbbb"); // list有序的： System.out.println(list); // [aaa, dd, c, bbbb] // 不给定规则，默认按自然排序，即按字母顺序排序 Collections.sort(list); System.out.println(list); // [aaa, bbbb, c, dd] // 如果定规则，按照规则排序：比如按照字符长度排序 Collections.sort(list, new Comparator<String>() { @Override public int compare(String o1, String o2) { return o1.length() - o2.length(); } }); System.out.println(list); // [c, dd, aaa, bbbb] /** * List中存储的是自定义类的话， * 如果想要排序需要使用Comparable接口，重写compareTo方法 * 因为List是可以重复的，所以Comparable自然排序后，不会去重 * 这也是List和Set的区别，如果是Set集合则会去重 */ ArrayList<Person> persons = new ArrayList<Person>(); persons.add(new Person("tom", 10)); persons.add(new Person("jerry", 12)); persons.add(new Person("rose", 8)); persons.add(new Person("jack", 10)); persons.add(new Person("tom", 10)); Collections.sort(persons); System.out.println(persons); // 结果： // [Person{name='rose', age=8}, Person{name='jack', age=10}, // Person{name='tom', age=10}, Person{name='tom', age=10}, // Person{name='jerry', age=12}] }
}
class Person implements Comparable<Person> { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Person{" + "name='" + name + '\\'' + ", age=" + age + '}'; } @Override public int compareTo(Person o) { int i = this.age - o.age; return i == 0 ? this.name.compareTo(o.name) : i; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Date.html",title:"",pathLocale:"/",contents:[{header:"Date",slug:"date",content:"需要导包，在 java.util 包下"},{header:"常见构造方法",slug:"常见构造方法",content:`方法
作用 public Date()
分配 Date 对象并初始化，以便它代表它被创建时的日期和时间 public Date(long date)
分配 Date 对象并初始化，以便它代表 date 参数中给出的毫秒时间值`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public long getTime()
返回自 1970 年 1 月 1 日 00:00:00 毫秒值 public void setTime (long time)
设置自 1970 年 1 月 1 日 00:00:00 毫秒时间值`},{header:"格式化时间(SimpleDateFormat)",slug:"格式化时间-simpledateformat",content:`需要导包，在 java.text 包下
Date => String
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); String dateString = dateFormat.format(date);
String => Date
SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); Date date = dateFormat.parse(dateString);`},{header:"实际应用",slug:"实际应用",content:`public static void main(String[] args) { Date date = new Date(); SimpleDateFormat dF1 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); SimpleDateFormat dF2 = new SimpleDateFormat("yyyy年MM月dd日 HH:mm:ss"); SimpleDateFormat dF3 = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss E"); String time1 = dF1.format(date); String time2 = dF2.format(date); String time3 = dF3.format(date); System.out.println(time1); // 2024-03-12 11:36:04 System.out.println(time2); // 2024年03月12日 11:36:04 System.out.println(time3); // 2024/03/12 11:36:04 星期二
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/File%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"File 类",slug:"file-类",content:`需要导包，在 java.io 下
什么是 File 类？
代表文件或者文件夹(目录)类，也就是说将文件或者文件夹，通过 File 类封装成对象。`},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public File(String pathname)
将给定的路径转换为 File 实例 public File(String parent, String child)
通过父路径和子路径创建新的 File 实例 public File(File parent, String child)
通过父路径和子路径创建新的 File 实例`},{header:"常见的成员方法",slug:"常见的成员方法",content:`创建 方法
作用 public boolean createNewFile()
创建文件 public boolean mkdir()
创建文件夹，只能创建一级 public boolean mkdirs()
创建文件夹，可以创建多级 删除 如果要删除的文件夹里边有子文件或者子文件夹，需要先删除子文件或文件夹，再删除该文件夹
通过 delete()删除时，被删除文件或者文件夹，不会进入电脑的回收站 方法
作用 public boolean delete()
删除文件或者文件夹 判断 方法
作用 public boolean exists()
判断是否存在 public boolean isDirectory()
判断是否是文件夹 public boolean isFile()
判断是否是文件 获取 方法
作用 public long length()
获取文件中的字节数 public String getName()
获取名称 public String getPath()
获取路径 public String getAbsolutePath()
获取绝对路径 public File getParentFile()
获取上级目录的 File 对象 public File[] listFiles()
获取目录中所有的子文件和子文件夹 重命名 方法
作用 public boolean renameTo(File dest)
把文件重命名为指定的文件路径，就是文件名称的修改`},{header:"递归删除文件夹 aaa",slug:"递归删除文件夹-aaa",content:`package com.wuziqi.gobang.IO; import java.io.File;
import java.io.IOException; public class DemoFile { public static void main(String[] args) throws IOException { // 递归删除 File file = new File("aaa"); delete(file); } public static void delete(File file){ File[] files = file.listFiles(); for(File f : files){ // 如果是文件夹，需要重新调用方法 if(f.isDirectory()){ delete(f); }else{ // 如果是文件，就直接删除 f.delete(); } // 最后，删除aaa这个根文件夹，没有文件了，可以直接删除 file.delete(); } };
}`},{header:"递归获取 aaa 目录下的所有.java 文件",slug:"递归获取-aaa-目录下的所有-java-文件",content:`package com.wuziqi.gobang.IO; import java.io.File; public class DemoFile { public static void main(String[] args) { // 递归获取aaa目录下的所有.java文件 File getJavas = new File("aaa"); print(getJavas); } public static void print(File file){ File[] files = file.listFiles(); for(File f : files){ // 如果是文件夹，再遍历 if(f.isDirectory()){ print(f); }else{ // 如果是文件，判断是否是java类型的文件 if(f.getName().endsWith(".java")){ System.out.println(f.getAbsolutePath()); } } } };
}`},{header:"其他方法的使用",slug:"其他方法的使用",content:`package com.wuziqi.gobang.IO; import java.io.File;
import java.io.IOException; public class DemoFile { public static void main(String[] args) throws IOException { // 文件对象 // public File(String pathname)：将给定的路径转换为 File 实例 File file1 = new File("C:\\\\mulu\\\\test.txt"); System.out.println(file1.getPath()); // public File(String parent, String child)：通过父路径和子路径创建 File实例 File file2 = new File("C:\\\\mulu\\\\subMulu", "test.txt"); System.out.println(file2.getPath()); // public File(File parent, String child)：通过父路径和子路径创建 File实例 File parentDir = new File("C:\\\\mulu\\\\subMulu"); File file3 = new File(parentDir, "test.txt"); System.out.println(file3.getPath()); // 创建 // public boolean createNewFile()：创建文件 File newFile = new File("C:\\\\mulu\\\\test.txt"); boolean isCreated = newFile.createNewFile(); System.out.println("文件是否创建成功：" + isCreated); // public boolean mkdir()：创建文件夹，只能创建一级 File folder1 = new File("C:\\\\mulu"); boolean isFolderCreated1 = folder1.mkdir(); System.out.println("文件夹是否创建成功：" + isFolderCreated1); // public boolean mkdirs()：创建文件夹，可以创建多级 File multiLevelFolder = new File("C:\\\\mulu\\\\subMulu1\\\\subMulu2"); boolean isMultiFolderCreated = multiLevelFolder.mkdirs(); System.out.println("多级文件夹是否创建成功：" + isMultiFolderCreated); // 删除 // public boolean delete()：删除文件或者文件夹 File fileToDelete = new File("C:\\\\mulu\\\\test.txt"); boolean isDeleted = fileToDelete.delete(); System.out.println("文件或文件夹是否删除成功：" + isDeleted); // 判断 // public boolean exists()：判断是否存在 File checkFile = new File("C:\\\\mulu\\\\test.txt"); boolean doesExist = checkFile.exists(); System.out.println("文件或文件夹是否存在：" + doesExist); // public boolean isDirectory() // 判断是否是文件夹 File directoryCheck = new File("C:\\\\mulu"); boolean isADirectory = directoryCheck.isDirectory(); System.out.println("是否为文件夹：" + isADirectory); // public boolean isFile()：判断是否是文件 File fileCheck = new File("C:\\\\mulu\\\\test.txt"); boolean isAFile = fileCheck.isFile(); System.out.println("是否为文件：" + isAFile); // 获取 // public long length()：获取文件中的字节数 File existingFile = new File("C:\\\\mulu\\\\test.txt"); long fileSizeInBytes = existingFile.length(); System.out.println("文件大小（字节）：" + fileSizeInBytes); // public String getName()：获取名称 File fileNameExample = new File("C:\\\\mulu\\\\test.txt"); String fileName = fileNameExample.getName(); System.out.println("文件名：" + fileName); // test.txt // public String getPath()：获取路径(传什么获取什么) File filePathExample = new File("C:\\\\mulu\\\\test.txt"); String filePath = filePathExample.getPath(); System.out.println("文件路径：" + filePath); // "C:\\mulu\\test.txt" // public String getAbsolutePath()：获取绝对路径(从盘符到文件名的整体) File absPathExample = new File("test.txt"); String absPath = absPathExample.getAbsolutePath(); System.out.println("文件绝对路径：" + absPath); // "C:\\mulu\\test.txt" // public File getParentFile()：获取上级目录的 File 对象 File parentDirExample = new File("C:\\\\mulu\\\\subMulu\\\\test.txt"); File parentDirectory = parentDirExample.getParentFile(); System.out.println("上级目录：" + parentDirectory.getPath()); // public File[] listFiles()：获取目录中所有的子文件和子文件夹 File dirToList = new File("C:\\\\mulu"); File[] contents = dirToList.listFiles(); if (contents != null) { for (File content : contents) { System.out.println(content.getName()); } } // 修改 // public boolean renameTo(File dest)： // 把文件重命名为指定的文件路径，就是文件名称的修改 File fileToRename = new File("C:\\\\mulu\\\\test.txt"); boolean isRenamed = fileToRename.renameTo(new File("C:\\\\mulu\\\\newTest.txt")); System.out.println("文件是否重命名成功：" + isRenamed); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Integer%E5%8C%85%E8%A3%85%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"Integer 包装类",slug:"integer-包装类",content:`包装类: 就是把基本数据类型包装成引用类型 基本数据类型
对应的包装类（位于 java.lang 包中） byte
Byte short
Short int
Integer long
Long float
Float double
Double char
Character boolean
Boolean`},{header:"Integer(int 类型包装类)",slug:"integer-int-类型包装类",content:""},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public Integer(int value)
创建 Integer 对象;int -> Integer public Integer(String s)
创建 Integer 对象;String 类型的数字 -> Integer // public Integer(int value):
Integer in1 = new Integer(12);
System.out.println(in1); // 12 // public Integer(String s)
Integer in2 = new Integer("12");
System.out.println(in2); // 12 // 只能是\`数字\`类型的String
Integer in3 = new Integer("abc");
System.out.println(in3); // 运行报错 // 超出Integer范围(就是int的范围)
Integer in4 = new Integer(11111111111111111); // 这是17位，int最大16位
System.out.println(in4); // 运行报错`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public int intValue()
将 Integer 类型的数字转换为 int 类型的数字 public boolean equals(Object obj)
比较两个 Integer 类型的数字是否相等 public static int parseInt(String s)
将字符串类型的数字转换为 int 类型的数字 public String toString()
将 Integer 类型的数字转换为字符串类型的数字 public static String toString(int i)
将 int 类型的数字转换为字符串类型的数字 public static Integer valueOf(int i)
将 int 类型的数字转换为 Integer 类型的数字 public static Integer valueOf(String s)
将字符串类型的数字转换为 Integer 类型的数字 // 最重要的使用方法案例：
System.out.println(Integer.parseInt("123")); // 123`},{header:"自动装箱和自动拆箱",slug:"自动装箱和自动拆箱",content:`自动装箱: int -> Integer
自动拆箱: Integer -> int Integer i = 10; // 自动装箱 => 手动装箱: Integer i = Integer.valueOf(10);
int n = i + 2; // 自动拆箱 => 手动拆箱: int n = i.intValue() + 2; Integer in = 12;
in = in + 20; // in = Integer.valueOf(in.intValue() + 20);`},{header:"基本数据类型和包装类之间的转换",slug:"基本数据类型和包装类之间的转换",content:`基本数据类型转换为包装类: 使用包装类的构造器 int num = 10;
Integer i = new Integer(num); 包装类转换为基本数据类型: 使用包装类中的方法 Integer i = new Integer(10);
int num = i.intValue(); 自动转换: 直接将包装类赋值给基本数据类型 Integer i = new Integer(10);
int num = i; 注意: 自动转换是编译器自动进行的, 不是我们手动进行的`},{header:"常见的问题",slug:"常见的问题",content:"Integer in1 = new Integer(127); Integer in2 = new Integer(127); System.out.println(in1 == in2); // false: 因为new出来的对象在内存中是不同的 Integer in3 = new Integer(128); Integer in4 = new Integer(128); System.out.println(in3 == in4); // false: 因为new出来的对象在内存中是不同的 Integer in5 = 127; Integer in6 = 127; System.out.println(in5 == in6); // true: 因为自动装箱, 会将127自动装箱成Integer对象 Integer in7 = 128; Integer in8 = 128; System.out.println(in7 == in8); // false: Integer范围: -128 - 127，范围内比较数值 System.out.println(in7.equals(in8)); // true: equals比较的是数值 Integer in9 = 126; Integer in10 = in9 + 1; Integer in11 = in9 + 1; // in11 是Integer类型；Integer对象的比较要用equals System.out.println(in10 == in11); // true System.out.println(in5 == in10); // true System.out.println(in5 == in2); // false System.out.println(in2 == in10); // false"}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Localdatetime.html",title:"",pathLocale:"/",contents:[{header:"LocalDateTime(jdk1.8 新出的日期类)",slug:"localdatetime-jdk1-8-新出的日期类",content:"写法简单，并且把 Date 和 Calendar 的用法都归纳总结了 LocalDate 表示日期，比如 2014-03-18。 LocalTime 表示时间，比如 22:30:40。 LocalDateTime 同时表示日期和时间，比如 2014-03-18T22:30:40。"},{header:"LocalDateTime 类",slug:"localdatetime-类",content:`需要导包，在 java.time 包下
没有构造方法(不能 new)`},{header:"LocalDateTime 获取当前类的方法",slug:"localdatetime-获取当前类的方法",content:`方法
作用 public static LocalDateTime now()
当前时间 public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)
获取传入时间 package com.wuziqi.gobang.controller;
import java.time.LocalDateTime; public class DemoNewDate { public static void main(String[] args) { LocalDateTime date1 = LocalDateTime.now(); System.out.println(date1); // 2024-03-13T11:29:58.939 LocalDateTime date2 = LocalDateTime.of(2022,2,22,22,22,22); System.out.println(date2); // 2022-02-22T22:22:22 }
}`},{header:"LocalDateTime 获取年月日时分秒方法",slug:"localdatetime-获取年月日时分秒方法",content:`方法
作用
方法
作用 getYear
获取年
getHour()
时 getMonthValue
获取月
getMinute()
分 getDayOfMonth
获取日
getSecond()
秒 package com.wuziqi.gobang.controller; import java.time.LocalDateTime; public class DemoNewDate { public static void main(String[] args) { LocalDateTime date = LocalDateTime.of(2022,2,22,22,22,22); System.out.println(date); // 2022-02-22T22:22:22 System.out.println(date.getYear()); // 2022 System.out.println(date.getMonthValue()); // 2 System.out.println(date.getHour()); // 22 }
}`},{header:"LocalDateTime 转换方法",slug:"localdatetime-转换方法",content:`方法
作用 LocalDate toLocalDate()
LocalDateTime 转成 LocalDate LocalTime toLocalTime()
LocalDateTime 转成 LocalTime package com.wuziqi.gobang.controller; import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime; public class DemoNewDate { public static void main(String[] args) { LocalDateTime date = LocalDateTime.of(2022,2,22,22,22,22); System.out.println(date); // 2022-02-22T22:22:22 LocalDate ld = date.toLocalDate(); System.out.println(ld); // 2022-02-22 LocalTime lt = date.toLocalTime(); System.out.println(lt); // 22:22:22 }
}`},{header:"LocalDateTime 解析和格式化方法",slug:"localdatetime-解析和格式化方法",content:`需要导包，DateTimeFormatter，在 java.time.format 包下 方法
作用 DateTimeFormatter.ofPattern("yyyy 年 MM 月 dd 日 HH:mm:ss E")
格式 String format(pattern)
格式化 LocalDateTime static LocalDateTime parse(String text, DateTimeFormatter formatter)
LocalDateTime 解析 package com.wuziqi.gobang.controller; import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter; public class DemoNewDate { public static void main(String[] args) { LocalDateTime date2 = LocalDateTime.of(2022,2,22,22,22,22); DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss E"); String ldf = date2.format(pattern); System.out.println(ldf); // 2022年02月22日 22:22:22 星期二 LocalDateTime ldt = LocalDateTime.parse(ldf, pattern); System.out.println(ldt);// 2022-02-22T22:22:22 }
}`},{header:"LocalDateTime 增量",slug:"localdatetime-增量",content:`方法
作用 LocalDateTime plusYears(long years)
增加 n 年 LocalDateTime plusXXX(long xxx)
增加 n xxx`},{header:"LocalDateTime 修改",slug:"localdatetime-修改",content:`方法
作用 LocalDateTime withYears(long years)
修改 n 年 LocalDateTime withXXX(long xxx)
修改 n xxx package com.wuziqi.gobang.controller; import java.time.LocalDateTime; public class DemoNewDate { public static void main(String[] args) { LocalDateTime date2 = LocalDateTime.of(2022,2,22,22,22,22); System.out.println(date2); // 2022-02-22T22:22:22 LocalDateTime ldj = date2.plusYears(2); System.out.println(ldj); // 2024-02-22T22:22:22 LocalDateTime ldx = date2.withYear(2022); System.out.println(ldx); // 2022-02-22T22:22:22 }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Math.html",title:"",pathLocale:"/",contents:[{header:"Math",slug:"math",content:"不需要导包，工具类(构造方法是私有的，成员方法是静态的)"},{header:"常用的成员方法",slug:"常用的成员方法",content:`方法
作用 static int abs(int a)
返回参数的绝对值 static int max(int a,int b)
返回两个参数中的较大值 static int min(int a,int b)
返回两个参数中的较小值 static double ceil(double a)
向上取整 static double floor(double a)
向下取整 static double pow(double a,double b)
返回 a 的 b 次幂 static long round(double a)
四舍五入 static double random()
0-1 之间的随机数 int num = Math.max(int a, int b); // 取较大值 double num = Math.random(); // 0-1之间的随机数`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Object%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8Api.html",title:"",pathLocale:"/",contents:[{header:"Object 类的常用 Api",slug:"object-类的常用-api",content:""},{header:"1. equals",slug:"_1-equals",content:`用来比较两个对象是否相等
如果是基本数据类型，则是比较两个数大小是否相等
如果是引用数据类型，则是比较地址值
如果想要判断两个对象的属性是否相同，需要用到 Object 的 equals 的方法进行重写 // equals方法的重写示例 package com.wuziqi.gobang.controller; public class Demo { public static void main(String[] args) { /*name可以都为"null"字符串, 可以都为null,也可以都为"",这样会相等， *但是"null" != null != "" **/ System.out.println("" == null); // "" != null，"null"是空字符串 Pig p1 = new Pig("小猪", 18); Pig p2 = new Pig("小猪", 18); Pig p3 = new Pig("小狗", 18); Dog p4 = new Dog("小狗", 18); Pig p5 = new Pig("", 18); // p5 == p6 Pig p6 = new Pig("", 18); Pig p7 = new Pig("null", 18); // p7 == p8 Pig p8 = new Pig("null", 18); Pig p9 = new Pig(null, 18); // p8 != p9 boolean a = p1.equals(p2); boolean b = p2.equals(p3); // boolean c = p3.equals(p4); System.out.println(a); // true System.out.println(b); // false // System.out.println(c); 编译报错 System.out.println(p5.equals(p6)); // true System.out.println(p7.equals(p8)); // true System.out.println(p5.equals(p7)); // false System.out.println(p8.equals(p9)); // false System.out.println(p5.equals(p9)); // false }
} class Pig extends Object { private String name; private int age; public Pig(String name, int age) { this.name = name; this.age = age; } // 这块是鼠标右键生成的equals方法重写 @Override public boolean equals(Object o) { // 判断是否指向同一个对象 if (this == o) return true; // 判断有参数为空(null)以及判断两个对象是否同一种类 if (o == null || getClass() != o.getClass()) return false; Pig pig = (Pig) o; return age == pig.age && name.equals(pig.name); } // // 这是按照思路自己重写的equals写法，用来弄清重写的意图
// @Override
// public boolean equals(Object obj){
// Pig p = (Pig) obj;
// // 限定不能为空参传入
// if (obj == null) return false;
// // 限定传入对象需要与入参对象类型一致
// if (!(obj instanceof Pig)) return false;
// // String也有一个equals方法用来判断是否相等
// return this.name.equals(p.name) && this.age == p.age;
// }
} class Dog { private String name; private int age; Dog(String name, int age) { this.name = name; this.age = age; }
}`},{header:"2. toString",slug:"_2-tostring",content:`如果不重写方法的话，获取到的是类名加上@加上对象所在的地址值
通过鼠标右键重写的方法会打印出来转成字符串形式的内容 package com.wuziqi.gobang.controller; public class Demo { public static void main(String[] args) { // 不重写toString()方法 Dog dog1 = new Dog("小明", 18, "公"); // 下边两个方法的打印结果一样， // 都是com.wuziqi.gobang.controller.Dog@23fc625e System.out.println(dog1); System.out.println(dog1.toString()); // 重写toString()方法后 Dog dog2 = new Dog("小灰", 18, "母"); System.out.println(dog2.toString()); // Dog{name='小灰', age=18, sex='母'} }
}
class Dog extends Object{ private String name; private int age; private String sex; public Dog(String name, int age, String sex) { this.name = name; this.age = age; this.sex = sex; } @Override public String toString() { return "Dog{" + "name='" + name + '\\'' + ", age=" + age + ", sex='" + sex + '\\'' + '}'; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/Random.html",title:"",pathLocale:"/",contents:[{header:"Random",slug:"random",content:"需要导包， 在 java.util 包下"},{header:"构造方法",slug:"构造方法",content:`Random() 创建一个新的随机数生成器 方法
作用 Random()
创建一个新的随机数生成器`},{header:"常用方法",slug:"常用方法",content:`方法
作用 int nextInt(int n)
返回一个伪随机数，范围在 0（包括）到 n（不包括）之间 Random r = new Random();
for(int i = 0; i < 10; i++){ int nI = r.nextInt(10); System.out.println(nI); // 输出结果可以为： 0 1 4 3 7 8 2 6 9 5
}`},{header:"获取 1-100 之间的随机数",slug:"获取-1-100-之间的随机数",content:""},{header:"Math 方法",slug:"math-方法",content:"int num = (int)(Math.random() * 100) + 1;"},{header:"Random 方法",slug:"random-方法",content:`Random r = new Random();
int num = r.nextInt(100) + 1;`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/StringBuilder.html",title:"",pathLocale:"/",contents:[{header:"StringBuilder",slug:"stringbuilder",content:`其实就是用来拼接字符串的，比 StringBuffer 多了一个 toString 方法，可以返回一个 String 对象；
StringBuilder 和 StringBuffer 非常像，除了构造和 toString 方法不同之外，其他方法都一样。 什么是 StringBuilder？ 一个可变的字符序列，String 是不可变的
字符串的缓冲区
是一个容器`},{header:"StringBuilder 容器的特点",slug:"stringbuilder-容器的特点",content:"缓冲区可以装任何的东西，但是装进去就取不出来了，而且，装进去的数据都会变成字符串。"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public StringBuilder()
构造一个不带任何字符的字符串生成器，其初始容量为 16 个字符 public StringBuilder(String str)
构造一个指定内容的字符串生成器。(初始容量: 16 + 字符串参数的长度)`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public StringBuilder append(任意类型 b)
追加 public int capacity()
返回当前容量 public StringBuilder reverse()
反转 public String toString()
此字符序列的字符串表示形式(StringBuilder => String)`},{header:"StringBuilder 和 String 转换",slug:"stringbuilder-和-string-转换",content:`String => StringBuilder
StringBuilder sb = new StringBuilder("abc");
StringBuilder => String
String str = sb.toString();`},{header:"案例",slug:"案例",content:`package com.wuziqi.gobang.controller; public class DemoStringBuilder { public static void main(String[] args) { // public StringBuilder() StringBuilder sb1 = new StringBuilder(); System.out.println(sb1); // 16位 // public StringBuilder(String str) StringBuilder sb2 = new StringBuilder("abc"); System.out.println(sb2); // "abc" StringBuilder sb3 = new StringBuilder("我这是一个超过了16位的一个特别长的字符"); System.out.println(sb3); // 默认16位，超出部分自动扩容 // public StringBuilder append(任意类型 b) StringBuilder sb = new StringBuilder(); sb.append("abc"); sb.append(true); sb.append(123.456); sb.append('a'); Pig pig= new Pig(); sb.append(pig); sb.append(123); System.out.println(sb); // 输出结果: // abctrue123.456acom.wuziqi.gobang.controller.Pig@23fc625e123 // public int capacity() int length = sb.capacity(); System.out.println("当前容量:" + length); // 当前容量:114 // public StringBuilder reverse() StringBuilder sbR = sb.reverse(); System.out.println(sbR); // 输出反转后结果: // 321e526cf32@giP.rellortnoc.gnabog.iqizuw.moca654.321eurtcba }
}
class Pig{ Pig(){}
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/String%E5%AD%97%E7%AC%A6%E4%B8%B2.html",title:"",pathLocale:"/",contents:[{header:"String 字符串",slug:"string-字符串",content:`什么是 String？ String 类用于表示和操作字符串。
String 类是 final 类型的，因此不能被继承。
字符串是常量，一旦被赋值，就不能被更改(长度不可以改变的字符序列)。 String 是一个引用数据类型
是 jdk 给我们提供好的一个现成的 String 类
"abc"既是一个字符串常量，又是一个字符串的对象(实例)`},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 String()
初始化一个新创建的 String 对象，使其表示一个空字符序列。 public String(byte[] bytes)
将字节数组转成字符串 public String(byte[] bytes,int offset,int length)
将字节数的一部分组转成字符串 public String(char[] value)
分配一个新的 String，将字符数组转成字符串 public String(char[] value,int offset,int count)
将字符数组的一部分转成字符串 public String(String original)
初始化一个新的 String 对象，使其表示一个与参数相同的字符序列；换句话说，新创建的字符串是该参数字符串的副本。 String s = "abc" // 需要注意长度的问题
public static void main(String[] args) { // public String(byte[] bytes) byte[] bys1 = {97, 98, 99, 100, 101 }; String str1 = new String(bys1); System.out.println(str1); // 输出: abcde // public String(byte[] bytes,int offset,int length) byte[] bys2 = {97, 98, 99, 100, 101 }; String str2 = new String(bys2, 2,3); System.out.println(str2); // 输出: cde // 报错 java.lang.StringIndexOutOfBoundsException: String index out of range: 5 byte[] bysError = {97, 98, 99 }; String strError = new String(bysError, 2,3); System.out.println(strError); // 报错 // public String(char[] value) char[] chs1 = {'a', 'b', 'c', 'd', 'e'}; String str3 = new String(chs1); System.out.println(str3); // 输出: abcde // public String(char[] value,int offset,int count) char[] chs2 = {'a', 'b', 'c', 'd', 'e'}; String str4 = new String(chs2, 0, 4); System.out.println(str4); // 输出: abcd
}`},{header:"常见的问题",slug:"常见的问题",content:`通过 new 出来的 String 对象和直接赋值出来的 String 对象有什么区别？ new 出来的，在内存中有两个对象；new 出来的字符串对象是存放在堆中的。
直接赋值的对象在内存中只有一个对象；字符串是存在字符串常量池中的。 String s1 = "abc";
String s2 = "abc";
String s3 = new String("abc");
System.out.println(s1 == s2); // true
System.out.println(s1 == s3); // false
System.out.println(s2 == s3); // false String s1 = "abc";
String s2 = "ab";
String s3 = s2 + "c"; // 相当于s2 的副本再去加c，副本不是s2
System.out.println(s1 == s2); // false
System.out.println(s1 == s3); // false 常量池是"ab "+ "c"；不是s2 + "c"
System.out.println(s2 == s3); // false String s1 = "abc";
String s2 = "ab" + "c";
System.out.println(s1 == s2); // true`},{header:"成员方法",slug:"成员方法",content:`方法
作用 public char charAt(int index)
获取指定索引对应的字符 public int compareTo(String anotherString)
按字典顺序比较两个字符串 public String concat(String str)
字符串拼接 public String toLowerCase()
字符都转换为小写 public String toUpperCase
字符都转换为大写 public boolean equals(Object anObject)
比较两个字符串的内容是否一致 public boolean equalsIgnoreCase(String anotherString)
比较两个字符串的内容是否一致(不区分大小写) public int lastIndexOf(int ch)
返回指定字符在此字符串中最后一次出现处的索引，找不到-1 public boolean isEmpty()
是否为空串 public int length()
返回此字符串的长度 public boolean startsWith(String prefix)
测试此字符串是否以指定的前缀开始 public boolean endsWith(String suffix)
测试此字符串是否以指定的后缀结束 public String replace(char oldChar,char newChar)
替换字符串，返回一个新的字符串 public byte[] getBytes()
将字符串转换成字节数组 public char[] toCharArray()
将此字符串转换为一个新的字符数组 public String trim()
去除空格，返回字符串的副本 public String substring(int beginIndex)
截取，从指定的索引到结尾 public String substring(int beginIndex,int endIndex)
截取，从指定的索引开始到指定的索引结束(包头不包尾) public String[] split(String regex)
根据给定正则表达式的匹配拆分此字符串 public String replace(String target,String replacement)
替换子字符串`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/System.html",title:"",pathLocale:"/",contents:[{header:"System",slug:"system",content:"系统类，不用导包，当然也不能实例化"},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 static void exit(int status)
退出 JVM 虚拟机 一般是 0 static long currentTimeMillis()
获取当前系统日期时间毫秒值 static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
复制数组(底层用来扩容数组) static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
src：原数组
srcPos：原数组的起始位置
dest：新数组
destPos：新数组的起始位置
length：复制的个数 // 扩容的案例
public class SystemDemo { public static void main(String[] args) { int[] src = {1, 2, 3}; int[] dest = new int[5]; // 5：新数组的长度，也是扩容后的长度 System.arraycopy(src, 0, dest, 0, src.length); for (int i = 0; i < dest.length; i++) { System.out.print(dest[i] + " "); // 输出结果：1 2 3 0 0, 后面的两个0是扩容的结果 } }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/UUID.html",title:"",pathLocale:"/",contents:[{header:"UUID",slug:"uuid",content:`需要导包，在 java.util 包下
一般不用他的构造`},{header:"常见成员方法",slug:"常见成员方法",content:`方法
作用 static UUID randomUUID()
随机数序列 String toString()
转成字符串类型 String uuid = UUID.randomUUID().toString();
System.out.println(uuid);
// 输出结果带-：dcf611f4-80c8-4610-ae94-1df5e9694af9
uuid = uuid.replaceAll("-", "");
System.out.println(uuid);
// 输出结果不带-：dcf611f480c84610ae941df5e9694af9`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0.html",title:"",pathLocale:"/",contents:[{header:"可变参数",slug:"可变参数",content:`什么是可变参数？
比如求两个数的和，可以知道是两个参数；求三个数的和，可以知道是三个参数；求 N(未知)个数的和，参数就是可变参数。`},{header:"可变参数的格式",slug:"可变参数的格式",content:`修饰符返 回值类型 方法名(数据类型... 变量名){
执行语句
return 返回值;
}`},{header:"可变参数的本质",slug:"可变参数的本质",content:"可变参数的本质其实就是数组容器。"},{header:"注意事项",slug:"注意事项",content:`当一个方法中，有多个参数时，并且其中有一个参数是可变参数，那可变参数必须放在最后。
package com.wuziqi.gobang.IO; import java.util.Arrays; public class DemoKbcs { public static void main(String[] args) { int total = getNum(1,2,3); // 可变参数传参求值 // int total = getNum({1,2,3}); // 数组传参求值 System.out.println(total); // 6 getLing(4, 16, 12,13,14); } // 可变参数 public static int getNum(int...i){ // int[] i = {1,2,3} <=> int...3 System.out.println(i); // [1,2,3] System.out.println(i.length); // 3 int sum = 0; for (int j : i) { sum += j; } return sum; } // 参数都是一样的，不是重载，下边放开会爆红 // 数组和可变参数的形参格式不一样 // public static int getNum(int[] i){ // System.out.println(i); // [1,2,3] // System.out.println(i.length); // 3 // int sum = 0; // for (int j : i) { // sum += j; // } // return sum; // } public static void getLing(int i, int j, int...k){ // getLing(4, 16, 12, 13, 14); System.out.println(i); // 4 System.out.println(j); // 16 // 可变参数放最后，int...k其实是12, 13, 14 System.out.println(k); // [I@3f99bd52 System.out.println(k.length); // 3 System.out.println(Arrays.toString(k)); // [12, 13, 14] }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%BC%82%E5%B8%B8.html",title:"",pathLocale:"/",contents:[{header:"异常",slug:"异常",content:`需要导包，在 java.lang 下
异常的体系结构?`},{header:"处理异常",slug:"处理异常",content:`主要针对编译时期异常(非 RuntimeException，即 Exception)的处理，就是明明代码和格式都没问题，
但是编译时还是有异常警告 捕获：一般都不用写，可以快速生成
try { // 出现红线的代码
} catch(异常类名 对象名){ // 处理方案
} finally { // 释放资源 // 无论是否出现异常，都会执行
}
抛：throws 被动抛出：throws 格式：throws 异常类名
写在什么位置：方法声明上
抛的是编译时期(Exception)异常，哪里调用跑哪里，调用方继续处理
抛的是运行时期(RuntimeException)异常，哪里调用抛哪里，调用方不需处理
在子父类中，如果父类没有抛，子类重写方法也不能抛，而且，就算父类抛异常了，
子类抛的异常的类也只能是父类异常的子类或者本身 主动抛出：throw 格式：throw 异常对象
写在什么位置：方法体中
抛的是编译时期(Exception)异常，哪里调用跑哪里，调用方不需处理
抛的是运行时期(RuntimeException)异常，哪里调用跑哪里，调用方不需处理 自定义异常类：需要去继承你想继承的异常(Exception、RuntimeException)
// 捕获一(多个ctach)
package com.wuziqi.gobang.controller; import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date; public class DemoYiChang { public static void main(String[] args) { try { SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); String s1 = "2024-02-13"; // 符合格式走try String s2 = "2024/02/13"; // 不符合格式，出现异常，走catch Date date1 = sdf.parse(s1); // 不处理异常时，parse会有红线 System.out.println(date1); // Tue Feb 13 00:00:00 CST 2024 /** * 1/0会出现异常 * 出现异常就终止，不再往下执行 * 同时底层创建对象，new ArithmeticException() */ System.out.println(1/0); /** * 上一步已经异常，所以不会走到这一步了 * 如果走到这一步，出现异常，底层创建对象，new ParseException() */ System.out.println(sdf.parse(s2)); }catch (ParseException e) { /** * ParseException e：形参 * 捕获的异常类型，可以根据报错后的提示来添加 * 实参：ParseException e = new ParseException() */ System.out.println("捕获了s2的异常为" + e); }catch(ArithmeticException e){ System.out.println("异常可以连续捕获!"); } /** * 与异常无关，外部逻辑，必然会执行 */ System.out.println("这块必定会执行!"); }
}
// 常用
// 捕获二(利用多态，形参为父类，实参为子类)
try { String s = "2024/02/13"; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); System.out.println(1/0); System.out.println(sdf.parse(s));
}catch(Exception e){// Exception e = new 异常对象(): 多态的妙用(Fu fu = new Zi()) System.out.println("异常类是父类，传入父类当然就不用管是哪种异常对象了");
}
System.out.println("这块必定会执行!");
// 抛(被动抛)
package com.wuziqi.gobang.controller; import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date; public class DemoYiChang { /** * 被动接收异常方可以捕获也可以继续抛出 main方法调用了aaa方法，aaa方法中抛出了异常，main方法捕获了异常 异常一旦抛出，就会执行catch代码块 */ public static void main(String[] args) { System.out.println("这块必定会执行!"); try { aaa(); // 调用 } catch (ParseException e) { e.printStackTrace(); } } public static void aaa() throws ParseException { // 被动抛出去 bbb(); // 调用 } public static void bbb() throws ParseException { // 被动抛出去 String s = "2024/02/13"; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date date = sdf.parse(s); System.out.println(date); }
}
// 抛(主动抛，编译时期异常)
package com.wuziqi.gobang.controller; public class DemoYiChang { public static void main(String[] args) { try { eat("苹果"); } catch (Exception e) { e.printStackTrace(); } } public static void eat(String food) throws Exception { if (food.startsWith("肉")){ System.out.println("我喜欢吃肉"); }else{ // 主动抛出异常 Exception e = new Exception("我只喜欢吃肉，没有肉就异常了!"); throw e; // throw new Exception("我只喜欢吃肉，没有肉就异常了!"); } }
}
// 抛(主动抛，运行时期异常)
package com.wuziqi.gobang.controller; public class DemoYiChang { public static void main(String[] args) { Person p = new Person(); p.eat("大白菜"); }
}
class Person{ public void eat(String food){ if(food.endsWith("肉")){ System.out.println("我喜欢吃"+ food); }else{ throw new RuntimeException("我只喜欢吃肉，没有肉会异常啊！"); } }
}
// 自定义异常类(运行时期异常)
package com.wuziqi.gobang.controller; public class DemoYiChang { public static void main(String[] args) { Person p = new Person(); p.eat("大白菜"); }
}
class Person{ public void eat(String food){ if(food.endsWith("肉")){ System.out.println("我喜欢吃"+ food); }else{ throw new NotEatMeetException("我只喜欢吃肉，没有肉会异常啊！"); } }
}
class NotEatMeetException extends RuntimeException{ public NotEatMeetException(){} public NotEatMeetException(String message){ super(message); }
}`},{header:"案例(RuntimeException 处理异常链)",slug:"案例-runtimeexception-处理异常链",content:`/** * 1.将编译时期异常转化为运行时期异常 * 2.使用 RuntimeException 处理异常链，不用挨个抛或者捕获
*/
package com.wuziqi.gobang.controller; public class DemoYiChang { public static void main(String[] args) { aaa(); } public static void aaa() { bbb(); } public static void bbb() { ccc(); } public static void ccc() { try{ String s = "2024/02/13"; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); Date date = sdf.parse(s); System.out.println(date); }catch(Exception e){ // 编译时期异常 throw new RuntimeException(); // 运行时期异常 } }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E6%B3%9B%E5%9E%8B.html",title:"",pathLocale:"/",contents:[{header:"泛型",slug:"泛型",content:`什么是泛型？
有泛型的地方就要指定参数类型了，不指定默认就是 Object 类。
泛型的定义格式？ <E>
<E,M> 泛型的作用？ 避免了强制类型转换 限制了集合中元素的数据类型`},{header:"泛型的基本使用",slug:"泛型的基本使用",content:`package com.wuziqi.gobang.controller; import java.util.ArrayList;
import java.util.Iterator; public class DemoFx { public static void main(String[] args) { // 限定为String类型 ArrayList<String> al = new ArrayList<String>(); // ArrayList al = new ArrayList(); al.add("1"); al.add("2"); al.add("3"); // 如果是String类型，这里会编译报错；取消泛型则可以添加4了 // al.add(4); /* 如果不限制类型，foreach要用Object类型 for (Object al1 : al){ System.out.println(al1); } **/ for (String al1 : al){ System.out.println(al1); // 1 2 3 } /* 不限制类型写法 Iterator al1 = al.iterator(); while (al1.hasNext()) { System.out.println(al1.next()); }**/ Iterator<String> al1 = al.iterator(); while (al1.hasNext()) { System.out.println(al1.next()); // 1 2 3 } }
}`},{header:"泛型的注意事项",slug:"泛型的注意事项",content:`泛型里泛型写引用类型，写基本类型会报错 前面的<>和后面的<>要匹配 在 jdk 新特性中，后面的<>可以省略不写或不添 ArrayList<String> al = new ArrayList<String>()
ArrayList<String> al = new ArrayList<>()
ArrayList<String> al = new ArrayList()`},{header:"自定义泛型",slug:"自定义泛型",content:""},{header:"自定义泛型类",slug:"自定义泛型类",content:`package com.wuziqi.gobang.controller; import java.util.ArrayList;
import java.util.Iterator; public class DemoFx { public static void main(String[] args) { Ppt<String> p1 = new Ppt<String>(); p1.print("aaa"); // p1.print(1); // 加上泛型会编译报错 }
} // 自定义泛型类
class Ppt<E>{ public void print(E e){ System.out.println(e); }
} // 常规类写法
//class Ppt{
// public void print(Object o){
// System.out.println(o);
// }
//}`},{header:"自定义泛型方法",slug:"自定义泛型方法",content:`package com.wuziqi.gobang.controller; import java.util.ArrayList;
import java.util.Iterator; public class DemoFx { public static void main(String[] args) { Fxff f1 = new Fxff(); f1.print("aaa"); f1.print(111); }
}
// 自定义泛型方法
class Fxff{ public <T> void print(T t){ System.out.println(t); }
} // 常规方法写法
//class Fxff{
// public void print(Object o){
// System.out.println(o);
// }
//}`},{header:"自定义泛型接口",slug:"自定义泛型接口",content:`package com.wuziqi.gobang.controller; import java.util.ArrayList;
import java.util.Iterator; public class DemoFx { public static void main(String[] args) { Fu<String> fu = new Zi<String>(); fu.print("aaa"); // fu.print(111); // 加上泛型会编译报错 }
}
// 自定义泛型接口
interface Fu<T>{ public abstract void print(T t);
}
class Zi<E> implements Fu<E>{ public void print(E e){ System.out.println(e); }
}`},{header:"泛型的通配符",slug:"泛型的通配符",content:`// ?
List<?> al01 = new ArrayList<String>();
List<?> al02 = new ArrayList<Integer>();
List<?> al03 = new ArrayList<Number>(); // ? extends E ：泛型上限
List<? extends Number> al001 = new ArrayList<Number>();
List<? extends Number> al002 = new ArrayList<Integer>();
List<? extends Number> al003 = new ArrayList<Float>();
List<? extends Number> al004 = new ArrayList<String>(); // 编译报错
List<? extends Number> al005 = new ArrayList<Object>(); // 上限Number，编译报错 // ? super T ：泛型下限
List<? super Number> al006 = new ArrayList<Number>();
List<? super Number> al007 = new ArrayList<Object>();
List<? super Number> al008 = new ArrayList<Float>(); // 下限Number，编译报错
List<? super Number> al009 = new ArrayList<String>();// 编译报错`},{header:"泛型综合",slug:"泛型综合",content:`package com.wuziqi.gobang.controller; import com.sun.org.apache.xerces.internal.xs.datatypes.ObjectList; import java.util.ArrayList;
import java.util.Iterator;
import java.util.List; public class DemoFx { public static void main(String[] args) { ArrayList<String> al = new ArrayList<String>(); // ArrayList al = new ArrayList(); al.add("1"); al.add("2"); al.add("3"); // al.add(4); /* for (Object al1 : al){ System.out.println(al1); } **/ for (String al1 : al){ System.out.println(al1); // 1 2 3 } /* Iterator al1 = al.iterator(); while (al1.hasNext()) { System.out.println(al1.next()); }**/ Iterator<String> al1 = al.iterator(); while (al1.hasNext()) { System.out.println(al1.next()); // 1 2 3 } Ppt<String> p1 = new Ppt<String>(); p1.print("aaa"); // p1.print(1); // 加上泛型会编译报错 Fxff f1 = new Fxff(); f1.print("aaa"); f1.print(111); Fu<String> fu = new Zi<String>(); fu.print("aaa"); // fu.print(111); // 加上泛型会编译报错 // 通配符 // ? List<?> al01 = new ArrayList<String>(); List<?> al02 = new ArrayList<Integer>(); List<?> al03 = new ArrayList<Number>(); // 通配符 // ? extends E ：泛型上限 List<? extends Number> al001 = new ArrayList<Number>(); List<? extends Number> al002 = new ArrayList<Integer>(); List<? extends Number> al003 = new ArrayList<Float>(); // List<? extends Number> al004 = new ArrayList<String>(); // 编译报错 // List<? extends Number> al005 = new ArrayList<Object>(); // 上限Number // 通配符 // ? super T ：泛型下限 List<? super Number> al006 = new ArrayList<Number>(); List<? super Number> al007 = new ArrayList<Object>(); // List<? super Number> al008 = new ArrayList<Float>(); // 下限Number // List<? super Number> al009 = new ArrayList<String>();// 编译报错 ArrayList<Number> al0 = new ArrayList<Number>(); ListTool.print(al0); }
} // 自定义泛型类
class Ppt<E>{ public void print(E e){ System.out.println(e); }
} // 常规类写法
//class Ppt{
// public void print(Object o){
// System.out.println(o);
// }
//} // 自定义泛型方法
class Fxff{ public <T> void print(T t){ System.out.println(t); }
} // 常规方法写法
//class Fxff{
// public void print(Object o){
// System.out.println(o);
// }
//} // 自定义泛型接口
interface Fu<T>{ public abstract void print(T t);
}
class Zi<E> implements Fu<E>{ public void print(E e){ System.out.println(e); }
} class ListTool{ // List<? extends Number> = al0 = new ArrayList<Number>; public static void print(List<? extends Number> l){ System.out.println(l); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E7%BC%96%E7%A0%81%E5%92%8C%E8%A7%A3%E7%A0%81.html",title:"",pathLocale:"/",contents:[{header:"编码和解码",slug:"编码和解码",content:""},{header:"编码表",slug:"编码表",content:`ASCII：最基本表，主要针对数字、英文、少数标点符号
GBK：国标，21003 个汉字，其中包括 ASCII，一个中文占 2 个字节
Unicode：国际标准，包含全世界所有文字，每个文字都对应一个唯一的编号，其中 UTF-8 最常用
UTF-8: 使用 1-4 个字节来表示一个字符，其中一个中文占 3 个字节`},{header:"编码",slug:"编码",content:`编码是将字符串转换为字节的过程。 方法
作用 public byte[] getBytes()
根据平台的默认编码，将字符串转成字节数组 public byte[] getBytes(String charsetName)
根据指定的字符集编码，将字符串转成字节数组`},{header:"解码",slug:"解码",content:`解码是将字节转换为字符串的过程。 方法
作用 public String(byte[] bytes)
根据平台的默认编码，将字节数组转成字符串 public String(byte[] bytes, String charsetName)
根据指定的字符集编码，将字节数组转成字符串`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang; import java.util.Arrays; public class EncodeAndDecode { public static void main(String[] args) throws Exception { // 编码 // public byte[] getBytes() /* *byte[] bys1 = "约吗？".getBytes(); *System.out.println(Arrays.toString(bys1)); */ String s1 = "约吗？"; byte[] bys1 = s1.getBytes(); System.out.println(Arrays.toString(bys1)); // public byte[] getBytes(String charsetName) String s2 = "约吗？"; byte[] bys2 = s2.getBytes("UTF-8"); System.out.println(Arrays.toString(bys2)); // 解码 // public String(byte[] bytes) byte[] bys3 = { -25, -70, -90, -27, -112, -105, -17, -68, -97 }; String s3 = new String(bys3); System.out.println(s3); // public String(byte[] bytes, String charsetName) byte[] bys4 = { -25, -70, -90, -27, -112, -105, -17, -68, -97 }; String s4 = new String(bys4, "gbk"); System.out.println(s4); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E8%A3%85%E9%A5%B0%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",title:"",pathLocale:"/",contents:[{header:"装饰设计模式",slug:"装饰设计模式",content:`对已有的方法或功能进行增强的方式 继承 class Demo{ public static void main(String[] args) { // A a = new A(); // B b = new B(); Tools.play(new A()); // 打篮球 Tools.play(new B()); // 打篮球、打排球、踢足球 }
}
class A{ public void play(){ System.out.println("打篮球"); }
}
class B extends A{ @Override public void play(){ super.play(); // 继承方法 System.out.println("打排球"); // 增强的功能 System.out.println("踢足球"); // 增强的功能 }
}
class Tools{ public static void play(A a){ a.play(); }
} 装饰设计模式 package com.wuziqi.gobang.Decorate; public class zhuangshishejimoshi { public static void main(String[] args) { FileInputStream fis = new FileInputStream("a.txt"); /* int by = fis.read(); System.out.println(by); byte[] bys = new byte[1024]; int len = fis.read(bys); System.out.println(len); System.out.println(new String(bys, 0, len)); */ /* * BufferedInputStream(InputStream is) * 正常来说需要传递InputStream类型参数，但它是抽象类 * 因此只能传递他的儿子，即FileInputStream */ BufferedInputStream bis = new BufferedInputStream(fis); System.out.println(bis); int by = bis.read(); // 调用的增强方法 System.out.println(by); byte[] bys = new byte[1024]; int len = bis.read(bys); // 调用的增强方法 System.out.println(len); System.out.println(new String(bys, 0, len)); }
}
abstract class InputStream{ public abstract int read(); public abstract int read(byte[] bys); public abstract void close();
}
class FileInputStream extends InputStream{ public FileInputStream(String path){ System.out.println("FileInputStream"); } @Override public int read() { // XXX：正常处理代码 return 0; } @Override public int read(byte[] bys) { // XXX：正常处理代码 return 0; } @Override public void close() { // XXX：正常处理代码 }
} class BufferedInputStream extends InputStream{ private InputStream is; // 变量对象 /* * InputStream is = new FileInputStream("a.txt"); * Fu fu = new Zi(); */ public BufferedInputStream(InputStream is){ this.is = is; // 初始化，给变量赋值，赋值为形参中的is } @Override public int read() { // XXX000：增强处理的代码 return 0; } @Override public int read(byte[] bys) { // XXX000：增强处理的代码 return 0; } @Override public void close() { // 没有被增强的方法调用被包装的对象的方法 is.close(); }
} 动态代理设计模式 适配器设计模式 外观设计模式 桥接设计模式 组合设计模式 享元设计模式 策略设计模式 模板方法设计模式 职责链设计模式 命令设计模式 状态设计模式`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E9%80%92%E5%BD%92.html",title:"",pathLocale:"/",contents:[{header:"递归",slug:"递归",content:`什么是递归？
一个方法的的内部又调用了这个方法本身，这就是递归。`},{header:"递归的注意事项",slug:"递归的注意事项",content:`递归的次数不能太多，否则会造成内存泄露，即内存溢出异常。 递归必须要有结束条件，否则死循环还会内存溢出。 package com.wuziqi.gobang.IO; public class DemoDiGui { public static void main(String[] args) { // 求5的阶乘 int num = getJieCheng(5); System.out.println(num);// 120 // i不能太大，太大超出返回值int的范围，因为是int，所以会返回0 int num2 = getJieCheng(100); System.out.println(num2);// 0 // 求一个未知数N的阶乘 int num3 = getJieCheng2(4); System.out.println(num3);// 24 // 1 1 2 3 5 8，根据规律，写出方法求第N个数是什么 int num4 = getSum(4); System.out.println(num4);// 3 } public static int getJieCheng(int i){ if(i == 1) return 1; return i*getJieCheng(i-1); } public static int getJieCheng2(int n){ if(n == 1) return 1; return n*getJieCheng2(n-1); } public static int getSum(int n){ if(n == 1 || n == 2) return 1; return getSum(n-2 ) + getSum(n-1); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E9%9B%86%E5%90%88.html",title:"",pathLocale:"/",contents:[{header:"集合",slug:"集合",content:`什么是集合？
集合是一个容器，由一组无序且唯一（即不能重复）的项组成的。`},{header:"特点",slug:"特点",content:"长度是可以变化的 集合容器只能存储引用数据类型(如果装载的是基本数据类型，则底层会默认调用其包装类的方法) 一个集合容器中，可以存储不同引用数据类型的数据"},{header:"集合与数组的区别",slug:"集合与数组的区别",content:"集合长度可变，数组一旦初始化长度就固定了 集合只能存储引用数据类型，数组可以存储任意数据类型 集合中存储的数据类型可以不同，数组中存储的数据类型必须相同 Collection 单列集合： Map 双列集合："}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E9%9B%86%E5%90%88%E6%80%BB%E7%BB%93.html",title:"",pathLocale:"/",contents:[{header:"集合总结",slug:"集合总结",content:""},{header:"集合的特点",slug:"集合的特点",content:`单列集合： 接口名
类名
特性
查询
增删
底层 List
-
有序，有索引，可重复
-
-
- List
ArrayList
同上
快
慢
数组 List
LinkedList
同上
慢
快
链表 List
Vector
同上
慢
慢
数组 Set
-
无序，无索引，不可重复
-
-
- Set
HashSet
同上，但是注意去重和 hashCode
快
慢
哈希表 Set
LinkedHashSet
有序
快
慢
链表和哈希表 Set
TreeSet
同上，但是可排序
慢
快
红黑树 双列集合： 接口名
类名
特性
查询
增删
底层
键值 Map
-
无序，无索引，键不可重复，值可重复
-
-
-
- Map
HashMap
同上
快
慢
哈希表
键和值都可为 null Map
TreeMap
同上，但是可排序
慢
快
红黑树
不可为 null Map
LinkedHashMap
同上，但是有序
快
慢
链表和哈希表
不可为 null Map
HashTable
同上
慢
慢
哈希表
不可为 null Map
Properties
同上
快
慢
数组和链表
可为 null，键值都是 String 类型`},{header:"集合 Tree 结构排序",slug:"集合-tree-结构排序",content:"自然排序：元素需要实现 Comparable 接口，重写 compareTo 方法 比较器：元素需要实现 Comparator 接口，重写 compare 方法"},{header:"集合 List 结构排序",slug:"集合-list-结构排序",content:"利用 Collections 工具类的 sort 方法进行排序"},{header:"集合的遍历",slug:"集合的遍历",content:"单列集合： 转数组循环遍历 迭代器遍历 增强 for 循环遍历(for each) 普通的 for 循环遍历(利用索引) 双列集合： keySet()键找值遍历 entrySet()键值对遍历"},{header:"集合的常用方法",slug:"集合的常用方法",content:`单列集合： add()：添加元素
remove()：删除元素
size()：获取元素个数
isEmpty()：判断是否为空
contains()：判断是否包含某个元素
clear()：清空集合
addAll()：添加多个元素
removeAll()：删除多个元素
retainAll()：保留多个元素
containsAll()：判断是否包含多个元素
equals()：判断是否相等
hashCode()：获取哈希码
toArray()：转换为数组
subList()：获取子集合
iterator()：获取迭代器
listIterator()：获取列表迭代器
spliterator()：获取集合的拆分器
stream()：获取流
parallelStream()：获取并行流
forEach()：遍历集合
forEachOrdered()：有序遍历集合
toString()：转换为字符串
removeIf()：删除满足条件的元素
replaceAll()：替换所有元素
replaceAll()：替换所有元素
sort()：排序
parallel()：并行处理
stream()：流式处理
parallelStream()：并行流式处理 双列集合： put()：添加元素
remove()：删除元素
size()：获取元素个数
isEmpty()：判断是否为空
containsKey()：判断是否包含某个键
containsValue()：判断是否包含某个值
clear()：清空集合
putAll()：添加多个元素
removeAll()：删除多个元素
retainAll()：保留多个元素
containsAll()：判断是否包含多个键或值
equals()：判断是否相等
hashCode()：获取哈希码
toArray()：转换为数组
keySet()：获取所有键的集合
values()：获取所有值的集合
entrySet()：获取所有键值对的集合
iterator()：获取迭代器
listIterator()：获取列表迭代器
spliterator()：获取集合的拆分器
stream()：获取流
parallelStream()：获取并行流
forEach()：遍历集合
forEachOrdered()：有序遍历集合
toString()：转换为字符串
removeIf()：删除满足条件的元素
replaceAll()：替换所有元素
replaceAll()：替换所有元素
sort()：排序
parallel()：并行处理
stream()：流式处理
parallelStream()：并行流式处理`},{header:"集合的使用",slug:"集合的使用",content:`package com.wuziqi.gobang.Map; import java.util.*; public class DemoClassStudent { /** * 定义一个学生类， * 属性：姓名（String name）、班级班号（String no）、成绩（double score） * 将n个学生对象存入List集合，并统计每个班级的总分和平均分 * 思想：采用面向对象的思想 * 不推荐使用Map<String,List<Student>>操作不方便 * 推荐使用Map<String,ClassRoom> */ public static void main(String[] args) { Map<String, ClassRoom> map = new TreeMap<String, ClassRoom>(); List<Stud> students1 = new ArrayList<Stud>(); students1.add(new Stud("小张",100)); students1.add(new Stud("小李",33)); students1.add(new Stud("小王",33)); students1.add(new Stud("小王",33)); List<Stud> students2 = new ArrayList<Stud>(); students2.add(new Stud("小亮",50)); students2.add(new Stud("小萌",38)); map.put("1班", new ClassRoom(0.0,0.0, students1)); map.put("2班", new ClassRoom(0.0,0.0, students2)); System.out.println(map); // 结果： // {1班=ClassRoom{total=199.0, pjNum=49.75, // students=[Stud{name='小张', score=100.0}, Stud{name='小李', score=33.0}, // Stud{name='小王', score=33.0}, Stud{name='小王', score=33.0}]}, // 2班=ClassRoom{total=88.0, pjNum=44.0, // students=[Stud{name='小亮', score=50.0},Stud{name='小萌', score=38.0}]}} }
}
class ClassRoom implements Comparable<ClassRoom>{ private Double total; private Double pjNum; private List students; private void setTotal(List students){ this.total = total; } private void setPjNum(List students){ this.pjNum = pjNum; } public ClassRoom(Double total, Double pjNum, List students) { this.students = students; this.total = total; this.pjNum = pjNum; for (Object o : students){ Stud s = (Stud)o; this.total += s.score; } this.pjNum = getTotal()/ students.size(); } public Double getTotal() { return total; } public void setTotal(Double total) { this.total = total; } public Double getPjNum() { return pjNum; } public void setPjNum(Double pjNum) { this.pjNum = pjNum; } public List getStudents() { return students; } public void setStudents(List students) { this.students = students; } @Override public String toString() { return "ClassRoom{" + "total=" + total + ", pjNum=" + pjNum + ", students=" + students + '}'; } @Override public int compareTo(ClassRoom o) { return this.getPjNum().compareTo(o.getPjNum()); }
}
class Stud{ private String name; double score; public Stud(String name, double score) { this.name = name; this.score = score; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getScore() { return score; } public void setScore(double score) { this.score = score; } @Override public String toString() { return "Stud{" + "name='" + name + '\\'' + ", score=" + score + '}'; }
}`}]},{path:"/web/React/%E6%8A%80%E6%9C%AF/react%E6%8A%80%E6%9C%AF%E7%82%B9.html",title:"",pathLocale:"/",contents:[{header:"React 技术点",slug:"react-技术点",content:""}]},{path:"/web/React/%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/react%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",title:"",pathLocale:"/",contents:[{header:"React 组件通信",slug:"react-组件通信",content:""}]},{path:"/web/Vue/Vue2/Vue2%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1.html",title:"",pathLocale:"/",contents:[{header:"Vue2 组件通信",slug:"vue2-组件通信",content:`在 Vue 2 中，组件之间的通信方式主要有以下几种： 使用自定义事件：通过在父组件中定义一个事件，子组件可以触发该事件并传递数据到父组件。父组件通过监听该事件，接收子组件传递的数据。 例如：
<!-- ParentComponent.vue -->
<template> <div> <ChildComponent @message="handleMessage" /> </div>
</template> <script> import ChildComponent from "./ChildComponent.vue"; export default { components: { ChildComponent, }, methods: { handleMessage(data) { console.log("Message received:", data); }, }, };
<\/script>
<!-- ChildComponent.vue -->
<template> <button @click="sendMessage">Send Message</button>
</template> <script> export default { methods: { sendMessage() { this.$emit("message", "Hello from child component!"); }, }, };
<\/script> 使用 props：父组件通过在子组件上绑定属性，将数据传递给子组件。子组件通过 props 选项接收这些数据。 例如：
<!-- ParentComponent.vue -->
<template> <div> <ChildComponent :message="parentMessage" /> </div>
</template> <script> import ChildComponent from "./ChildComponent.vue"; export default { components: { ChildComponent, }, data() { return { parentMessage: "Hello from parent component!", }; }, };
<\/script>
<!-- ChildComponent.vue -->
<template> <div>{{ message }}</div>
</template> <script> export default { props: { message: { type: String, required: true, }, }, };
<\/script> 使用 v-bind 指令：在子组件上使用 v-bind 指令，将数据绑定到父组件的某个属性上。 例如：
<!-- ParentComponent.vue -->
<template> <div> <ChildComponent :data="parentData" /> </div>
</template> <script> import ChildComponent from "./ChildComponent.vue"; export default { components: { ChildComponent, }, data() { return { parentData: "Hello from parent component!", }; }, };
<\/script>
<!-- ChildComponent.vue -->
<template> <div>{{ data }}</div>
</template> <script> export default { props: { data: { type: String, required: true, }, }, };
<\/script> $parent、$children、$root、$refs 使用 vuex 进行组件间数据的通信 引入第三方插件 pubsub 进行发布订阅 以上就是 Vue 2 中组件通信的几种方式。在实际项目中，可以根据需求选择合适的方式来实现组件之间的通信。`}]},{path:"/web/Vue/Vue3/pinia.html",title:"",pathLocale:"/",contents:[{header:"pinia",slug:"pinia",content:`pinia 写法:选择器 API、组合式 API
例如：
/**store/index.ts**/ //创建大仓库
import { createPinia } from "pinia";
//createPinia方法可以用于创建大仓库
let store = createPinia();
//对外暴露,安装仓库
export default store;
/**store/modules/info.ts**/ //定义info小仓库
import { defineStore } from "pinia";
//第一个仓库:小仓库名字 第二个参数:小仓库配置对象
//defineStore方法执行会返回一个函数,函数作用就是让组件可以获取到仓库数据
let useInfoStore = defineStore("info", { //存储数据:state state: () => { return { count: 99, arr: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], }; }, actions: { //注意:函数没有context上下文对象 //没有commit、没有mutations去修改数据 updateNum(a: number, b: number) { this.count += a; }, }, getters: { total() { let result: any = this.arr.reduce((prev: number, next: number) => { return prev + next; }, 0); return result; }, },
});
//对外暴露方法
export default useInfoStore;
/**store/modules/todo.ts**/ //定义组合式API仓库
import { defineStore } from "pinia";
import { ref, computed, watch } from "vue";
//创建小仓库
let useTodoStore = defineStore("todo", () => { let todos = ref([ { id: 1, title: "吃饭" }, { id: 2, title: "睡觉" }, { id: 3, title: "打豆豆" }, ]); let arr = ref([1, 2, 3, 4, 5]); const total = computed(() => { return arr.value.reduce((prev, next) => { return prev + next; }, 0); }); //务必要返回一个对象:属性与方法可以提供给组件使用 return { todos, arr, total, updateTodo() { todos.value.push({ id: 4, title: "组合式API方法" }); }, };
}); export default useTodoStore;
<!-- ParentComponent.vue -->
<template> <div class="box"> <h1>pinia</h1> <div class="container"> <Child></Child> <Child1></Child1> </div> </div>
</template> <script setup lang="ts"> import Child from "./Child.vue"; import Child1 from "./Child1.vue"; //vuex:集中式管理状态容器,可以实现任意组件之间通信！！！ //核心概念:state、mutations、actions、getters、modules //pinia:集中式管理状态容器,可以实现任意组件之间通信！！！ //核心概念:state、actions、getters //pinia写法:选择器API、组合式API
<\/script>
<!-- ChildComponent.vue -->
<template> <div class="child"> <h1>{{ infoStore.count }}---{{infoStore.total}}</h1> <button @click="updateCount">点击我修改仓库数据</button> </div>
</template> <script setup lang="ts"> import useInfoStore from "../../store/modules/info"; //获取小仓库对象 let infoStore = useInfoStore(); console.log(infoStore); //修改数据方法 const updateCount = () => { //仓库调用自身的方法去修改仓库的数据 infoStore.updateNum(66, 77); };
<\/script>
<!-- Child1.vue -->
<template> <div class="child1"> {{ infoStore.count }} <p @click="updateTodo">{{ todoStore.arr }}{{todoStore.total}}</p> </div>
</template> <script setup lang="ts"> import useInfoStore from "../../store/modules/info"; //获取小仓库对象 let infoStore = useInfoStore(); //引入组合式API函数仓库 import useTodoStore from "../../store/modules/todo"; let todoStore = useTodoStore(); //点击p段落去修改仓库的数据 const updateTodo = () => { todoStore.updateTodo(); };
<\/script>`}]},{path:"/web/Vue/Vue3/props.html",title:"",pathLocale:"/",contents:[{header:"props",slug:"props",content:`Vue 3 中组件之间的通信方式有以下几种：
使用 props：与 Vue 2 中的用法类似，父组件通过在子组件上绑定属性，将数据传递给子组件。子组件通过 props 选项接收这些数据。
例如：
<!-- ParentComponent.vue -->
<template> <div class="box"> <h1>props:我是父组件曹操</h1> <hr /> <Child info="我是曹操" :money="money"></Child> </div>
</template> <script setup lang="ts"> //props:可以实现父子组件通信,props数据还是只读的！！！ import Child from "./Child.vue"; import { ref } from "vue"; let money = ref(10000);
<\/script>
<!-- ChildComponent.vue -->
<template> <div class="son"> <h1>我是子组件:曹植</h1> <p>{{props.info}}</p> <p>{{props.money}}</p> <!--props可以省略前面的名字---> <p>{{info}}</p> <p>{{money}}</p> <button @click="updateProps">修改props数据</button> </div>
</template> <script setup lang="ts"> //需要使用到defineProps方法去接受父组件传递过来的数据 //defineProps是Vue3提供方法,不需要引入直接使用 let props = defineProps(["info", "money"]); //数组|对象写法都可以 //按钮点击的回调 const updateProps = () => { // props.money+=10; props:只读的 console.log(props.info); };
<\/script>`}]},{path:"/web/Vue/Vue3/provide%E4%B8%8Einject.html",title:"",pathLocale:"/",contents:[{header:"provide 与 inject",slug:"provide-与-inject",content:`provide(提供)与 inject(注入)：Vue3 提供 provide(提供)与 inject(注入),可以实现隔辈组件传递数据。
例如：
<!-- ParentComponent.vue -->
<template> <div class="box"> <h1>Provide与Inject{{car}}</h1> <hr /> <Child></Child> </div>
</template> <script setup lang="ts"> import Child from "./Child.vue"; //vue3提供provide(提供)与inject(注入),可以实现隔辈组件传递数据 import { ref, provide } from "vue"; let car = ref("法拉利"); //祖先组件给后代组件提供数据 //两个参数:第一个参数就是提供的数据key //第二个参数:祖先组件提供数据 provide("TOKEN", car);
<\/script>
<!-- Child.vue -->
<template> <div class="child"> <h1>我是子组件1</h1> <Child></Child> </div>
</template> <script setup lang="ts"> import Child from "./GrandChild.vue";
<\/script>
<!-- GrandChild.vue -->
<template> <div class="child1"> <h1>孙子组件</h1> <p>{{car}}</p> <button @click="updateCar">更新数据</button> </div>
</template> <script setup lang="ts"> import { inject } from "vue"; //注入祖先组件提供数据 //需要参数:即为祖先提供数据的key let car = inject("TOKEN"); const updateCar = () => { car.value = "自行车"; };
<\/script>`}]},{path:"/web/Vue/Vue3/ref%E4%B8%8E_parent.html",title:"",pathLocale:"/",contents:[{header:"ref 与$parent",slug:"ref-与-parent",content:`使用 ref 与$parent：在 Vue 3 中，ref可以获取真实的DOM节点,可以获取到子组件实例VC,$parent:可以在子组件内部获取到父组件的实例。
例如：
<!-- ParentComponent.vue -->
<template> <div class="box"> <h1>我是父亲曹操:{{money}}</h1> <button @click="handler">找我的儿子曹植借10元</button> <hr /> <Son ref="son"></Son> <hr /> <Dau></Dau> </div>
</template> <script setup lang="ts"> //ref:可以获取真实的DOM节点,可以获取到子组件实例VC //$parent:可以在子组件内部获取到父组件的实例 //引入子组件 import Son from "./Son.vue"; import Dau from "./Daughter.vue"; import { ref } from "vue"; //父组件钱数 let money = ref(100000000); //获取子组件的实例 let son = ref(); //父组件内部按钮点击回调 const handler = () => { money.value += 10; //儿子钱数减去10 son.value.money -= 10; son.value.fly(); }; //对外暴露 defineExpose({ money, });
<\/script>
<!-- Son.vue -->
<template> <div class="son"> <h3>我是子组件:曹植{{money}}</h3> </div>
</template> <script setup lang="ts"> import { ref } from "vue"; //儿子钱数 let money = ref(666); const fly = () => { console.log("我可以飞"); }; //组件内部数据对外关闭的，别人不能访问 //如果想让外部访问需要通过defineExpose方法对外暴露 defineExpose({ money, fly, });
<\/script>
<!-- Daughter.vue -->
<template> <div class="dau"> <h1>我是闺女曹杰{{money}}</h1> <button @click="handler($parent)">点击我爸爸给我10000元</button> </div>
</template> <script setup lang="ts"> import { ref } from "vue"; //闺女钱数 let money = ref(999999); //闺女按钮点击回调 const handler = ($parent) => { money.value += 10000; $parent.money -= 10000; };
<\/script>`}]},{path:"/web/Vue/Vue3/slot.html",title:"",pathLocale:"/",contents:[{header:"slot",slug:"slot",content:`使用插槽：在 Vue 3 中，作用域插槽就是可以传递数据的插槽,子组件可以讲数据回传给父组件,父组件可以决定这些回传的。
例如：
<!-- ParentComponent.vue -->
<template> <div> <h1>slot</h1> <Test1 :todos="todos"> <template v-slot="{ $row, $index }"> <p :style="{ color: $row.done ? 'green' : 'red' }"> {{ $row.title }}--{{ $index }} </p> </template> </Test1> <Test> <div> <pre>大江东去浪淘尽,千古分流人物</pre> </div> <!-- 具名插槽填充a --> <template #a> <div>我是填充具名插槽a位置结构</div> </template> <!-- 具名插槽填充b v-slot指令可以简化为# --> <template #b> <div>我是填充具名插槽b位置结构</div> </template> </Test> </div>
</template> <script setup lang="ts"> import Test from "./Test.vue"; import Test1 from "./Test1.vue"; //插槽:默认插槽、具名插槽、作用域插槽 //作用域插槽:就是可以传递数据的插槽,子组件可以讲数据回传给父组件,父组件可以决定这些回传的 //数据是以何种结构或者外观在子组件内部去展示！！！ import { ref } from "vue"; //todos数据 let todos = ref([ { id: 1, title: "吃饭", done: true }, { id: 2, title: "睡觉", done: false }, { id: 3, title: "打豆豆", done: true }, { id: 4, title: "打游戏", done: false }, ]);
<\/script>
<!-- Test.vue -->
<template> <div class="box"> <h1>我是子组件默认插槽</h1> <!-- 默认插槽 --> <slot></slot> <h1>我是子组件默认插槽</h1> <h1>具名插槽填充数据</h1> <slot name="a"></slot> <h1>具名插槽填充数据</h1> <h1>具名插槽填充数据</h1> <slot name="b"></slot> <h1>具名插槽填充数据</h1> </div>
</template> <script setup lang="ts"><\/script>
<!-- Test1.vue -->
<template> <div class="box"> <h1>作用域插槽</h1> <ul> <li v-for="(item, index) in todos" :key="item.id"> <!--作用域插槽:可以讲数据回传给父组件--> <slot :$row="item" :$index="index"></slot> </li> </ul> </div>
</template> <script setup lang="ts"> //通过props接受父组件传递数据 defineProps(["todos"]);
<\/script>`}]},{path:"/web/Vue/Vue3/useAttrs.html",title:"",pathLocale:"/",contents:[{header:"useAttrs",slug:"useattrs",content:`使用 useAttrs：Vue3 提供一个方法 useAttrs 方法,它可以获取组件身上的属性与事件。
例如：
<template> <div> <h1>useAttrs</h1> <el-button type="primary" size="small" :icon="Edit"></el-button> <!-- 自定义组件 --> <HintButton type="primary" size="small" :icon="Edit" title="编辑按钮" @click="handler" @xxx="handler" ></HintButton> </div>
</template> <script setup lang="ts"> //vue3框架提供一个方法useAttrs方法,它可以获取组件身上的属性与事件！！！ //图标组件 import { Check, Delete, Edit, Message, Search, Star, } from "@element-plus/icons-vue"; import HintButton from "./HintButton.vue"; //按钮点击的回调 const handler = () => { alert(12306); };
<\/script>
<!-- HintButton.vue -->
<template> <div :title="title"> <el-button :="$attrs"></el-button> </div>
</template> <script setup lang="ts"> //引入useAttrs方法:获取组件标签身上属性与事件 import { useAttrs } from "vue"; //此方法执行会返回一个对象 let $attrs = useAttrs(); //万一用props接受title let props = defineProps(["title"]); //props与useAttrs方法都可以获取父组件传递过来的属性与属性值 //但是props接受了useAttrs方法就获取不到了 console.log($attrs);
<\/script> <style scoped></style>`}]},{path:"/web/Vue/Vue3/v-model.html",title:"",pathLocale:"/",contents:[{header:"v-model",slug:"v-model",content:`使用 v-model：在 Vue 3 中，可以使用 v-model 指令将数据双向绑定到父组件和子组件。
例如：
<!-- ParentComponent.vue -->
<template> <div> <h1>v-model:钱数{{ money }}{{pageNo}}{{pageSize}}</h1> <input type="text" v-model="info" /> <hr /> <!-- props:父亲给儿子数据 --> <!-- <Child :modelValue="money" @update:modelValue="handler"></Child> --> <!-- v-model组件身上使用 第一:相当有给子组件传递props[modelValue] = 10000 第二:相当于给子组件绑定自定义事件update:modelValue --> <Child v-model="money"></Child> <hr /> <Child1 v-model:pageNo="pageNo" v-model:pageSize="pageSize"></Child1> </div>
</template> <script setup lang="ts"> //v-model指令:收集表单数据,数据双向绑定 //v-model也可以实现组件之间的通信,实现父子组件数据同步的业务 //父亲给子组件数据 props //子组件给父组件数据 自定义事件 //引入子组件 import Child from "./Child.vue"; import Child1 from "./Child1.vue"; import { ref } from "vue"; let info = ref(""); //父组件的数据钱数 let money = ref(10000); //自定义事件的回调 const handler = (num) => { //将来接受子组件传递过来的数据 money.value = num; }; //父亲的数据 let pageNo = ref(1); let pageSize = ref(3);
<\/script>
<!-- Child.vue -->
<template> <div class="child"> <h3>钱数:{{ modelValue }}</h3> <button @click="handler">父子组件数据同步</button> </div>
</template> <script setup lang="ts"> //接受props let props = defineProps(["modelValue"]); let $emit = defineEmits(["update:modelValue"]); //子组件内部按钮的点击回调 const handler = () => { //触发自定义事件 $emit("update:modelValue", props.modelValue + 1000); };
<\/script>
<!-- Child1.vue -->
<template> <div class="child2"> <h1>同时绑定多个v-model</h1> <button @click="handler">pageNo{{ pageNo }}</button> <button @click="$emit('update:pageSize', pageSize + 4)"> pageSize{{ pageSize }} </button> </div>
</template> <script setup lang="ts"> let props = defineProps(["pageNo", "pageSize"]); let $emit = defineEmits(["update:pageNo", "update:pageSize"]); //第一个按钮的事件回调 const handler = () => { $emit("update:pageNo", props.pageNo + 3); };
<\/script>`}]},{path:"/web/Vue/Vue3/%E5%85%A8%E5%B1%80%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BA%BF.html",title:"",pathLocale:"/",contents:[{header:"全局事件总线",slug:"全局事件总线",content:`使用第三方插件，需要 npm install mitt 全局安装并对外暴漏；
例如：
//引入mitt插件:mitt一个方法,方法执行会返回bus对象
import mitt from "mitt";
const $bus = mitt();
export default $bus;
<!-- ParentComponent.vue -->
<template> <div class="box"> <h1>全局事件总线$bus</h1> <hr /> <div class="container"> <Child1></Child1> <Child2></Child2> </div> </div>
</template> <script setup lang="ts"> //引入子组件 import Child1 from "./Child1.vue"; import Child2 from "./Child2.vue";
<\/script>
<!-- Child1.vue --> <template> <div class="child1"> <h3>我是子组件1:曹植</h3> </div>
</template> <script setup lang="ts"> import $bus from "../../bus"; //组合式API函数 import { onMounted } from "vue"; //组件挂载完毕的时候,当前组件绑定一个事件,接受将来兄弟组件传递的数据 onMounted(() => { //第一个参数:即为事件类型 第二个参数:即为事件回调 $bus.on("car", (car) => { console.log(car); }); });
<\/script>
<!-- Child2.vue -->
<template> <div class="child2"> <h2>我是子组件2:曹丕</h2> <button @click="handler">点击我给兄弟送一台法拉利</button> </div>
</template> <script setup lang="ts"> //引入$bus对象 import $bus from "../../bus"; //点击按钮回调 const handler = () => { $bus.emit("car", { car: "法拉利" }); };
<\/script>`}]},{path:"/web/Vue/Vue3/%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6.html",title:"",pathLocale:"/",contents:[{header:"自定义事件",slug:"自定义事件",content:`使用 自定义事件：在 Vue 3 中，不管是放在标签身上、组件标签身上都是原生 DOM 事件。可以通过自定义事件向父组件传值。
例如：
<!-- ParentComponent.vue --> <template> <div> <h1>事件</h1> <!-- 原生DOM事件 --> <pre @click="handler"> 大江东去浪淘尽,千古分流人物 </pre> <button @click="handler1(1,2,3,$event)">点击我传递多个参数</button> <hr /> <!-- vue2框架当中:这种写法自定义事件,可以通过.native修饰符变为原生DOM事件 vue3框架下面写法其实即为原生DOM事件 vue3:原生的DOM事件不管是放在标签身上、组件标签身上都是原生DOM事件 --> <Event1 @click="handler2"></Event1> <hr /> <!-- 绑定自定义事件xxx:实现子组件给父组件传递数据 --> <Event2 @xxx="handler3" @click="handler4"></Event2> </div>
</template> <script setup lang="ts"> //引入子组件 import Event1 from "./Event1.vue"; //引入子组件 import Event2 from "./Event2.vue"; //事件回调--1 const handler = (event) => { //event即为事件对象 console.log(event); }; //事件回调--2 const handler1 = (a, b, c, $event) => { console.log(a, b, c, $event); }; //事件回调---3 const handler2 = () => { console.log(123); }; //事件回调---4 const handler3 = (param1, param2) => { console.log(param1, param2); }; //事件回调--5 const handler4 = (param1, param2) => { console.log(param1, param2); };
<\/script>
<!-- Event1.vue -->
<template> <div class="son"> <p>我是子组件1</p> <button>点击我也执行</button> </div>
</template> <script setup lang="ts"><\/script>
<!-- Event2.vue -->
<template> <div class="child"> <p>我是子组件2</p> <button @click="handler">点击我触发自定义事件xxx</button> <button @click="$emit('click','AK47','J20')"> 点击我触发自定义事件click </button> </div>
</template> <script setup lang="ts"> //利用defineEmits方法返回函数触发自定义事件 //defineEmits方法不需要引入直接使用 let $emit = defineEmits(["xxx", "click"]); //按钮点击回调 const handler = () => { //第一个参数:事件类型 第二个|三个|N参数即为注入数据 $emit("xxx", "东风导弹", "航母"); };
<\/script>`}]},{path:"/web/Vue/Vue3Plus/class%E4%B8%8Estyle%E7%9A%84%E7%BB%91%E5%AE%9A.html",title:"",pathLocale:"/",contents:[{header:"class 与 style 的绑定",slug:"class-与-style-的绑定",content:""}]},{path:"/web/Vue/Vue3Plus/props%E4%B8%8Eemit.html",title:"",pathLocale:"/",contents:[{header:"props 与 emit",slug:"props-与-emit",content:""}]},{path:"/web/Vue/Vue3Plus/%E4%BC%A0%E9%80%8FAttribute%E7%9A%84%E5%8F%96%E6%B6%88%E4%B8%8EuseAttrs.html",title:"",pathLocale:"/",contents:[{header:"传透 Attribute 的取消与 useAttrs",slug:"传透-attribute-的取消与-useattrs",content:""}]},{path:"/web/Vue/Vue3Plus/%E4%BE%A6%E5%90%AC%E5%99%A8watch%E4%B8%8EwatchEffect.html",title:"",pathLocale:"/",contents:[{header:"侦听器 watch 与 watchEffect",slug:"侦听器-watch-与-watcheffect",content:""}]},{path:"/web/Vue/Vue3Plus/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%9F%BA%E7%A1%80ref%E4%B8%8Ereactive.html",title:"",pathLocale:"/",contents:[{header:"响应式基础 ref 与 reactive",slug:"响应式基础-ref-与-reactive",content:""}]},{path:"/web/Vue/Vue3Plus/%E6%8F%92%E6%A7%BD%E7%9A%84%E7%94%A8%E6%B3%95.html",title:"",pathLocale:"/",contents:[{header:"插槽 v-model:default={...}的用法",slug:"插槽-v-model-default-的用法",content:""}]},{path:"/web/Vue/Vue3Plus/%E6%9D%A1%E4%BB%B6%E6%B8%B2%E6%9F%93(v-if%E4%B8%8Ev-for%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7).html",title:"",pathLocale:"/",contents:[{header:"条件渲染(v-if 与 v-for 的优先级)",slug:"条件渲染-v-if-与-v-for-的优先级",content:""}]},{path:"/web/Vue/Vue3Plus/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html",title:"",pathLocale:"/",contents:[{header:"生命周期",slug:"生命周期",content:""}]},{path:"/web/Vue/Vue3Plus/%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C(%E5%B1%80%E9%83%A8%E4%B8%8E%E5%85%A8%E5%B1%80).html",title:"",pathLocale:"/",contents:[{header:"组件注册(局部与全局)",slug:"组件注册-局部与全局",content:""}]},{path:"/web/Vue/Vue3Plus/%E7%BB%84%E5%90%88%E5%BC%8FApi%E7%9A%84%E4%BC%98%E7%82%B9.html",title:"",pathLocale:"/",contents:[{header:"组合式 Api 可以像一样 react-hooks 拆分",slug:"组合式-api-可以像一样-react-hooks-拆分",content:""}]},{path:"/web/Vue/Vue3Plus/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8C%87%E4%BB%A4%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6.html",title:"",pathLocale:"/",contents:[{header:"自定义指令与自定义插件",slug:"自定义指令与自定义插件",content:""}]},{path:"/web/Vue/Vue3Plus/%E8%A1%A8%E5%8D%95%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A.html",title:"",pathLocale:"/",contents:[{header:"表单的双向绑定",slug:"表单的双向绑定",content:""}]},{path:"/web/Vue/Vue3Plus/%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E4%B8%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%8C%BA%E5%88%AB.html",title:"",pathLocale:"/",contents:[{header:"计算属性的缓存机制与事件的区别",slug:"计算属性的缓存机制与事件的区别",content:""}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/IO%E6%B5%81%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html",title:"",pathLocale:"/",contents:[{header:"IO 流异常处理",slug:"io-流异常处理",content:`package com.wuziqi.gobang.IO; import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException; public class DemoErrorTryCatch { public static void main(String[] args) { FileInputStream fis = null; FileOutputStream fos = null; try{ // 创建字节输入流对象 fis = new FileInputStream("aaa/b.txt"); // 创建字节输出流对象 fos = new FileOutputStream("aaa/a.txt"); // 一次读取一个字节数组，一次写入一个字节数组的一部分 byte[] bys = new byte[1024]; int len = 0; while( (len = fis.read(bys)) != -1 ){ fos.write(bys, 0, len); } }catch( IOException e ){ e.printStackTrace(); }finally{ // 释放资源 if (fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } if (fos != null){ try { fos.close(); } catch (IOException e) { e.printStackTrace(); } } } }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/IO%E6%B5%81%E6%A6%82%E8%BF%B0.html",title:"",pathLocale:"/",contents:[{header:"IO 流概述",slug:"io-流概述",content:`所有相关的抽象类和实现类，都需要导包，且都在 java.io 包下。
什么是 IO 流？
I：Input，读、输入，将数据从本地磁盘中读出来，输入到内存中(大脑里)
O：Output，写、输出，将内存中的数据写下来，输出到本地磁盘中(写纸上)`},{header:"IO 流的体系结构",slug:"io-流的体系结构",content:""},{header:"IO 流的分类",slug:"io-流的分类",content:`按照流向分 输入流
输出流 按照类型分 字节流
字符流 按习惯分类 字节输入流
字节输出流
字符输入流
字符输出流`},{header:"流的选择",slug:"流的选择",content:`字符流操作文本
字节流是万能流`},{header:"流的转换",slug:"流的转换",content:"转换流，可以将字节流转换成字符流。"},{header:"流的打印",slug:"流的打印",content:"打印流，只能是输出流；既有字节打印流，又有字符打印流。"}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/IO%E6%B5%81%E7%9A%84%E9%80%89%E6%8B%A9.html",title:"",pathLocale:"/",contents:[{header:"IO 流的选择",slug:"io-流的选择",content:`一般的 txt、java 等文件，内容能看得懂的可以使用字符流；如果看不懂，必须使用字节流；
字节流可以操作大多数文件，如 mp4、mp3、img 等；
docx 和 excel 文件不能用字符流，即便是用的是字节流，也可能出现内容丢失的情况。`},{header:"1. 字符流",slug:"_1-字符流",content:"字符流只能操作文本文件"},{header:"2. 字节流",slug:"_2-字节流",content:"万能流，可以操作所有文件"},{header:"总结",slug:"总结",content:""}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Collection%E6%8E%A5%E5%8F%A3.html",title:"",pathLocale:"/",contents:[{header:"Collection 接口",slug:"collection-接口",content:"单列集合；需要导包，在 java.util 下；Collection 接口，不是类，是单列集合的顶层"},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 boolean add(Object e)
添加元素 boolean addAll(Collection c)
添加集合 boolean remove(Object o)
删除元素 boolean removeIf(Predicate filter)
按照条件删除元素 void clear()
清空集合 int size()
获取集合长度 boolean contains(Object o)
是否包含 boolean isEmpty
是否为空 Object[] toArray()
集合转数组 Iterator<E> iterator()
获取迭代器对象`},{header:"集合的遍历",slug:"集合的遍历",content:`转数组循环遍历 Collection c = new ArrayList();
Object[] obj = c.toArray();
for(int i = 0; i < obj.length; i++){ System.out.println(obj[i]);
} 迭代器遍历 Collection c = new ArrayList();
Iterator it = c.iterator();
while (it.hasNext()) { Object obj = it.next(); System.out.println(obj);
} 增强 for 循环(for each 遍历) 增强 for 循环底层也是迭代器遍历，只是简化写法
增强 for 循环也可以用来遍历数组
格式：for(数据类型 变量名 : 数组名/集合名){...} Collection c = new ArrayList();
for (Object obj : c) { System.out.println(obj);
}`},{header:"方法的应用",slug:"方法的应用",content:`package com.wuziqi.gobang.controller; import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.function.Predicate; public class DemoCollection { public static void main(String[] args) { // 多态格式的，Collection是类，所以只能创建子对象 Collection c = new ArrayList(); System.out.println(c); // 结果为[]: 说明底层重写了toString方法 // boolean add(Object e)：集合中添加一个元素 c.add("aaa"); c.add("bbb"); // Collection只能添加引用类型，这块不报错说明底层自动转成Integer类型了 c.add(111); System.out.println(c); // [aaa, bbb, 111] // boolean addAll(Collection c)：集合中添加一个集合 Collection c1 = new ArrayList(); c1.addAll(c); System.out.println(c1); // [aaa, bbb, 111] // boolean remove(Object o)：删除某一元素 c1.remove("aaa"); System.out.println(c1); // [bbb, 111] // boolean removeIf(Predicate filter)：根据条件删除 // Object是泛型，当然可以换成String等 c.removeIf(new Predicate<Object>() { @Override public boolean test(Object t) { // Object和上边对应 // return true; // 满足条件，要把该元素删除掉 // reutrn false; // 不满足，不能删掉元素 return t instanceof Integer; } }); // c.removeIf((o) -> o.equals(111)); // 与上边的重写方法一样效果 System.out.println(c); // [aaa, bbb] // boolean isEmpty()：是否为空 System.out.println(c.isEmpty()); // false // int Size()：获取长度 System.out.println(c.size()); // 2 // boolean contains(Object o)：是否包含 System.out.println(c); // [aaa, bbb] c.add(111); System.out.println(c.contains("ddd")); // false System.out.println(c.contains(111)); // true // void clear()：清空集合 c.clear(); System.out.println(c); // [] System.out.println(c.isEmpty()); // true // Object[] toArray()：转成数组进行遍历 System.out.println(c1); // [bbb, 111] Object[] objs = c1.toArray(); for (int i = 0; i < objs.length; i++){ System.out.println(objs[i]); // bbb 111 } // Iterator<E> iterator()：通过迭代器对象遍历 c1.add(new Pigs("小明", 18)); // 结果：[bbb, 111, com.wuziqi.gobang.controller.Pigs@23fc625e] // 给Pigs加上toString()方法后 // 打印结果：[bbb, 111, Pigs{name='小明', age=18}] System.out.println(c1); /** * Iterator是接口 * 有两个子方法 * hasNext()：判断是否还有元素 * next()：获取下一个元素 * */ Iterator it = c1.iterator(); // 需要导包，也是多态格式 while (it.hasNext()){ System.out.println(it.next()); // 打印结果：bbb 111 Pigs{name='小明', age=18} } // 增强for循环(for each遍历) for (Object obj : c1){ System.out.println(obj); // 打印结果：bbb 111 Pigs{name='小明', age=18} } // 增强for循环遍历数组 int arr[] = {1,2,3,4,5,6,7,8,9}; for (Object obj : arr){ System.out.println(obj); // 1,2,3,4,5,6,7,8,9 } }
}
class Pigs{ private String name; private int age; Pigs(String name, int age){ this.name = name; this.age = age; } @Override public String toString() { return "Pigs{" + "name='" + name + '\\'' + ", age=" + age + '}'; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Iterator%E8%BF%AD%E4%BB%A3%E5%99%A8.html",title:"",pathLocale:"/",contents:[{header:"Iterator 迭代器",slug:"iterator-迭代器",content:""}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88Map/HashMap%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"HashMap 实现类",slug:"hashmap-实现类",content:`和Map一模一样；
双列集合；需要导包，在 java.util 下； HashMap 是实现类。`},{header:"HashMap 集合的特性",slug:"hashmap-集合的特性",content:"无序性 无索引 元素唯一(键唯一，值不唯一) 双列的"},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 V put(K key, V value)
添加元素，返回添加之前的值；修改元素，返回被修改之前的值 V remove(Object key)
根据键来删除元素，返回被删除的元素的值 int size()
获取长度 void clear()
清空 V get(Object key)
根据键来获取值 boolean containsKey(Object key)
判断是否包含，键为给定的内容，的元素 boolean containsValue(Object value)
判断是否包含，值为给定的内容，的元素 Set<K> keySet()
获取所有的键，并用 Set 集合接收 Collection<V> values()
获取所有的值，并用 Collection(或其他结合) 集合接收 Set<Map.Entry<K,V>> entrySet()
获取所有的键值对，并用 Set 结合接收`},{header:"HashMap 集合的遍历",slug:"hashmap-集合的遍历",content:`键找值遍历 Set <String> keys = map.keySet(); for (String key : keys){ System.out.println(key + ":" + map.get(key)); // 结果： // 李四:20 // 张三:18 // 王五:22
} 键值对获取键合值 Set<Map.Entry<String, Integer>> entrySet = map.entrySet(); for (Map.Entry<String, Integer> entry : entrySet){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22
}
import java.util.Map.Entry; // 内部类的用法，需要导包
Set<Entry<String, Integer>> entrySet = map.entrySet(); for (Entry<String, Integer> entry : entrySet){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22
}`},{header:"方法的应用",slug:"方法的应用",content:`package com.wuziqi.gobang.Map; import java.util.HashMap;
import java.util.Set;
import java.util.Map.Entry; public class DemoHashMap { public static void main(String[] args) { HashMap<Integer, Person> map= new HashMap<Integer, Person>(); map.put(1, new Person("John", 18)); map.put(2, new Person("Jack", 20)); map.put(3, new Person("Jim", 22)); // 遍历一 Set<Integer> keys = map.keySet(); for (Integer key : keys) { System.out.println(key); System.out.println(map.get(key)); // 结果： // 1 // Person{name='John', age=18} // 2 // Person{name='Jack', age=20} // 3 // Person{name='Jim', age=22} } // 遍历二 Set<Entry<Integer, Person>> entries = map.entrySet(); for (Entry<Integer, Person> entry : entries) { int key = entry.getKey(); Person p = entry.getValue(); System.out.println(key+ ":" + p.getName()+ "," + p.getAge()); // 结果： // 1:John,18 // 2:Jack,20 // 3:Jim,22 } }
}
class Person{ private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Person{" + "name='" + name + '\\'' + ", age=" + age + '}'; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88Map/HashTable%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"HashTable 实现类",slug:"hashtable-实现类",content:`只有HashMap的键值对都可以为 null， HashTable、TreeMap 的键和值都不可以为 null，否则会报空指针异常。
package com.wuziqi.gobang.Map; import sun.reflect.generics.tree.Tree; import java.util.HashMap;
import java.util.Hashtable;
import java.util.TreeMap; public class DemoHashTable { public static void main(String[] args) { Hashtable<String, Integer> ht = new Hashtable<String, Integer>(); ht.put("aaa", 1); // ht.put(null,null); // 报错 // ht.put("bbb", null); // 报错 // ht.put(null,2); // 报错 System.out.println(ht); // 结果：{aaa=1} // 键和值都不能为 null HashMap<String, Integer> hm = new HashMap<String, Integer>(); hm.put("aaa", 1); // hm.put(null,null); // hm.put("bbb", null); // hm.put(null,2); System.out.println(hm); // 结果：{aaa=1, null=2, bbb=null} // 键合值都可以为 null TreeMap<String, Integer> tm = new TreeMap<String, Integer>(); tm.put("aaa", 1); // tm.put(null,null); // 报错 // tm.put("bbb", null); // 报错 // tm.put(null,2); // 报错 System.out.println(tm); // 结果：{aaa=1} // 键和值都不能为 null }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88Map/LinkedHashMap%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"LinkedHashMap 实现类",slug:"linkedhashmap-实现类",content:`根LinkedHashSet和HashSet一样；LinkedHashMap 实现类比HashMap多了一个有序的特性。
package com.wuziqi.gobang.Map; import java.util.LinkedHashMap; public class DemoLinkedHashMap { public static void main(String[] args) { LinkedHashMap<String, Integer> map = new LinkedHashMap<String, Integer>(); map.put("bbb", 18); map.put("aaa", 16); map.put("ccc", 22); for (String key : map.keySet()) { System.out.println(key + "=" + map.get(key)); // 结果：有序的，怎么存怎么返 // bbb=18 // aaa=16 // ccc=22 } }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88Map/Map%E6%8E%A5%E5%8F%A3.html",title:"",pathLocale:"/",contents:[{header:"Map 接口",slug:"map-接口",content:"双列集合；需要导包，在 java.util 下；Map 接口，不是类，是双列集合的顶层。"},{header:"Map 集合的特性",slug:"map-集合的特性",content:"无序性 无索引 元素唯一(键唯一，值不唯一) 双列的"},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 V put(K key, V value)
添加元素，返回添加之前的值；修改元素，返回被修改之前的值 V remove(Object key)
根据键来删除元素，返回被删除的元素的值 int size()
获取长度 void clear()
清空 V get(Object key)
根据键来获取值 boolean containsKey(Object key)
判断是否包含，键为给定的内容，的元素 boolean containsValue(Object value)
判断是否包含，值为给定的内容，的元素 Set<K> keySet()
获取所有的键，并用 Set 集合接收 Collection<V> values()
获取所有的值，并用 Collection(或其他结合) 集合接收 Set<Map.Entry<K,V>> entrySet()
获取所有的键值对，并用 Set 结合接收`},{header:"Map 集合的遍历",slug:"map-集合的遍历",content:`键找值遍历 Set <String> keys = map.keySet(); for (String key : keys){ System.out.println(key + ":" + map.get(key)); // 结果： // 李四:20 // 张三:18 // 王五:22
} 键值对获取键合值 Set<Map.Entry<String, Integer>> entrySet = map.entrySet(); for (Map.Entry<String, Integer> entry : entrySet){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22
}
import java.util.Map.Entry; // 内部类的用法，需要导包
Set<Entry<String, Integer>> entrySet = map.entrySet(); for (Entry<String, Integer> entry : entrySet){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22
}`},{header:"方法的应用",slug:"方法的应用",content:`package com.wuziqi.gobang.Map; import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry; public class DemoMap { public static void main(String[] args) { // Map是接口，需要创建实现类对象 Map<String, Integer> map = new HashMap<String,Integer>(); System.out.println(map); // {} // V put(K key, V value) map.put("张三", 18); map.put("李四", 20); map.put("王五", 22); map.put("李四", 18); // 最后输出18，不是添加，是替换 System.out.println(map); // {李四=18, 张三=18, 王五=22} // V remove(Object key) map.remove("王五"); System.out.println(map); // {李四=18, 张三=18} // int size() int size = map.size(); System.out.println(size); // 2 // void clear() map.clear(); System.out.println(map); //{} // V get(Object key) map.put("张三", 18); map.put("李四", 20); map.put("王五", 22); int age = map.get("李四"); System.out.println(age); // 20 // boolean containsKey(Object key) // boolean containsValue(Object value) Boolean isWang = map.containsKey("王五"); Boolean isHou = map.containsKey("后端"); Boolean wangWu = map.containsValue("王五"); Boolean hou = map.containsValue("后端"); System.out.println(isWang); // true System.out.println(isHou); // false System.out.println(wangWu); // true System.out.println(hou); // false // Set<K> keySet() Set<String> set = map.keySet(); for (String s : set){ System.out.println(s); // 李四 张三 王五 } // Collection<V> values() Collection<Integer> values = map.values(); for (Integer i : values){ System.out.println(i); // 20 18 22 } // 遍历一（键找值遍历） Set <String> keys = map.keySet(); for (String key : keys){ System.out.println(key + ":" + map.get(key)); // 结果： // 李四:20 // 张三:18 // 王五:22 } /** * 遍历二 * 键值对 * Set<Map.Entry<K,V>> entrySet() * Map.Entry：是内部类的用法，和Outer.Inner用法一样 * 可以省略Map，但是Entry需要导包 * entry有两个方法：getKey()和getValue() * getKey()：获取键 * getValue()：获取值 * */ Set<Map.Entry<String,Integer>> set1= map.entrySet(); for (Map.Entry<String,Integer> entry : set1){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22 }; Set<Entry<String,Integer>> set2= map.entrySet(); for (Entry<String,Integer> entry : set2){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22 }; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88Map/Properties%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"Properties 实现类",slug:"properties-实现类",content:"是 HashTable 实现类的子类"}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8F%8C%E5%88%97%E9%9B%86%E5%90%88Map/TreeMap%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"TreeMap 实现类",slug:"treemap-实现类",content:`和Map很相似，除了可以排序，其他基本一样；
双列集合；需要导包，在 java.util 下； TreeMap 是实现类。`},{header:"TreeMap 集合的特性",slug:"treemap-集合的特性",content:"无序性 无索引 元素唯一(键唯一，值不唯一) 双列的 可以排序的(根据键来排序)"},{header:"数据结构",slug:"数据结构",content:"红黑树，TreeSet 的底层就是 TreeMap。"},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 V put(K key, V value)
添加元素，返回添加之前的值；修改元素，返回被修改之前的值 V remove(Object key)
根据键来删除元素，返回被删除的元素的值 int size()
获取长度 void clear()
清空 V get(Object key)
根据键来获取值 boolean containsKey(Object key)
判断是否包含，键为给定的内容，的元素 boolean containsValue(Object value)
判断是否包含，值为给定的内容，的元素 Set<K> keySet()
获取所有的键，并用 Set 集合接收 Collection<V> values()
获取所有的值，并用 Collection(或其他结合) 集合接收 Set<Map.Entry<K,V>> entrySet()
获取所有的键值对，并用 Set 结合接收`},{header:"TreeMap 集合的遍历",slug:"treemap-集合的遍历",content:`键找值遍历 Set <String> keys = map.keySet(); for (String key : keys){ System.out.println(key + ":" + map.get(key)); // 结果： // 李四:20 // 张三:18 // 王五:22
} 键值对获取键合值 Set<Map.Entry<String, Integer>> entrySet = map.entrySet(); for (Map.Entry<String, Integer> entry : entrySet){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22
}
import java.util.Map.Entry; // 内部类的用法，需要导包
Set<Entry<String, Integer>> entrySet = map.entrySet(); for (Entry<String, Integer> entry : entrySet){ System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // 李四:20 // 张三:18 // 王五:22
}`},{header:"排序(和TreeSet一样，自然排序、比较器)",slug:"排序-和treeset一样-自然排序、比较器",content:""},{header:"方法的应用",slug:"方法的应用",content:`package com.wuziqi.gobang.Map; import java.util.Comparator;
import java.util.Set;
import java.util.TreeMap;
import java.util.Map.Entry; public class DemoTreeMap { public static void main(String[] args) { TreeMap<String, Student> tm = new TreeMap<String, Student>(); tm.put("9527", new Student("Tom", 18)); tm.put("9530", new Student("Jerry", 18)); tm.put("9526", new Student("Rose", 18)); tm.put("9531", new Student("Nose", 18)); tm.put("9525", new Student("Fore", 18)); Set<String> keys = tm.keySet(); for (String key : keys) { System.out.println(key + ":" + tm.get(key)); // 结果：根据键值，进行了排序 // 9525:Student{name='Fore', age=18} // 9526:Student{name='Rose', age=18} // 9527:Student{name='Tom', age=18} // 9530:Student{name='Jerry', age=18} // 9531:Student{name='Nose', age=18} } TreeMap<Student, String> tm2 = new TreeMap<Student, String>( new Comparator<Student>() { @Override public int compare(Student o1, Student o2) { int i = o1.getAge() - o2.getAge(); int ii = i == 0 ? o1.getName().compareTo(o2.getName()) : i; return ii; } } ); tm2.put(new Student("Tom", 18),"9527"); tm2.put(new Student("Jerry", 17), "9530"); tm2.put(new Student("Rose", 16), "9526"); tm2.put(new Student("Nose", 20), "9531"); tm2.put(new Student("Tom", 18), "9525"); Set<Entry<Student, String>> sets = tm2.entrySet(); for (Entry<Student, String> entry : sets) { System.out.println(entry.getKey() + ":" + entry.getValue()); // 结果： // Student{name='Rose', age=16}:9526 // Student{name='Jerry', age=17}:9530 // Student{name='Tom', age=18}:9525 // Student{name='Nose', age=20}:9531 } }
}
class Student { private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Student{" + "name='" + name + '\\'' + ", age=" + age + '}'; }
}
//class Student implements Comparable<Student>{
// private String name;
// private int age;
//
// public Student(String name, int age) {
// this.name = name;
// this.age = age;
// }
//
// public String getName() {
// return name;
// }
//
// public void setName(String name) {
// this.name = name;
// }
//
// public int getAge() {
// return age;
// }
//
// public void setAge(int age) {
// this.age = age;
// }
//
// @Override
// public String toString() {
// return "Student{" +
// "name='" + name + '\\'' +
// ", age=" + age +
// '}';
// }
// @Override
// public int compareTo(Student o) {
// int i = this.age - o.age;
// int ii = i == 0 ? this.name.compareTo(o.name) : i;
// return ii;
// }
//}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91.html",title:"",pathLocale:"/",contents:[{header:"普通二叉树",slug:"普通二叉树",content:"普通二叉树： 二叉查找树： 平衡二叉树： 红黑树："}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%93%88%E5%B8%8C%E8%A1%A8.html",title:"",pathLocale:"/",contents:[{header:"哈希表",slug:"哈希表",content:`哈希值：是 jdk 通过对象的地址值和一些算法计算出来的一个 int 类型的整数值，
可以通过 Object 类中的 hashCode()方法获取。
jdk1.8 之前：数组 + 链表(即，元素为链表的数组) jdk1.8 开始：数组 + 链表 + 红黑树`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.html",title:"",pathLocale:"/",contents:[{header:"数据结构",slug:"数据结构",content:""},{header:"队列：先进先出",slug:"队列-先进先出",content:""},{header:"栈：先进后出",slug:"栈-先进后出",content:""},{header:"数组：查询快，增删慢",slug:"数组-查询快-增删慢",content:""},{header:"链表：查询慢，增删快",slug:"链表-查询慢-增删快",content:"单向链表： 单向链表修改： 双向链表："}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E6%89%93%E5%8D%B0%E6%B5%81/PrintStream%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"PrintStream 类",slug:"printstream-类",content:"打印字节流，只有输出流，没有输入流"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public PrintStream(String fileName)
根据指定的文件创建 PrintStream public PrintStream(OutputStream out, boolean autoFlush)
根据指定的 OutputStream 创建 PrintStream；默认 false`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public void println(any x)
打印任意类型的 x，并换行 public void print(any x)
打印任意类型的 x，不换行 public void write(int b)
将指定的字节写入此流，不换行 public void write(byte[] buf, int off, int len)
将指定的字节数组的一部分写入此流，不换行`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.DaYinOutput; import java.io.FileOutputStream;
import java.io.PrintStream; public class PrintStream01 { public static void main(String[] args) throws Exception{ // public PrintStream(String fileName) /* PrintStream ps = new PrintStream("aaa/888.txt"); ps.println("你好"); ps.print("这个不换行!"); ps.write(97); ps.close(); */ // PrintStream(OutputStream out, boolean autoFlush) // autoFlush：只有值为true，且方法为println、printf、format才会自动刷新 PrintStream ps = new PrintStream(new FileOutputStream("aaa/888.txt") , true); ps.println("autoFlush:true，这个会自动刷新；且换行"); ps.print("autoFlush:true，这个也不会自动刷新；且不换行!"); ps.write(new byte[]{ 97, 98, 99, 100}, 0, 4); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E6%89%93%E5%8D%B0%E6%B5%81/PrintWriter%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"PrintWriter 类",slug:"printwriter-类",content:"打印字符流，只有输出流，没有输入流"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public PrintWriter(String fileName)
根据指定的文件创建 PrintWriter public PrintWriter(Writer out, boolean autoFlush)
根据指定的 Writer 创建 PrintWriter；默认 false`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public void println(any x)
打印任意类型的 x，并换行 public void print(any x)
打印任意类型的 x，不换行 public void write(String s)
打印字符串 s ，不换行`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.DaYinOutput; import java.io.FileWriter;
import java.io.PrintWriter; public class PrintWriter01 { public static void main(String[] args) throws Exception{ // public PrintWriter(String fileName) /* PrintWriter pw = new PrintWriter("aaa/666.txt"); pw.println("你好"); pw.print("这个不换行!"); pw.write("只能打印字符串、字符或者字符数组；且也不换行"); pw.close(); */ // public PrintWriter(Writer out, boolean autoFlush) // autoFlush：只有值为true，且方法为println、printf、format才会自动刷新 PrintWriter pw = new PrintWriter(new FileWriter("aaa/666.txt"), true); pw.println("autoFlush:true，这个会自动刷新；且换行"); pw.print("autoFlush:true，这个也不会自动刷新；且不换行!"); pw.write("打印字符串 s；autoFlush:true，这个也不会自动刷新；且不换行! "); }
}`},{header:"文件复制",slug:"文件复制",content:`package com.wuziqi.gobang.IO.DaYinOutput; import java.io.BufferedReader;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.PrintWriter; public class PrintCopy01 { public static void main(String[] args) throws Exception { // 一次读取一行，一次写出一行 BufferedReader br = new BufferedReader(new FileReader("aaa/111.txt")); PrintWriter pw = new PrintWriter("aaa/777.txt"); String line = null; while ((line = br.readLine()) != null) { pw.println(line); } pw.close(); br.close(); // 读取一行写入一行，同时开启自动刷新 BufferedReader br = new BufferedReader(new FileReader("aaa/111.txt")); PrintWriter pw = new PrintWriter(new FileWriter("aaa/777.txt"), true); String line = null; while ((line = br.readLine()) != null) { pw.println(line); } }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/List/ArrayList%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"ArrayList 实现类",slug:"arraylist-实现类",content:"需要导包，在 java.util 下；ArrayList 是 List 接口的实现类；底层是数组数据结构。"},{header:"ArrayList 类的特点(List 接口的特点)",slug:"arraylist-类的特点-list-接口的特点",content:`有序的集合（即：存进去的顺序和取出来的顺序是一致的） 有索引
元素都允许重复`},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public ArrayList
new 对象`},{header:"常见的成员方法",slug:"常见的成员方法",content:"和 List 接口 中定义的方法基本一致，当然包括Collection 集合中的方法。"},{header:"遍历",slug:"遍历",content:"和 List 接口 中定义的遍历一样。"},{header:"案例",slug:"案例",content:`/** * 已知集合中存储了"aaa"、"bbb"、"aaa"、"ccc"、"aaa"、"ddd" * * 要求：把集合中的所有"aaa"干掉
*/
import java.util.ArrayList; public class ArrayListDemo { public static void main(String[] args){ ArrayList list = new ArrayList(); list.add("aaa"); list.add("bbb"); list.add("aaa"); list.add("ccc"); list.add("aaa"); list.add("ddd"); System.out.println("修改前的集合：" + list); // 把集合中的所有"aaa"干掉 for (int i = 0; i < list.size(); i++){ if ("aaa".equals(list.get(i))){ list.remove(i); i--; /** * 注意： * 如果删除的是最后一个元素，则不会影响集合的长度 * 如果删除的不是最后一个元素，则需要重新计算下标的位置，重新开始 * i--不能忘记，否则会出现删除不完全的情况 * 如果使用迭代器删除或者使用增强for循环删除，有可能会报错 * java.util.ConcurrentModificationException * 并发修改异常 */ } } }
}
/** * 已知一个集合，有3个学生，遍历打印3个学生的信息
*/
package com.wuziqi.gobang.controller; import java.util.ArrayList; public class DemoList { public static void main(String[] args) { ArrayList astu = new ArrayList(); astu.add(new Student("小明",18)); astu.add(new Student("小张",20)); astu.add(new Student("rose",18)); for (Object o : astu) { //for each 多态格式 // System.out.println(o); 这样直接打印没问题 // 换一种打印 Student s = (Student) o; // 向下转型后才可以使用特有方法 System.out.println(s.getName() + "..." + s.getAge()); } }
} class Student{ private String name; private int age; Student(String name, int age){ this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Student{" + "name='" + name + '\\'' + ", age=" + age + '}'; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/List/LinkedList%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"LinkedList 实现类",slug:"linkedlist-实现类",content:"需要导包，在 java.util 下；LinkedList 是 List 接口的实现类；底层是双向链表数据结构。"},{header:"LinkedList 类的特点(同 ArrayList)",slug:"linkedlist-类的特点-同-arraylist",content:`有序的集合（即：存进去的顺序和取出来的顺序是一致的） 有索引
元素都允许重复`},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public LinkedList
new 对象`},{header:"常见的成员方法",slug:"常见的成员方法",content:`同 ArrayList LinkedList 特有的方法
作用 public void addFirst(Object e)
在首位添加元素 public void addLast(Object e)
在末尾添加元素 public Object getFirst()
获取首位元素 public Object getLast()
获取末尾元素 public Object removeFirst()
删除首位元素，返回被删除的元素 public Object removeLast()
删除末尾元素，返回被删除的元素`},{header:"遍历",slug:"遍历",content:"同 ArrayList"},{header:"到底用 ArrayList 还是 LinkedList",slug:"到底用-arraylist-还是-linkedlist",content:`需要判断对时间和空间的权衡来选择使用哪种集合类。
ArrayList：数组数据结构，查询快，增删慢
LinkedList：链表数据结构，查询慢，增删快 需要考虑存取速度和 LinkedList 需要更多的内存空间 如果需要频繁的插入和删除元素，建议使用 LinkedList 如果需要频繁的随机访问元素，建议使用 ArrayList`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/List/List%E5%AD%90%E6%8E%A5%E5%8F%A3.html",title:"",pathLocale:"/",contents:[{header:"List 子接口",slug:"list-子接口",content:"需要导包，在 java.util 下；List 也是接口，是 Collection 的子接口。"},{header:"List 集合的特点",slug:"list-集合的特点",content:`有序的集合（即：存进去的顺序和取出来的顺序是一致的） 有索引，所以 List 集合也被称为索引集合
元素都允许重复，所以 List 集合也被称为有序集合`},{header:"常见的成员方法",slug:"常见的成员方法",content:`Collection 集合的方法都被继承了，不描述了 方法
作用 boolean add(Object e)
添加元素 void add(int index, Object element)
添加元素 boolean remove(Object o)
删除元素 boolean removeIf(Predicate filter)
按照条件删除元素 Object remove(int index)
删除指定索引处的元素 Object set(int index, Object element)
修改指定索引处的元素，返回被修改的数据 Object get(int index)
返回指定索引处的元素`},{header:"List 集合遍历",slug:"list-集合遍历",content:"转数组循环遍历 迭代器遍历 增强 for 循环遍历(for each) 普通的 for 循环遍历(利用索引)"},{header:"方法的使用案例",slug:"方法的使用案例",content:`package com.wuziqi.gobang.controller; import java.util.ArrayList;
import java.util.Iterator;
import java.util.List; public class DemoList { public static void main(String[] args) { List list = new ArrayList(); list.add("aaa"); list.add("bbb"); list.add("ccc"); // void add(int index, Object element) list.add(1, "ddd"); System.out.println(list); // [aaa, ddd, bbb, ccc] list.remove("ddd"); // void remove(int index) list.remove(1); System.out.println(list); // [aaa, ccc] // Object set(int index, Object element) list.set(1, "bbb"); System.out.println(list); // [bbb,ccc] // Object get(int index) list.get(1); System.out.println(list.get(1)); // bbb list.add("bbb"); list.add("ccc"); list.add(111); list.add(111); // 转数组遍历 Object[] obj = list.toArray(); for (int i = 0; i < obj.length; i++){ System.out.println(obj[i]); } // 迭代器遍历 Iterator it = list.iterator(); while (it.hasNext()){ System.out.println(it.next()); } // 增强for遍历(for each) for (Object o : list){ System.out.println(o); } // 普通for缓存遍历(利用索引) for(int i = 0; i < list.size(); i++){ System.out.println(list.get(i)); } }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Set/Comparable%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F.html",title:"",pathLocale:"/",contents:[{header:"Comparable 自然排序",slug:"comparable-自然排序",content:`一堆学生，只有姓名和年龄，
先根据年龄从小到大排序，
如果年龄相同，则按照字典顺序从小到大排序，
同龄的学生中没有同名的。 package com.wuziqi.gobang.Set; import java.util.TreeSet; public class DemoComparable { public static void main(String[] args) { TreeSet<Person> ts = new TreeSet<Person>(); ts.add(new Person("Tom", 20)); ts.add(new Person("Rose", 19)); ts.add(new Person("Jerry", 20)); ts.add(new Person("Jack", 19)); ts.add(new Person("Tina", 18)); ts.add(new Person("Rose", 19)); System.out.println(ts); }
}
class Person implements Comparable<Person> { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } @Override public String toString() { return "Person{" + "name='" + name + '\\'' + ", age=" + age + '}'; } public int compareTo(Person o) { int i = this.age - o.age; return i == 0 ? this.name.compareTo(o.name) : i; }
}
/** * 输出结果： * [Person{name='Tina', age=18}, Person{name='Jack', age=19}, * Person{name='Rose', age=19}, *Person{name='Jerry', age=20}, * Person{name='Tom', age=20}] */`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Set/Comparator%E6%AF%94%E8%BE%83%E5%99%A8.html",title:"",pathLocale:"/",contents:[{header:"Comparator 比较器",slug:"comparator-比较器",content:`一堆学生，只有姓名和年龄，
先根据年龄从小到大排序，
如果年龄相同，则按照字典顺序从小到大排序，
同龄的学生中没有同名的。 package com.wuziqi.gobang.Set; import java.util.Comparator;
import java.util.TreeSet; public class DemoComparator { public static void main(String[] args) { TreeSet<Student> ts = new TreeSet<Student>(new Comparator<Student>() { @Override public int compare(Student o1, Student o2) { int i = o1.getAge() - o2.getAge(); return i == 0 ? o1.getName().compareTo(o2.getName()) : i; } }); ts.add(new Student("Tom", 20)); ts.add(new Student("Rose", 19)); ts.add(new Student("Jerry", 20)); ts.add(new Student("Jack", 19)); ts.add(new Student("Tina", 18)); ts.add(new Student("Rose", 19)); System.out.println(ts); }
}
class Student{ private String name; private int age; public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Student{" + "name='" + name + '\\'' + ", age=" + age + '}'; }
}
/** * 输出结果： * [Person{name='Tina', age=18}, Person{name='Jack', age=19}, * Person{name='Rose', age=19}, *Person{name='Jerry', age=20}, * Person{name='Tom', age=20}] */`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Set/HashSet%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"HashSet 实现类",slug:"hashset-实现类",content:""},{header:"HashSet 集合的特点",slug:"hashset-集合的特点",content:"无序性（即：存进去的顺序和取出来的顺序不一定一致） 无索引 唯一性，HashSet 类中的元素的不能重复"},{header:"常见的成员方法",slug:"常见的成员方法",content:"与 Set 集合一致"},{header:"HashSet 集合遍历",slug:"hashset-集合遍历",content:"转数组循环遍历 迭代器遍历 增强 for 循环遍历(for each)"},{header:"HashSet 存储字符串类型的数据",slug:"hashset-存储字符串类型的数据",content:""},{header:"HashSet 存储 Integer 类型的数据",slug:"hashset-存储-integer-类型的数据",content:""},{header:"HashSet 存储的数据类型可以不一致",slug:"hashset-存储的数据类型可以不一致",content:`package com.wuziqi.gobang.Set; import java.util.HashSet; public class HashSets { public static void main(String[] args) { HashSet<String> hs = new HashSet<String>(); hs.add("aaa"); hs.add("ccc"); hs.add("aaa"); // 唯一性：去重 hs.add("bbb"); System.out.println(hs); // [aaa, ccc, bbb] HashSet<Integer> hs1 = new HashSet<Integer>(); hs1.add(1); hs1.add(3); hs1.add(1); // 唯一性：去重 hs1.add(4); System.out.println(hs1); // [1, 3, 4] HashSet ts2 = new HashSet(); ts2.add(1); ts2.add("3"); ts2.add(true); System.out.println(ts2); // [1, 3, true] }
}`},{header:"HashSet 存储自定义的类默认不去重的问题",slug:"hashset-存储自定义的类默认不去重的问题",content:`去重：重写 hashCode()和 equals()方法package com.wuziqi.gobang.Set; import java.util.HashSet;
import java.util.Objects; public class HashSets { public static void main(String[] args) { HashSet<String> hs = new HashSet<String>(); hs.add("aaa"); hs.add("ccc"); hs.add("bbb"); hs.add("aaa"); System.out.println(hs); // [aaa, ccc, bbb] HashSet<Integer> hs1 = new HashSet<Integer>(); hs1.add(1); hs1.add(3); hs1.add(1); hs1.add(4); System.out.println(hs1); // [1, 3, 4] HashSet ts2 = new HashSet(); ts2.add(1); ts2.add("3"); ts2.add(true); System.out.println(ts2); // [1, 3, true] HashSet<Cat> ts3 = new HashSet<Cat>(); ts3.add(new Cat("Tom", 18)); ts3.add(new Cat("Tony", 20)); ts3.add(new Cat("Jerry", 18)); ts3.add(new Cat("Tom", 18)); ts3.add(new Cat("Tony", 21)); ts3.add(new Cat("Jessy", 18)); System.out.println(new Cat("Tom", 18).equals(new Cat("Tom", 18))); // false System.out.println(ts3); // [Cat{name='Tony', age=21}, Cat{name='Tom', age=18}, // Cat{name='Jessy', age=18}, Cat{name='Jerry', age=18}, // Cat{name='Tony', age=20}, Cat{name='Tom', age=18}] // 去重：重写hashCode和equals方法 }
}
class Cat{ private String name; private int age; public Cat(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Cat{" + "name='" + name + '\\'' + ", age=" + age + '}'; } // 去重的最终方案 @Override public boolean equals(Object o) { // return true; ：写死了 equals Cat c = (Cat) o; // 向下转型，获取到成员属性 return this.name.equals(c.name) && this.age == c.age; } @Override public int hashCode() { // return 1; ：写死了 hashCode // *12：为了避免出现 18 +12 = 12 + 18 这样的问题发生 // 还有比如 "Aa".hashCode() = "BB".hashCode() 这样的问题 // 这种问题出现了也没事，因为在equals方法中，会判断 name是否一致 return this.name.hashCode() + this.age * 12; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Set/LinkedHashSet%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"LinkedHashSet 实现类",slug:"linkedhashset-实现类",content:`与 HashSet实现类一样，唯一的不同就是 LinkedHashSet 实现类是有序的集合（即：存进去的顺序和取出来的顺序是一致的）
package com.wuziqi.gobang.Set; import java.util.LinkedHashSet; public class HashSets { public static void main(String[] args) { LinkedHashSet <String> lhs = new LinkedHashSet<String>(); lhs.add("aaa"); lhs.add("ccc"); lhs.add("bbb"); System.out.println(lhs); // [aaa, ccc, bbb] }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Set/Set%E6%8E%A5%E5%8F%A3.html",title:"",pathLocale:"/",contents:[{header:"Set 子接口",slug:"set-子接口",content:"需要导包，在 java.util 下；Set 也是接口，是 Collection 的子接口。"},{header:"Set 集合的特点",slug:"set-集合的特点",content:"无序性（即：存进去的顺序和取出来的顺序不一定一致） 无索引 唯一性，Set 集合中的元素的不能重复"},{header:"常见的成员方法",slug:"常见的成员方法",content:"与 Collection 集合一致"},{header:"Set 集合遍历",slug:"set-集合遍历",content:"转数组循环遍历 迭代器遍历 增强 for 循环遍历(for each)"},{header:"方法的使用案例",slug:"方法的使用案例",content:`package com.wuziqi.gobang.Set; import java.util.HashSet;
import java.util.Set; public class Demo01 { public static void main(String[] args) { Set<String> set = new <String> HashSet(); set.add("aaa"); set.add("bbb"); set.add("ccc"); // set.add(111);// 由于泛型，编译报错 Boolean b = set.add("aaa"); System.out.println(b); // 唯一性：false System.out.println(set); // 无序性：[aaa, ccc, bbb] }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/%E5%8D%95%E5%88%97%E9%9B%86%E5%90%88Collection/Set/TreeSet%E5%AE%9E%E7%8E%B0%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"TreeSet 实现类",slug:"treeset-实现类",content:""},{header:"TreeSet 集合的特点",slug:"treeset-集合的特点",content:"无序性（即：存进去的顺序和取出来的顺序不一定一致） 无索引 唯一性，TreeSet 类中的元素的不能重复 可以排序的(按照规则排序，默认按照字典顺序由小到大)"},{header:"常见的成员方法",slug:"常见的成员方法",content:"与 Set 集合一致"},{header:"TreeSet 集合遍历",slug:"treeset-集合遍历",content:"转数组循环遍历 迭代器遍历 增强 for 循环遍历(for each)"},{header:"TreeSet 存储字符串类型的数据",slug:"treeset-存储字符串类型的数据",content:"按照字典顺序，由小到大排序"},{header:"TreeSet 存储 Integer 类型的数据",slug:"treeset-存储-integer-类型的数据",content:`按照数字的大小，由小到大排序package com.wuziqi.gobang.Set; import java.util.TreeSet; public class TreeSets { public static void main(String[] args) { TreeSet<String> ts = new TreeSet<String>(); ts.add("aaa"); ts.add("ccc"); ts.add("bbb"); System.out.println(ts); // 按照字典顺序，由小到大：[aaa, bbb, ccc] TreeSet<Integer> ts1 = new TreeSet<Integer>(); ts1.add(1); ts1.add(3); ts1.add(2); System.out.println(ts1); // 按照数字大小由小到大：1 2 3 }
}`},{header:"TreeSet 存储的数据类型不一致的问题",slug:"treeset-存储的数据类型不一致的问题",content:`TreeSet 一般与泛型一起使用package com.wuziqi.gobang.Set; import java.util.TreeSet; public class TreeSets { public static void main(String[] args) { TreeSet ts2 = new TreeSet(); ts2.add(1); ts2.add("3"); ts2.add(true); // 运行时期异常：因为底层排序没有规则， // 所以出现类型转换异常，因此一般与泛型一起使用 System.out.println(ts2); }
}`},{header:"TreeSet 存储自定义的类的问题",slug:"treeset-存储自定义的类的问题",content:`如果存储的是自定义类，需要构造 Comparable 或者 Comparator，不然也会报类型转换异常package com.wuziqi.gobang.Set; import java.util.TreeSet; public class TreeSets { public static void main(String[] args) { TreeSet<Pig> ts3 = new TreeSet<Pig>(); ts3.add(new Pig("小猪", 1)); ts3.add(new Pig("小猪", 2)); // 运行时期异常：没有给排序规则，类型转换异常， // 因此需要Comparable 或者 Comparator System.out.println(ts3); }
}
class Pig{ private String name; private int age; public Pig(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Pig{" + "name='" + name + '\\'' + ", age=" + age + '}'; }
}`},{header:"TreeSet 存储自定义的类需要满足的条件",slug:"treeset-存储自定义的类需要满足的条件",content:"自然排序 Comparable 如何实现自然排序？ 自定义的这个类要实现 Comparable 接口 重写 compareTo 抽象方法 在 compareTo 方法中定义排序规则 return 0：集合中的元素只有一个 return 正数：集合中的元素按照正序排列 return 负数：集合中的元素按照倒序排列 比较器 Comparator 如何实现比较器？ 自定义类 创建 TreeSet 对象时，在构造方法中传递 Comparator 的对象 重写 compareTo 抽象方法 在 compare() 方法中定义排序规则 return 0：集合中的元素只有一个 return 正数：集合中的元素按照正序排列 return 负数：集合中的元素按照倒序排列"},{header:"Comparable",slug:"comparable",content:`// Comparable 自然排序
package com.wuziqi.gobang.Set; import java.util.TreeSet; public class TreeSets { public static void main(String[] args) { TreeSet<Pig> ts3 = new TreeSet<Pig>(); ts3.add(new Pig("小猪", 1)); ts3.add(new Pig("小猪", 2)); System.out.println(ts3); }
}
class Pig implements Comparable<Pig>{ private String name; private int age; public Pig(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Pig{" + "name='" + name + '\\'' + ", age=" + age + '}'; } @Override public int compareTo(Pig o) { return 0; /** * return 0：[Pig{name='小猪', age=1}] * return 正数：[Pig{name='小猪', age=1}, Pig{name='小猪', age=2}] * return 负数：[Pig{name='小猪', age=2}, Pig{name='小猪', age=1}] */ }
}`},{header:"Comparator",slug:"comparator",content:`// Comparator 比较器
package com.wuziqi.gobang.Set; import java.util.Comparator;
import java.util.TreeSet; public class TreeSets { public static void main(String[] args) { TreeSet<Dog> ts4 = new TreeSet<Dog>(new Comparator<Dog>() { @Override public int compare(Dog o1, Dog o2) { return 0; /** * return 0：[Dog{name='小狗', age=18}] * return 正数：[Dog{name='小狗', age=18}, Dog{name='小狗', age=30}] * return 负数：[Dog{name='小狗', age=30}, Dog{name='小狗', age=18}] */ } }); ts4.add(new Dog("小狗", 18)); ts4.add(new Dog("小狗", 30)); System.out.println(ts4); }
}
class Dog { private String name; private int age; public Dog(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return "Dog{" + "name='" + name + '\\'' + ", age=" + age + '}'; }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E7%AC%A6%E6%B5%81/%E5%86%99%E5%85%A5/BufferedReader%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"BufferedReader 类",slug:"bufferedreader-类",content:"缓冲字符输出流、有缓冲区、高效"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public BufferedReader(Reader in)
读取给定 File 对象的文件`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public void flush
刷新缓冲区 public void close
释放资源，同时自带刷新缓冲区的功能 其他方法
同 FileReader`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZiFuInput; import java.io.BufferedReader;
import java.io.FileReader; public class BufferedReader01 { public static void main(String[] args) throws Exception { /* FileReader fr = new FileReader("aaa/111.txt"); BufferedReader br = new BufferedReader(fr); */ BufferedReader br = new BufferedReader(new FileReader("aaa/111.txt")); int len = 0; while( (len = br.read()) != -1){ System.out.print((char)len); } }
}`},{header:"特有的成员方法",slug:"特有的成员方法",content:`方法
作用 public String readLine()
一次读取一行，返回值是 String 类型，读不到返回 null package com.wuziqi.gobang.IO.ZiFuInput; import java.io.BufferedReader;
import java.io.FileReader; public class BufferedReadLine { public static void main(String[] args) throws Exception{ // public String readLine()：一次读取一行，没有就是null BufferedReader br = new BufferedReader(new FileReader("aaa/111.txt")); /* String s1 = br.readLine(); String s2 = br.readLine(); String s3 = br.readLine(); String s4 = br.readLine(); String s5 = br.readLine(); System.out.println(s1); System.out.println(s2); System.out.println(s3); System.out.println(s4); System.out.println(s5); // ai约不约？随便吧。 // 字符流嘛 // 必须来点中文啊 // null // null */ String line = null; while ((line = br.readLine()) != null) { System.out.println(line); } // ai约不约？随便吧。 // 字符流嘛 // 必须来点中文啊 }
}`},{header:"文件的复制",slug:"文件的复制",content:`package com.wuziqi.gobang.IO.ZiFuInput; import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileReader;
import java.io.FileWriter; public class BufferedCopy01 { public static void main(String[] args) throws Exception{ // 1.一次读取一个字符，一次写入一个字符 /* BufferedReader br = new BufferedReader(new FileReader("aaa/111.txt")); BufferedWriter bw = new BufferedWriter(new FileWriter("aaa/222.txt")); int ch = 0; while((ch = br.read()) != -1){ bw.write(ch); } bw.close(); br.close(); */ // 2.一次读取一个字符数组，一次写入一个字符数组一部分 /* BufferedReader br = new BufferedReader(new FileReader("aaa/111.txt")); BufferedWriter bw = new BufferedWriter(new FileWriter("aaa/222.txt")); char[] chs = new char[1024]; int len = 0; while((len = br.read(chs)) != -1){ bw.write(chs, 0, len); } bw.close(); br.close(); */ // 3.一次读取一行，一次写入行 //（这种方式最后总会多出来一个空行，如果不在意可以使用） BufferedReader br = new BufferedReader(new FileReader("aaa/111.txt")); BufferedWriter bw = new BufferedWriter(new FileWriter("aaa/555.txt")); String line = null; while ((line = br.readLine()) != null) { bw.write(line, 0, line.length()); bw.newLine(); } bw.close(); br.close(); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E7%AC%A6%E6%B5%81/%E5%86%99%E5%85%A5/FileReader%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"FileReader 类",slug:"filereader-类",content:""},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public FileReader(String fileName)
根据指定的文件名读取 public FileReader(File file)
根据指定的文件读取`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public int read()
一次读取一个字符数据 public int read(char[] cbuf)
一次读取一个字符数组，返回实际读取字符的个数 public int read(char[] cbuf, int off, int len)
一次读取一个字符数组的部分数据`},{header:"示例",slug:"示例",content:`package com.wuziqi.gobang.IO.ZiFuInput; import java.io.FileReader; public class FileReaderDemo01 { public static void main(String[] args) throws Exception { // public FileReader(String fileName) FileReader fr = new FileReader("aaa/111.txt"); System.out.println(fr); // java.io.FileReader@23fc625e // 一次读一个字符：public int read() /* int a = fr.read(); int a1 = fr.read(); int a2 = fr.read(); System.out.println(a); // 97 System.out.println(a1); // 105 System.out.println(a2); // 32422 System.out.println((char) a2); // 约 int a = 0; while( (a = fr.read()) != -1 ) { System.out.print((char) a); // ai约不约？随便吧。 } */ // 一次读取一个数组：public int read(char[] cbuf) /* char[] arr = new char[5]; int a = fr.read(arr); System.out.println(a); // 5 读到了5个字符 System.out.println(new String(arr)); // ai约不约 char[] arr = new char[5]; int a = 0; while( (a = fr.read(arr)) != -1 ) { System.out.print(new String(arr, 0, a)); // ai约不约？随便吧。 } */ // 一次读取一个数组的部分：public int read(char[] cbuf, int off, int len) char[] arr = new char[5]; int a = fr.read(arr, 1,3); System.out.println(a); // 3：读取到3个 System.out.println(new String(arr)); // ai约 }
}`},{header:"文件的复制",slug:"文件的复制",content:`package com.wuziqi.gobang.IO.ZiFuInput; import java.io.FileReader;
import java.io.FileWriter; public class FileCopy01 { public static void main(String[] args) throws Exception { // 一次读取一个字符，一次写入一个字符 /* FileReader fr = new FileReader("aaa/111.txt"); FileWriter fw = new FileWriter("aaa/222.txt"); int len = 0; while( (len = fr.read()) != -1){ fw.write(len); } fw.close(); fr.close(); */ // 一次读取一个字符数组，一次写入一个字符数组的一部分 FileReader fr = new FileReader("aaa/111.txt"); FileWriter fw = new FileWriter("aaa/222.txt"); char [] ch = new char[1024]; int len = 0; while( (len = fr.read(ch)) != -1){ fw.write(ch,0,len); } fw.close(); fr.close(); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E7%AC%A6%E6%B5%81/%E8%BE%93%E5%87%BA/BufferedWriter%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"BufferedWriter 类",slug:"bufferedwriter-类",content:"缓冲字符输出流、有缓冲区、高效"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public BufferedWriter(Writer out)
将输出流写到给定 File 对象的文件`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public void close
释放资源，同时自带刷新缓冲区的功能 其他方法
同 FileWriter`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZiFuOutput; import java.io.BufferedWriter;
import java.io.FileWriter; public class BufferedWriter01 { public static void main(String[] args) throws Exception{ /* FileWriter fw = new FileWriter("aaa/222.txt"); BufferedWriter bw = new BufferedWriter(fw); */ BufferedWriter bw = new BufferedWriter(new FileWriter("aaa/222.txt")); }
}`},{header:"特有的成员方法",slug:"特有的成员方法",content:`方法
作用 public void newLine()
换行(不用考虑系统，自动切换；"\\r\\n"换行时要考虑系统) package com.wuziqi.gobang.IO.ZiFuOutput; import java.io.BufferedWriter;
import java.io.FileWriter; public class BufferedNewLine { public static void main(String[] args) throws Exception{ // public void newLine()：相当于换行符 BufferedWriter bw = new BufferedWriter(new FileWriter("aaa/444.txt")); bw.newLine(); bw.newLine(); bw.newLine(); bw.write("都到这行了!"); bw.flush(); bw.close(); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E7%AC%A6%E6%B5%81/%E8%BE%93%E5%87%BA/FileWriter%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"FileWriter 类",slug:"filewriter-类",content:""},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public FileWriter(File file)
将输出流写到给定 File 对象的文件中 public FileWriter(File file, boolean append)
同上，追加 public FileWriter(String fileName)
将输出流写到指定名字的文件中 public FileWriter(String fileName, boolean append)
同上并追加`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public void close
释放资源 public void flush
刷新 public void write(int c)
写入一个字符数据 public void write(char[] cbuf)
写入一个字符数组数据 public void write(char[] cbuf, int off, int len)
写入一个字符数组的一部分数据 public void write(String str)
写入一个字符串数据 public void write(String str, int off, int len)
写入一个字符串的一部分数据`},{header:"示例",slug:"示例",content:`package com.wuziqi.gobang.IO.ZiFuOutput; import java.io.FileWriter; public class FileWriterDemo01 { public static void main(String[] args) throws Exception { // 给定了一个不存在的文件，那么会自动创建 // public FileWriter(String fileName) FileWriter fw = new FileWriter("aaa/111.txt"); System.out.println(fw); // java.io.FileWriter@23fc625e // public void write(int c) fw.write(97); // a fw.write(105); // i // public void write(char[] cbuf) char[] cbuf = {'约', '不'}; fw.write(cbuf); // 约不 // public void write(char[] cbuf, int off, int len) fw.write(cbuf, 0, 1); // 约 // public void write(String str) fw.write("？"); // ？ // public void write(String str, int off, int len) fw.write("？随便吧。爱约不约", 1, 4); // 随便吧。 fw.flush(); fw.close(); // ai约不约？随便吧。 }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E8%8A%82%E6%B5%81/%E5%86%99%E5%85%A5/BufferedInputStream%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"BufferedInputStream 类",slug:"bufferedinputstream-类",content:"缓冲字节输入流、有缓冲区、高效"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public BufferedInputStream(InputStream in)
读取给定的已经存在的文件中的数据`},{header:"常见的成员方法",slug:"常见的成员方法",content:"同 FileInputStream"},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZiJieInput; import java.io.BufferedInputStream;
import java.io.FileInputStream; public class DemoBufferedInputStream { public static void main(String[] args) throws Exception { // public BufferedInputStream(FileInputStream in) // 有参构造的原因是因为底层，使用的是装饰设计模式 // FileInputStream fis = new FileInputStream("aaa/bbb.txt"); // BufferedInputStream bis = new BufferedInputStream(fis); BufferedInputStream bis = new BufferedInputStream(new FileInputStream("aaa/bbb.txt")); // 读取 // 一次读取一个字节 int by = 0; while ((by = bis.read()) != -1) { System.out.print((char) by); } // 一次读取一个数组的字节 byte[] bys = new byte[5]; int len = 0; while ((len = bis.read(bys)) != -1) { System.out.print(new String(bys, 0, len)); } }
}`},{header:"文件复制",slug:"文件复制",content:`// 方式一(一次读取一个字节，一次写入一个字节)
package com.wuziqi.gobang.IO.ZiJieInput; import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream; public class DemoCopyBuffer1 { public static void main(String[] args) throws Exception { // 创建一个字节输入流对象 BufferedInputStream fis = new BufferedInputStream( new FileInputStream("aaa/bbb.txt") ); // 创建一个字节输出流对象 BufferedOutputStream fos = new BufferedOutputStream( new FileOutputStream("aaa/b.txt") ); // 一次读取一个字节，一次写入一个字节 int by = 0; while ((by = fis.read()) != -1) { fos.write(by); } // 释放资源，关闭流 fis.close(); fos.close(); }
}`},{header:"复制文件(高效)",slug:"复制文件-高效",content:`// 方式二(一次读取一个字节数组，一次写入一个字节数组的一部分)
package com.wuziqi.gobang.IO.ZiJieInput; import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.FileInputStream;
import java.io.FileOutputStream; public class DemoCopyBuffer2 { public static void main(String[] args) throws Exception { // 创建字节输入流对象 BufferedInputStream fis = new BufferedInputStream(new FileInputStream("aaa/b.txt")); // 创建字节输出流对象 BufferedOutputStream fos = new BufferedOutputStream(new FileOutputStream("aaa/a.txt")); // 一次读取一个字节数组，一次写入一个字节数组的一部分 byte[] bys = new byte[5]; int len = 0; while( (len = fis.read(bys)) != -1 ){ fos.write(bys, 0, len); } // 释放资源 fis.close(); fos.close(); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E8%8A%82%E6%B5%81/%E5%86%99%E5%85%A5/FileInputStream%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"FileInputStream 类.md",slug:"fileinputstream-类-md",content:""},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public FileInputStream(File file)
读取给定的已经存在的文件中的数据 public FileInputStream(String name)
作用同上`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public int read()
读取一个字节大小的数据 public int read(byte[] b)
实际上读取到了几个字符的个数 public int read(byte[] b,int off,int len)
读取文件中字节数组的一部分`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZiJieInput; import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.Arrays; public class DemoFileInputStream { public static void main(String[] args) throws IOException { // 在aaa.txt文件中读取一个字节长度的内容 // public FileInputStream(File file) File file1 = new File("aaa/bbb.txt"); FileInputStream fis = new FileInputStream(file1); /* * public int read(): 每次读取一个字节，返回一个int类型的值 * 返回值：如果读取到了，返回一个字节对应int值，如果到了末尾，开始返回-1 * 每次执行都会继续读取，直到读取到末尾 * 当前文件中只有abc三个字符，所以读取到abc后，再读取就会返回-1 */ int by1 = fis.read(); System.out.println((char)by1); // a int by2 = fis.read(); System.out.println((char)by2); // b int by3 = fis.read(); System.out.println((char)by3); // c int by4 = fis.read(); System.out.println(by4); // -1 int by5 = fis.read(); System.out.println(by5); // -1 /* * 循环读取1： * 上边是已知当前文件有三个字符， * 假设不知道一个文件有多少个字符， * 可以用当前的循环方法 */ int byt1 = fis.read(); while(byt1 !=-1){ System.out.println((char)byt1); byt1 = fis.read(); } //循环读取2：循环1的优化 int byt2 = 0; while((byt2 = fis.read()) !=-1){ System.out.println((char)byt2); } /* * public int read(byte[] b): 实际上读取到了几个字符的个数 * new byte[n]: 会读取n个字符，但是实际读取要看文件中的字符个数； * 如果文件中的字符个数超过了n，则当前返回值就是n； * 如果文件中的字符个数不足n，则当前返回值就是实际读取到的字符个数； * 其中，读取到的字符内容，会给到new byte[n]，所以最好用一个变量接收便于使用 */ byte[] byts1 = new byte[3]; int number0 = fis.read(byts1); System.out.println(number0); // 3 System.out.println(Arrays.toString(byts1)); // [97, 98, 99] String sss = new String(byts1); System.out.println(sss); // [a, b, c] int number1 = fis.read(new byte[4]); System.out.println(number1); // 3 int number2 = fis.read(new byte[5]); System.out.println(number2); // 3 int number3 = fis.read(new byte[2]); System.out.println(number3); // 2 int number4 = fis.read(new byte[1]); System.out.println(number4); // 1 /* * 循环读取：上边是已知文件字符数，如果不知道的话就需要循环了 * 每次读n个 * 直到读取的个数为 -1，即没读取到，结束 */ byte[] bytes = new byte[5]; int len = 0; while( (len = fis.read(bytes)) !=-1){ String s = new String(bytes, 0, len); System.out.println(s); } }
}`},{header:"关闭流",slug:"关闭流",content:`方法
作用 public void close
关闭输入流或者输出流`},{header:"文件复制",slug:"文件复制",content:`// 方式一(一次读取一个字节，一次写入一个字节)
package com.wuziqi.gobang.IO.ZiJieInput; import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException; public class DemoCopyFile1 { public static void main(String[] args) throws IOException { // 创建一个字节输入流对象 FileInputStream fis = new FileInputStream("aaa/bbb.txt"); // 创建一个字节输出流对象 FileOutputStream fos = new FileOutputStream("aaa/b.txt"); // 一次读取一个字节，一次写入一个字节 int by = 0; while ((by = fis.read()) != -1) { fos.write(by); } // 释放资源，关闭流 fis.close(); fos.close(); }
}
// 方式二(一次读取一个字节数组，一次写入一个字节数组的一部分)
package com.wuziqi.gobang.IO.ZiJieInput; import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException; public class DemoCopyFile2 { public static void main(String[] args) throws IOException { // 创建字节输入流对象 FileInputStream fis = new FileInputStream("aaa/b.txt"); // 创建字节输出流对象 FileOutputStream fos = new FileOutputStream("aaa/a.txt"); // 一次读取一个字节数组，一次写入一个字节数组的一部分 byte[] bys = new byte[5]; int len = 0; while( (len = fis.read(bys)) != -1 ){ fos.write(bys, 0, len); } // 释放资源 fis.close(); fos.close(); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E8%8A%82%E6%B5%81/%E8%BE%93%E5%87%BA/BufferedOutputStream%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"BufferedOutputStream 类",slug:"bufferedoutputstream-类",content:"缓冲字节输出流、有缓冲区、高效"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public BufferedInputStream(OutputStream out)
将输出流写到给定 File 对象的文件`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public void flush
刷新缓冲区 public void close
释放资源，同时自带刷新缓冲区的功能 其他方法
同 FileOutputStream`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZiJieOutput; import java.io.BufferedOutputStream;
import java.io.FileOutputStream; public class DemoBufferedIOutputStream { public static void main(String[] args) throws Exception { // public BufferedOutputStream(FileOutputStream out) // 有参构造的原因是因为底层，使用的是装饰设计模式 // FileOutputStream fos = new FileOutputStream("aaa/bbb.txt"); // BufferedOutputStream bos = new BufferedOutputStream(fos); BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("aaa/bbb.txt", true)); // 写出数据 // 一次写出一个字节 bos.write(97); bos.write(97); bos.write(99); bos.write(98); // 刷新缓冲区，否则数组一直在缓冲区，没有写入，导致文件一直是空白的 bos.flush(); // 一次写出一个数组长度的字节 byte[] bytes = {97, 98, 99, 100, 101, 102, 103, 104}; // 换行 bos.write("\\r\\n".getBytes()); bos.write(bytes); // 缓冲 bos.flush(); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AD%97%E8%8A%82%E6%B5%81/%E8%BE%93%E5%87%BA/FileOutputStream%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"FileOutputStream 类.md",slug:"fileoutputstream-类-md",content:""},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public FileOutputStream(File file)
将输出流写到给定 File 对象的文件中 public FileOutputStream(String name)
作用同上，区别先去创建一个文件对象 public FileOutputStream(String name, Boolean append)
目的同上，但是与上边两个不同点是可以控制是否追加`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 public void write(int b)
在文件中写一个字节大小的数据 public void write(byte[] b)
将一个字节数组写到文件中 public void write(byte[] b,int off,int len)
将字节数组的一部分写到文件中，从 off 位置开始，写入 len 个`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZiJieOutput; import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException; public class DemoFileOutputStream { public static void main(String[] args) throws IOException { // aaa目录对象 File file = new File("aaa"); // 创建aaa目录对象 boolean isFolderAaa = file.mkdir(); // aaa.txt文件对象 File file1 = new File("aaa.txt"); // 创建aaa.txt文件 boolean isTxtAaa = file1.createNewFile(); // bbb.txt文件对象 File file2 = new File(file,"bbb.txt"); // 在aaa目录下创建bbb.txt文件 boolean isTxtBbb = file2.createNewFile(); // 在aaa.txt文件中写入一个字节长度的内容 // public FileOutputStream(File file) FileOutputStream fos = new FileOutputStream(file1); // public void write(int b) fos.write(1); // 在文件中是一个字符长度的二进制乱码  fos.write(97); // 在文件中表现为a // 两个添加执行完成后文件中内容为a // 但是整个程序再执行一次的时候，默认文件是空着的，重新添加内容 // 在bbb.txt文件中写入一个字节数组，或者说多个字节的内容 // public void write(byte[] b) byte[] bytes = {97, 98, 99, 100, 101, 102, 103, 104}; FileOutputStream fosb = new FileOutputStream(file2); fosb.write(bytes);// 文件中内容为 abcdefghi fosb.write(bytes, 2, 3);// 文件中内容为 cde // 两个方法执行完成后文件中内容为abcdefghcde // 但是整个程序再执行一次的时候，默认文件是空着的，重新添加内容 }
}`},{header:"两个小问题",slug:"两个小问题",content:`如何换行？ 换行符：
windows：\\r\\n
linux：\\n
mac：\\r FileOutputStream fosb = new FileOutputStream("aaa.txt");
/* * write(byte[] b) * getBytes: 将字符串转换为字节数组
*/
fosb.write("\\r\\n".getBytes()); 如何追加？
正常情况下每次运行程序，文件都会被清空，如果想要追加，需要使用第三个构造方法，并且需要传入一个布尔值，传入 true 表示追加，传入 false 表示覆盖；默认是 false。 // public FileOutputStream(String name, Boolean append)
FileOutputStream fosb = new FileOutputStream(file2, true);`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%B5%81/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/ObjectOutputStream%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"ObjectOutputStream 类",slug:"objectoutputstream-类",content:"反序列化流 反序列化：将本地磁盘中的对象，以流的形式，还原成内存中的对象"}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%B5%81/%E5%BA%8F%E5%88%97%E5%8C%96/ObjectInputStream%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"ObjectInputStream 类",slug:"objectinputstream-类",content:"序列化流 序列化：将内存中的对象，以流的形式，从内存中写出到本地"}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E8%BD%AC%E6%8D%A2%E6%B5%81/%E8%BE%93%E5%85%A5/InputStreamReader%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"InputStreamReader 类",slug:"inputstreamreader-类",content:"转换流可以将字节流转换成字符流"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public InputStreamReader(InputStream in)
创建一个使用默认字符编码的 InputStreamReader public InputStreamReader(InputStream in, String charsetName)
创建一个使用指定字符编码的 InputStreamReader`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 方法
同 FileReader`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZhuanhuanInput; import java.io.FileInputStream;
import java.io.InputStreamReader; public class InputStreamReader01 { public static void main(String[] args) throws Exception{ // public InputStreamReader(InputStream in) /* FileInputStream fis = new FileInputStream("aaa/111.txt"); InputStreamReader isr = new InputStreamReader(fis); */ InputStreamReader isr = new InputStreamReader(new FileInputStream("aaa/111.txt")); int len = 0; while( (len = isr.read()) != -1){ System.out.print((char)len); } }
}`},{header:"转换流文件复制",slug:"转换流文件复制",content:`package com.wuziqi.gobang.IO.ZhuanhuanInput; import java.io.*; public class FileCopy1 { public static void main(String[] args) throws Exception { // 1. 一次读取一个字符，一次写出一个字符 InputStreamReader isr = new InputStreamReader( new FileInputStream("aaa/111.txt") ); OutputStreamWriter osw = new OutputStreamWriter( new FileOutputStream("aaa/222.txt") ); int ch = 0; while ((ch = isr.read()) != -1) { osw.write(ch); } osw.close(); isr.close(); // 2. 一次读取一个字符数组，一次写出一个字符数组的一部分 InputStreamReader isr = new InputStreamReader( new FileInputStream("aaa/111.txt") ); OutputStreamWriter osw = new OutputStreamWriter( new FileOutputStream("aaa/222.txt") ); char[] buf = new char[1024]; int len = 0; while ((len = isr.read(buf)) != -1){ osw.write(buf,0,len); } osw.close(); isr.close(); // 3. 用BufferedReader增强，一次读取一行并写入一行 BufferedReader br = new BufferedReader( new InputStreamReader(new FileInputStream("aaa/111.txt")) ); BufferedWriter bw = new BufferedWriter( new OutputStreamWriter(new FileOutputStream("aaa/222.txt")) ); String line = null; while ((line = br.readLine()) != null){ bw.write(line); bw.newLine(); } bw.close(); br.close(); // 4. 一次读取一个字符数组，一次写入一个字符数组的一部分(高效) BufferedReader br = new BufferedReader( new InputStreamReader(new FileInputStream("aaa/111.txt")) ); BufferedWriter bw = new BufferedWriter( new OutputStreamWriter(new FileOutputStream("aaa/222.txt")) ); char[] buf = new char[1024]; int len = 0; while ((len = br.read(buf)) != -1){ bw.write(buf,0,len); } bw.close(); br.close(); // 5. 一次读取一个字符，一次写出一个字符(高效) BufferedReader br = new BufferedReader( new InputStreamReader(new FileInputStream("aaa/111.txt")) ); BufferedWriter bw = new BufferedWriter( new OutputStreamWriter(new FileOutputStream("aaa/222.txt")) ); int ch = 0; while ((ch = br.read()) != -1) { bw.write(ch); } bw.close(); br.close(); }
}`}]},{path:"/admin/Java/Java%E5%B8%B8%E7%94%A8Api/IO%E6%B5%81/%E8%BD%AC%E6%8D%A2%E6%B5%81/%E8%BE%93%E5%87%BA/OutputStreamWriter%E7%B1%BB.html",title:"",pathLocale:"/",contents:[{header:"OutputStreamWriter 类",slug:"outputstreamwriter-类",content:"转换流可以将字节流转换成字符流"},{header:"常见的构造方法",slug:"常见的构造方法",content:`方法
作用 public OutputStreamWriter(OutputStream out)
创建一个使用默认字符编码的 OutputStreamWriter public OutputStreamWriter(OutputStream out, String charsetName)
创建一个使用命名字符编码的 OutputStreamWriter`},{header:"常见的成员方法",slug:"常见的成员方法",content:`方法
作用 方法
同 FileWriter`},{header:"方法的使用",slug:"方法的使用",content:`package com.wuziqi.gobang.IO.ZhuanhuanOutput; import java.io.FileOutputStream;
import java.io.OutputStreamWriter; public class OutputStreamWriter01 { public static void main(String[] args) throws Exception{ // public OutputStreamWriter(OutputStream out) /* FileOutputStream fos = new FileOutputStream("aaa/111.txt"); OutputStreamWriter osw = new OutputStreamWriter(fos); */ OutputStreamWriter osw = new OutputStreamWriter( new FileOutputStream("aaa/111.txt") ); }
}`}]},{path:"/404.html",title:"",pathLocale:"/",contents:[{header:"",slug:"",content:"404 Not Found"}]},{path:"/category/",title:"Categories",pathLocale:"/",contents:[]},{path:"/category/history/",title:"Category History",pathLocale:"/",contents:[]},{path:"/category/categorya/",title:"Category CategoryA",pathLocale:"/",contents:[]},{path:"/category/categoryb/",title:"Category CategoryB",pathLocale:"/",contents:[]},{path:"/category/categoryc/",title:"Category CategoryC",pathLocale:"/",contents:[]},{path:"/tag/",title:"Tags",pathLocale:"/",contents:[]},{path:"/tag/wwi/",title:"Tag WWI",pathLocale:"/",contents:[]},{path:"/tag/wwii/",title:"Tag WWII",pathLocale:"/",contents:[]},{path:"/tag/tag-a/",title:"Tag tag A",pathLocale:"/",contents:[]},{path:"/tag/tag-b/",title:"Tag tag B",pathLocale:"/",contents:[]},{path:"/tag/tag-c/",title:"Tag tag C",pathLocale:"/",contents:[]},{path:"/tag/tag-d/",title:"Tag tag D",pathLocale:"/",contents:[]},{path:"/tag/tag-e/",title:"Tag tag E",pathLocale:"/",contents:[]},{path:"/article/",title:"Articles",pathLocale:"/",contents:[]},{path:"/timeline/",title:"Timeline",pathLocale:"/",contents:[]}],V="update-vuepress-plugin-full-text-search2-search-index";var A=S(R),z=B(()=>{const t=new Map;for(const e of A.value)t.set(e.path,e);return t});import.meta.webpackHot&&(__VUE_HMR_RUNTIME__[V]=t=>{A.value=t});function W(t){const e=S([]);let l=null;return O(t,()=>{l&&clearTimeout(l),l=setTimeout(i,100)}),e;function i(){const u=t.value.toLowerCase().trim();if(!u){e.value=[];return}const r=new Map,n=new Set;for(const a of A.value)for(const s of q(a,u)){n.add(s.parentPageTitle);let o=r.get(s.parentPageTitle);o||(o=[],r.set(s.parentPageTitle,o)),o.push(s)}const c=[...n].sort((a,s)=>{const o=r.get(a);return r.get(s).length-o.length});e.value=[...r].flatMap(([,a])=>a).sort((a,s)=>a.parentPagePriority-s.parentPagePriority||c.indexOf(a.parentPageTitle)-c.indexOf(s.parentPageTitle)||a.priority-s.priority)}}function*q(t,e){const l=w(t.title,e);if(l){yield{path:t.path,parentPageTitle:E(t),title:t.title,display:l,page:t,content:null,parentPagePriority:1,priority:1};return}for(const i of t.contents){const u=w(i.header,e);if(u){yield{path:t.path+(i.slug?`#${i.slug}`:""),parentPageTitle:E(t),title:t.title,display:u,page:t,content:null,parentPagePriority:10,priority:2};continue}const r=w(i.content,e);r&&(yield{path:t.path+(i.slug?`#${i.slug}`:""),parentPageTitle:E(t),title:t.title,display:[{type:"header",str:`${i.header}
`},...r],page:t,content:null,parentPagePriority:10,priority:10})}}function E(t){const e=t.path.split("/");let l="/";return e[1]&&(l=`/${e[1]}/`),(z.value.get(l)||t).title}function w(t,e){const l=[];let i=0;const u=t.toLowerCase().replace(/\s/gu," ");let r=0,n=u.indexOf(e,r);if(n<0)return null;for(;n>=0;){const a=n+e.length;if(c(t.slice(r,n),"normal"),c(t.slice(n,a),"highlight"),r=a,n=u.indexOf(e,r),i>100)break}return c(t.slice(r),"normal"),l.filter(a=>a.str);function c(a,s){let o=a;s==="normal"&&o.length>100&&i===0&&(o=`… ${o.slice(-10)}`);let g=!1;if(i+o.length>100){if(l.some(h=>h.type==="ellipsis"))return;o=o.slice(0,Math.max(100-i,1)),g=!0}l.push({type:s,str:o}),i+=o.length,g&&(l.push({type:"ellipsis",str:" …"}),i+=2)}}var Z={"/":{placeholder:"标题搜索"}};const $=Z,U=j({name:"SearchBox",props:{locales:{type:Object,required:!1,default:()=>$}},setup(t){const{locales:e}=P(t),l=S(""),i=S(!1),u=S(-1),r=W(l),n=B(()=>l.value&&i.value&&r.value.length),c=T(),a=k(),s=B(()=>e.value[a.value]??{});function o(){if(!n.value)return;let p=u.value-1;p<0&&(p=r.value.length-1),h(p)}function g(){if(!n.value)return;let p=u.value+1;p>=r.value.length&&(p=0),h(p)}function h(p){u.value=p}function C(){u.value=-1}function x(p){if(!n.value)return;const F=r.value[p];F&&c.push(F.path)}return{query:l,focused:i,focusIndex:u,suggestions:r,activeSuggestion:n,onUp:o,onDown:g,focus:h,unfocus:C,go:x,locale:s}}}),K={class:"search-box",role:"search"},_=["placeholder"],X=["onMousedown","onMouseenter"],Y=["href"],G={key:0,class:"parent-page-title"},Q={class:"suggestion-row"},tt={class:"page-title"},et={class:"suggestion-content"};function nt(t,e,l,i,u,r){return m(),d("div",K,[M(b("input",{ref:"input","onUpdate:modelValue":e[0]||(e[0]=n=>t.query=n),"aria-label":"Search",class:v({focused:t.focused}),placeholder:t.locale.placeholder??"Search",autocomplete:"off",spellcheck:"false",onFocus:e[1]||(e[1]=()=>t.focused=!0),onBlur:e[2]||(e[2]=()=>t.focused=!1),onKeyup:[e[3]||(e[3]=y(n=>t.go(t.focusIndex),["enter"])),e[4]||(e[4]=y((...n)=>t.onUp&&t.onUp(...n),["up"])),e[5]||(e[5]=y((...n)=>t.onDown&&t.onDown(...n),["down"]))]},null,42,_),[[N,t.query]]),t.activeSuggestion?(m(),d("ul",{key:0,class:"suggestions",onMouseleave:e[7]||(e[7]=(...n)=>t.unfocus&&t.unfocus(...n))},[(m(!0),d(L,null,I(t.suggestions,(n,c)=>(m(),d("li",{key:c,class:v(["suggestion",{focused:c===t.focusIndex}]),onMousedown:a=>t.go(c),onMouseenter:a=>t.focus(c)},[b("a",{href:n.path,onClick:e[6]||(e[6]=H(()=>{},["prevent"]))},[n.parentPageTitle&&(!t.suggestions[c-1]||t.suggestions[c-1].parentPageTitle!==n.parentPageTitle)?(m(),d("div",G,f(n.parentPageTitle),1)):D("",!0),b("div",Q,[b("div",tt,f(n.title||n.path),1),b("div",et,[(m(!0),d(L,null,I(n.display,(a,s)=>(m(),d("span",{key:s,class:v(a.type)},f(a.str),3))),128))])])],8,Y)],42,X))),128))],32)):D("",!0)])}const it=J(U,[["render",nt],["__scopeId","data-v-4f07616c"],["__file","SearchBox.vue"]]);export{it as default};
