import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "../app.Bl4XAEYy.mjs";
const _sfc_main = {};
function _sfc_ssrRender(_ctx, _push, _parent, _attrs) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h2 id="usememo-和-usecallback" tabindex="-1"><a class="header-anchor" href="#usememo-和-usecallback"><span>useMemo 和 useCallback</span></a></h2><p><code>useMemo</code> 和 <code>useCallback</code> 是 React 提供的两个 Hook，用于优化性能，它们通过记忆化来避免不必要的计算和渲染。以下是这两个 Hook 的关键技术点和概念：</p><h3 id="usememo" tabindex="-1"><a class="header-anchor" href="#usememo"><span><code>useMemo</code></span></a></h3><h3 id="_1-基本使用" tabindex="-1"><a class="header-anchor" href="#_1-基本使用"><span>1. 基本使用</span></a></h3><p><code>useMemo</code> 用于对高开销的计算进行记忆化，以优化性能。</p><div class="language-jsx line-numbers-mode" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useMemo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">expensiveCalculation</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 假设这是一个复杂的计算</span>
  <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> x<span class="token punctuation">,</span> y <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">useMemo</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">expensiveCalculation</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Result: </span><span class="token punctuation">{</span>result<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-依赖数组" tabindex="-1"><a class="header-anchor" href="#_2-依赖数组"><span>2. 依赖数组</span></a></h3><p><code>useMemo</code> 接受一个函数和一个依赖数组，只有当依赖项改变时，才会重新计算。</p><h3 id="_3-避免不必要的计算" tabindex="-1"><a class="header-anchor" href="#_3-避免不必要的计算"><span>3. 避免不必要的计算</span></a></h3><p><code>useMemo</code> 可以避免在每次渲染时都进行高开销的计算。</p><h3 id="_4-惰性计算" tabindex="-1"><a class="header-anchor" href="#_4-惰性计算"><span>4. 惰性计算</span></a></h3><p><code>useMemo</code> 可以用于惰性计算，即只有在需要时才进行计算。</p><h3 id="_5-与usememo结合使用" tabindex="-1"><a class="header-anchor" href="#_5-与usememo结合使用"><span>5. 与<code>useMemo</code>结合使用</span></a></h3><p><code>useMemo</code> 可以与 <code>useCallback</code> 结合使用，以确保传递给子组件的回调函数的稳定性。</p><h3 id="usecallback" tabindex="-1"><a class="header-anchor" href="#usecallback"><span><code>useCallback</code></span></a></h3><h3 id="_1-基本使用-1" tabindex="-1"><a class="header-anchor" href="#_1-基本使用-1"><span>1. 基本使用</span></a></h3><p><code>useCallback</code> 用于返回一个记忆化的回调函数，这个函数只有在依赖项改变时才会重新创建。</p><div class="language-jsx line-numbers-mode" data-ext="jsx" data-title="jsx"><pre class="language-jsx"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> useCallback <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">&#39;react&#39;</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">MyComponent</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span> doSomething <span class="token punctuation">}</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> handleDoSomething <span class="token operator">=</span> <span class="token function">useCallback</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>doSomething<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleDoSomething<span class="token punctuation">}</span></span><span class="token punctuation">&gt;</span></span><span class="token plain-text">Do Something</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_2-依赖数组-1" tabindex="-1"><a class="header-anchor" href="#_2-依赖数组-1"><span>2. 依赖数组</span></a></h3><p><code>useCallback</code> 接受一个函数和一个依赖数组，只有当依赖项改变时，才会重新创建函数。</p><h3 id="_3-避免不必要的渲染" tabindex="-1"><a class="header-anchor" href="#_3-避免不必要的渲染"><span>3. 避免不必要的渲染</span></a></h3><p><code>useCallback</code> 可以避免子组件因为父组件的重新渲染而不必要的重新渲染。</p><h3 id="_4-稳定性" tabindex="-1"><a class="header-anchor" href="#_4-稳定性"><span>4. 稳定性</span></a></h3><p><code>useCallback</code> 可以确保回调函数的引用稳定性，这对于传递给子组件或使用在<code>useEffect</code>中非常有用。</p><h3 id="_5-自定义-hook" tabindex="-1"><a class="header-anchor" href="#_5-自定义-hook"><span>5. 自定义 Hook</span></a></h3><p><code>useCallback</code> 可以用于创建自定义 Hook，以在多个组件间复用回调逻辑。</p><h3 id="_6-与usememo的区别" tabindex="-1"><a class="header-anchor" href="#_6-与usememo的区别"><span>6. 与<code>useMemo</code>的区别</span></a></h3><ul><li><code>useMemo</code> 用于优化高开销的计算。</li><li><code>useCallback</code> 用于优化回调函数的创建。</li></ul><h3 id="_7-性能注意事项" tabindex="-1"><a class="header-anchor" href="#_7-性能注意事项"><span>7. 性能注意事项</span></a></h3><ul><li>过度使用 <code>useMemo</code> 和 <code>useCallback</code> 可能会导致性能下降，因为它们会增加代码的复杂性。</li><li>应该在真的有性能瓶颈时才使用这两个 Hook。</li></ul><h3 id="_8-与react-memo结合使用" tabindex="-1"><a class="header-anchor" href="#_8-与react-memo结合使用"><span>8. 与<code>React.memo</code>结合使用</span></a></h3><p><code>useMemo</code> 和 <code>useCallback</code> 可以与 <code>React.memo</code> 结合使用，以避免组件的不必要的渲染。</p><h3 id="_9-惰性初始化" tabindex="-1"><a class="header-anchor" href="#_9-惰性初始化"><span>9. 惰性初始化</span></a></h3><p><code>useMemo</code> 和 <code>useCallback</code> 可以用于惰性初始化对象或函数。</p><h3 id="_10-避免深比较" tabindex="-1"><a class="header-anchor" href="#_10-避免深比较"><span>10. 避免深比较</span></a></h3><p>在依赖数组中，应避免进行深比较，因为这可能会导致性能问题。</p><h3 id="_11-避免在渲染阶段使用" tabindex="-1"><a class="header-anchor" href="#_11-避免在渲染阶段使用"><span>11. 避免在渲染阶段使用</span></a></h3><p><code>useMemo</code> 和 <code>useCallback</code> 应该谨慎使用，以避免在渲染阶段进行复杂的计算或创建函数。</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("../pages/web/React/React提升/Hooks/useMemo和useCallback.html.vue");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const useMemo_useCallback_html = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender], ["__file", "useMemo和useCallback.html.vue"]]);
const data = JSON.parse(`{"path":"/web/React/React%E6%8F%90%E5%8D%87/Hooks/useMemo%E5%92%8CuseCallback.html","title":"","lang":"zh-CN","frontmatter":{},"headers":[{"level":2,"title":"useMemo 和 useCallback","slug":"usememo-和-usecallback","link":"#usememo-和-usecallback","children":[{"level":3,"title":"useMemo","slug":"usememo","link":"#usememo","children":[]},{"level":3,"title":"1. 基本使用","slug":"_1-基本使用","link":"#_1-基本使用","children":[]},{"level":3,"title":"2. 依赖数组","slug":"_2-依赖数组","link":"#_2-依赖数组","children":[]},{"level":3,"title":"3. 避免不必要的计算","slug":"_3-避免不必要的计算","link":"#_3-避免不必要的计算","children":[]},{"level":3,"title":"4. 惰性计算","slug":"_4-惰性计算","link":"#_4-惰性计算","children":[]},{"level":3,"title":"5. 与useMemo结合使用","slug":"_5-与usememo结合使用","link":"#_5-与usememo结合使用","children":[]},{"level":3,"title":"useCallback","slug":"usecallback","link":"#usecallback","children":[]},{"level":3,"title":"1. 基本使用","slug":"_1-基本使用-1","link":"#_1-基本使用-1","children":[]},{"level":3,"title":"2. 依赖数组","slug":"_2-依赖数组-1","link":"#_2-依赖数组-1","children":[]},{"level":3,"title":"3. 避免不必要的渲染","slug":"_3-避免不必要的渲染","link":"#_3-避免不必要的渲染","children":[]},{"level":3,"title":"4. 稳定性","slug":"_4-稳定性","link":"#_4-稳定性","children":[]},{"level":3,"title":"5. 自定义 Hook","slug":"_5-自定义-hook","link":"#_5-自定义-hook","children":[]},{"level":3,"title":"6. 与useMemo的区别","slug":"_6-与usememo的区别","link":"#_6-与usememo的区别","children":[]},{"level":3,"title":"7. 性能注意事项","slug":"_7-性能注意事项","link":"#_7-性能注意事项","children":[]},{"level":3,"title":"8. 与React.memo结合使用","slug":"_8-与react-memo结合使用","link":"#_8-与react-memo结合使用","children":[]},{"level":3,"title":"9. 惰性初始化","slug":"_9-惰性初始化","link":"#_9-惰性初始化","children":[]},{"level":3,"title":"10. 避免深比较","slug":"_10-避免深比较","link":"#_10-避免深比较","children":[]},{"level":3,"title":"11. 避免在渲染阶段使用","slug":"_11-避免在渲染阶段使用","link":"#_11-避免在渲染阶段使用","children":[]}]}],"git":{"updatedTime":1728487189000,"contributors":[{"name":"OnionTin]","email":"2775376881@qq.com","commits":1}]},"filePathRelative":"web/React/React提升/Hooks/useMemo和useCallback.md","excerpt":"<!-- @format -->\\n<h2>useMemo 和 useCallback</h2>\\n<p><code>useMemo</code> 和 <code>useCallback</code> 是 React 提供的两个 Hook，用于优化性能，它们通过记忆化来避免不必要的计算和渲染。以下是这两个 Hook 的关键技术点和概念：</p>\\n<h3><code>useMemo</code></h3>\\n<h3>1. 基本使用</h3>\\n<p><code>useMemo</code> 用于对高开销的计算进行记忆化，以优化性能。</p>\\n<div class=\\"language-jsx\\" data-ext=\\"jsx\\" data-title=\\"jsx\\"><pre class=\\"language-jsx\\"><code><span class=\\"token keyword\\">import</span> <span class=\\"token punctuation\\">{</span> useMemo <span class=\\"token punctuation\\">}</span> <span class=\\"token keyword\\">from</span> <span class=\\"token string\\">'react'</span><span class=\\"token punctuation\\">;</span>\\n\\n<span class=\\"token keyword\\">function</span> <span class=\\"token function\\">expensiveCalculation</span><span class=\\"token punctuation\\">(</span><span class=\\"token parameter\\">x<span class=\\"token punctuation\\">,</span> y</span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token comment\\">// 假设这是一个复杂的计算</span>\\n  <span class=\\"token keyword\\">return</span> x <span class=\\"token operator\\">*</span> y<span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n\\n<span class=\\"token keyword\\">function</span> <span class=\\"token function\\">MyComponent</span><span class=\\"token punctuation\\">(</span><span class=\\"token parameter\\"><span class=\\"token punctuation\\">{</span> x<span class=\\"token punctuation\\">,</span> y <span class=\\"token punctuation\\">}</span></span><span class=\\"token punctuation\\">)</span> <span class=\\"token punctuation\\">{</span>\\n  <span class=\\"token keyword\\">const</span> result <span class=\\"token operator\\">=</span> <span class=\\"token function\\">useMemo</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span> <span class=\\"token operator\\">=&gt;</span> <span class=\\"token function\\">expensiveCalculation</span><span class=\\"token punctuation\\">(</span>x<span class=\\"token punctuation\\">,</span> y<span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">,</span> <span class=\\"token punctuation\\">[</span>x<span class=\\"token punctuation\\">,</span> y<span class=\\"token punctuation\\">]</span><span class=\\"token punctuation\\">)</span><span class=\\"token punctuation\\">;</span>\\n  <span class=\\"token keyword\\">return</span> <span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;</span>div</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token plain-text\\">Result: </span><span class=\\"token punctuation\\">{</span>result<span class=\\"token punctuation\\">}</span><span class=\\"token tag\\"><span class=\\"token tag\\"><span class=\\"token punctuation\\">&lt;/</span>div</span><span class=\\"token punctuation\\">&gt;</span></span><span class=\\"token punctuation\\">;</span>\\n<span class=\\"token punctuation\\">}</span>\\n</code></pre></div>"}`);
export {
  useMemo_useCallback_html as comp,
  data
};
